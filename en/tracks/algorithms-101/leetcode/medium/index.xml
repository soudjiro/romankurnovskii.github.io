<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Medium on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/</link><description>Recent content in Medium on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>2. Add Two Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2/</guid><description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. First accepted Idea:
Loop through lists add each value to the list reverse list calculate sum create linked list from reversed sum class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def createLinkedNode(values): head = ListNode(values[0]) current = head for i in values[1:]: node = ListNode(i) current.</description></item><item><title>3. Longest Substring Without Repeating Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3/</guid><description>LeetCode problem
Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. First accepted Idea:
Loop through string Calculate max count of elements in substring If get double element, then go back until get this element and do step 2. Proceed the main loop class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: uniqs = set() len_max = 0 len_current = 0 idx = 0 for i in s: if i in uniqs: len_max = max(len_max, len_current) len_current = 1 uniqs = set(i) for j in reversed(s[:idx]): if j == i: break else: len_current += 1 uniqs.</description></item><item><title>5. Longest Palindromic Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/5/</guid><description>LeetCode problem
Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same as the original string.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; First accepted Hints How can we reuse a previously computed palindrome to compute a larger palindrome?
How can we reuse a previously computed palindrome to compute a larger palindrome?</description></item><item><title>7. Reverse Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</link><pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/7/</guid><description>LeetCode problem
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321
Example 2:
Input: x = -123 Output: -321
Example 3:
Input: x = 120 Output: 21
First accepted Idea:
Convert number to int Remove minus if exist (or convert module of number) reverse class Solution: def reverse(self, x: int) -&amp;gt; int: reversed_int = [] str_int = str(x) if x &amp;lt; 0: str_int = str_int[1:] for i in reversed(range(len(str_int))): reversed_int.</description></item><item><title>8. String to Integer (atoi)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</link><pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/8/</guid><description>LeetCode problem
// .js /** * @param {string} s * @return {number} */ var myAtoi = function(s) { let res = 0; let num = parseInt(s); if(num &amp;gt;= 2147483648){ res = 2147483647; } else if (num &amp;lt;= -2147483648){ res = -2147483648; } else if (isNaN(num)) { res = 0; } else { res = num; } return res; };</description></item><item><title>11. Container With Most Water</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/11/</guid><description>LeetCode problem 11
Problem Statement The problem involves an array of integers height, where each element represents the height of a line. These lines, along with the x-axis, form a series of containers. Your goal is to find the two lines that form the container with the greatest area.
Naive Solution The naive solution is to consider all pairs of lines and calculate the area of water each pair can contain. You would keep track of the maximum area encountered.</description></item><item><title>15. 3Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/15/</guid><description>LeetCode problem
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description></item><item><title>17. Letter Combinations of a Phone Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</link><pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/17/</guid><description>LeetCode problem
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;] Example 2:
Input: digits = &amp;quot;&amp;quot; Output: [] First accepted class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: if not digits: return [] letters = [&amp;#39;&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] result = [&amp;#39;&amp;#39;] for d in digits: d = int(d) tmp = [] for letter in letters[d]: for word in result: word += letter tmp.</description></item><item><title>19. Remove Nth Node From End of List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/19/</guid><description>LeetCode problem 19
Given the &amp;lsquo;head&amp;rsquo; of a linked list, remove the &amp;rsquo;nth&amp;rsquo; node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Idea:
Two pointers. Second pointer starts from nth position. Run while second pointer exist. # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description></item><item><title>22. Generate Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/22/</guid><description>LeetCode problem
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Prerequirements Backtracking pattern
First accepted Idea:
class Solution: def generateParenthesis(self, n): res = [] def dfs(l: int, r: int, s: str) -&amp;gt; None: if l == 0 and r == 0: res.append(s) if l &amp;gt; 0: dfs(l - 1, r, s + &amp;#39;(&amp;#39;) if l &amp;lt; r: dfs(l, r - 1, s + &amp;#39;)&amp;#39;) dfs(n, n, &amp;#39;&amp;#39;) return res</description></item><item><title>28. Find the Index of the First Occurrence in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/28/index.en./</link><pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/28/index.en./</guid><description>LeetCode problem
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.
Example 2:
Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description></item><item><title>29. Divide Two Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/29/</guid><description>LeetCode problem
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.
Return the quotient after dividing dividend by divisor.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.</description></item><item><title>33. Search in Rotated Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</link><pubDate>Thu, 24 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/33/</guid><description>LeetCode problem
There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</link><pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/34/</guid><description>LeetCode problem
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
Example 3:
Input: nums = [], target = 0 Output: [-1,-1]
Code Idea:</description></item><item><title>36. Valid Sudoku</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/36/</guid><description>LeetCode problem
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.</description></item><item><title>38. Count and Say</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/38/</guid><description>LeetCode problem
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
countAndSay(1) = &amp;quot;1&amp;quot; countAndSay(n) is the way you would &amp;ldquo;say&amp;rdquo; the digit string from countAndSay(n-1), which is then converted into a different digit string. To determine how you &amp;ldquo;say&amp;rdquo; a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</description></item><item><title>46. Permutations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</link><pubDate>Sat, 17 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/46/</guid><description>LeetCode problem
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:
Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3:
Input: nums = [1] Output: [[1]] Idea:
Draw a decigion tree Fix when branch is ready to return Implementation:
Recursive: Go through every value in nums Pop value call perm() with updated nums from each call(step) append &amp;lsquo;poped&amp;rsquo; value from step 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: result_permutation = [] if len(nums) == 1: # base case return [nums[:]] for _ in nums: tmp_removed = nums.</description></item><item><title>48. Rotate Image</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</link><pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/48/</guid><description>LeetCode problem 48
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] Idea:
class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify matrix in-place instead.</description></item><item><title>49. Group Anagrams</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/49/</guid><description>LeetCode problem
Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
Example 1:
Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2:
Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3:
Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] Idea:
class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dd = {} for s in strs: s_sort = &amp;#34;&amp;#34;.</description></item><item><title>50. Pow(x, n)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/50/</guid><description>LeetCode problem
Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Approach 1:
class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: return x ** n Approach 2:
Recursive
class Solution: def myPow(self, x, n): if not n: return 1 if n &amp;lt; 0: return 1 / self.</description></item><item><title>53. Maximum Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</link><pubDate>Mon, 26 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/53/</guid><description>LeetCode problem
Given an integer array nums, find the subarray which has the largest sum and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Approach 1:
class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: max_ = nums[0] max2 = nums[0] if len(nums) == 1: return max_ for i in range(1, len(nums)): max_ = max(nums[i], nums[i] + max_) max2 = max(max_, max2) return max2</description></item><item><title>55. Jump Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/55/</guid><description>LeetCode problem
You are given an integer array nums. You are initially positioned at the array&amp;rsquo;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description></item><item><title>56. Merge Intervals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/56/</guid><description>LeetCode problem
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:
Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Approach 1:
class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort() res = [intervals[0]] for ir in range(1, len(intervals)): if intervals[ir][0] &amp;gt;= res[-1][0] and intervals[ir][0] &amp;lt;= res[-1][1]: # [1,3],[2,6] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) elif res[-1][0] &amp;gt;= intervals[ir][0] and res[-1][0] &amp;lt;= intervals[ir][1]: # [1,3],[0,4] res[-1][0] = min(intervals[ir][0], res[-1][0]) res[-1][1] = max(intervals[ir][1], res[-1][1]) else: res.</description></item><item><title>62. Unique Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/62/</guid><description>LeetCode problem
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The test cases are generated so that the answer will be less than or equal to 2 * 10^9.</description></item><item><title>73. Set Matrix Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/73/</guid><description>LeetCode problem
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s.
You must do it in place.
Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] Approach 1:
Idea:
LeetCode Submission
class Solution: def setZeroes(self, matrix: List[List[int]]) -&amp;gt; None: rows = len(matrix) cols = len(matrix[0]) # 1. Check first row/column for zero&amp;#39;s first_row_has_zero = 0 in matrix[0] first_col_has_zero = 0 in list(zip(*matrix))[0] # 2.</description></item><item><title>75. Sort Colors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</link><pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/75/</guid><description>LeetCode problem
This problem is also known as the Dutch National Flag problem. One solution is to use three pointers to partition the array into three sections: red, white, and blue.
Here&amp;rsquo;s the algorithm:
Initialize three pointers: left, mid, and right. Initialize left to 0, mid to 0, and right to n-1, where n is the length of the input array. While mid is less than or equal to right: If nums[mid] is 0, swap nums[mid] with nums[left], increment mid and left.</description></item><item><title>78. Subsets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/78/</guid><description>LeetCode problem
In this solution, we start with an empty list in the results array.
For each element in the nums array, we append that element to all of the subsets in the results array to create new subsets, and then add these new subsets to the results array.
By doing this for all elements in nums, we generate all possible subsets.
class Solution: def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [[]] for i in nums: for j in range(len(res)): cur = [] cur.</description></item><item><title>92. Reverse Linked List II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/92/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/92/</guid><description>LeetCode задача 92
Задача Дан односвязный список и два целых числа left и right, где left &amp;lt;= right. Задача заключается в том, чтобы перевернуть узлы списка с позиции left до right
Т.е. если список 1-2-3-4-5-6-7-8-9, left=2, right=7, то итоговый список будет 1-7-6-5-4-3-2-8-9.
Подсказки Для решения задачи удобно использовать два указателя: один для сохранения начальной позиции участка, который нужно перевернуть, и второй для выполнения самого разворота.
Подход Основная идея решения заключается в использовании двух указателей: одного для начала подсписка, который нужно перевернуть, и второго для его конца.</description></item><item><title>116. Populating Next Right Pointers in Each Node</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/116/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/116/</guid><description>LeetCode problem
from collections import deque class Solution: def connect(self, root: &amp;#39;Optional[Node]&amp;#39;) -&amp;gt; &amp;#39;Optional[Node]&amp;#39;: if not root: return root queue = deque([root]) while queue: level_size = len(queue) for i in range(level_size): node = queue.popleft() if i &amp;lt; level_size - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root LeetCode Editorial:
Editorial</description></item><item><title>122. Best Time to Buy and Sell Stock II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/122/</link><pubDate>Fri, 31 Mar 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/122/</guid><description>LeetCode problem
To solve this problem, we can use a greedy approach.
The idea is to keep adding the profit whenever the price on the next day is higher than the price on the current day.
This way, we will maximize profit.
class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = 0 for i in range(1, len(prices)): if prices[i] &amp;gt; prices[i - 1]: profit += prices[i] - prices[i - 1] return profit LeetCode Editorial:
Editorial</description></item><item><title>128. Longest Consecutive Sequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/128/</link><pubDate>Thu, 13 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/128/</guid><description>LeetCode problem
Save all numbers in set to make it possible to get number at O(1). For each element look for the current+1 element if exists. class Solution: def longestConsecutive(self, nums: List[int]) -&amp;gt; int: res = 0 nset = set(nums) for x in nset: if x - 1 not in nset: # prevent double calculations _max = 1 cur = x while cur + 1 in nset: _max += 1 cur += 1 res = max(_max, res) return res</description></item><item><title>130. Surrounded Regions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/130/</link><pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/130/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to iterate through each cell in the grid, and for each O, check if it is surrounded by X&amp;rsquo;s in all four directions (up, down, left, and right). If so, flip it to X. However, this method has a high time complexity and does not take advantage of any properties of the problem.
Approach: The more efficient solution is to perform a Depth-First Search (DFS) starting from the border O&amp;rsquo;s.</description></item><item><title>131. Palindrome Partitioning</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</link><pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/131/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to generate all possible partitions of the given string and then check if every substring in each partition is a palindrome.
However, this approach would be inefficient, as there would be an exponential number of partitions to check.
Approach:
Using Backtracking.
Logic:
Define a helper function, is_palindrome, to check if a given substring is a palindrome. Define the backtrack function to find all palindrome partitions recursively. This function will take the current position in the string and the current partition as input arguments.</description></item><item><title>134. Gas Station</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/134/</guid><description>LeetCode problem
Naive Solution:
A naive solution would be to try starting from each gas station and check if you can complete the circuit. For each gas station, calculate the remaining gas in the tank after traveling to the next station.
If the gas is not enough to travel to the next station, stop and try starting from the next gas station.
Approach:
In this problem, we can use a greedy algorithm
We can keep track of the total gas and total cost while iterating through the gas stations.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode problem
The problem asks to create a deep copy of a given linked list with a random pointer in each node. A deep copy means that the new linked list will have completely new nodes, and none of its pointers should point to the nodes in the original list. Both the next and random pointers of the new nodes should point to the new nodes in the copied list in the same order as the original list.</description></item><item><title>139. Word Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</link><pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/139/</guid><description>LeetCode problem
Approach:
Dynamic Programming.
Logic:
Using DP:
Iterate through each character of string s. Generate all possible substrings ending at the current index. Check if the substring is in wordDict: If it is, check if the index before the substring&amp;rsquo;s first index is marked as True (this indicates that the part of the string before the current substring can be segmented into words in wordDict). If it is, then mark the current index as True. Solution:
class Solution: def wordBreak(self, s, wordDict): n = len(s) dp = [False] * n for end in range(1, n + 1): # 1.</description></item><item><title>146. LRU Cache</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</link><pubDate>Mon, 22 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/146/</guid><description>LeetCode problem
The operations we need to support are get and put which should both be done in O(1) time.
get(key) should return the value if the key exists in the cache, otherwise return -1. put(key, value) should update the value of the key if the key exists; otherwise, this method should insert the key-value pair into the cache. If the cache is full, this method should also evict the least recently used key-value pair. Approach Use Doubly Linked List or Python OrderedDict</description></item><item><title>148. Sort List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/148/</guid><description>LeetCode problem
Naive Solution Traverse the linked list, adding each node&amp;rsquo;s value to a Python list sort that list create a new linked list from the sorted values return the head of this new list. This solution would have a time complexity of O(n log n) due to the sort operation and a space complexity of O(n) because of the extra list we&amp;rsquo;re creating.
class Solution: def sortList(self, head): values = [] node = head while node: values.append(node.val) node = node.</description></item><item><title>151. Reverse Words in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/151/</guid><description>LeetCode problem
Problem Statement The problem is about reversing the order of words in a given string s. Each word in s is defined as a sequence of non-space characters and the words are separated by at least one space. You are expected to return a string with the words in reversed order and separated by a single space. It is important to note that s may contain leading or trailing spaces or multiple spaces between two words, but the returned string should not contain any extra spaces.</description></item><item><title>152. Maximum Product Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</link><pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/152/</guid><description>LeetCode problem
Problem Statement In this problem, we&amp;rsquo;re given an integer array nums, and our task is to find the maximum product of a contiguous subarray. A subarray is a contiguous part of an array. The interesting part of this problem is that the array can contain both positive and negative numbers, so the maximum product can be obtained by a subarray ending at any index of the array.
Naive Solution A naive approach to this problem would be to calculate the product of all possible subarrays and return the maximum one.</description></item><item><title>166. Fraction to Recurring Decimal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/166/</guid><description>LeetCode problem 166
Problem Statement Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.
This problem is about converting a fraction to its decimal representation in string format. The tricky part is dealing with repeating decimals. If a decimal repeats, we should enclose the repeating part in parentheses.
For example, if we have a fraction 1/3, the decimal representation would be 0.</description></item><item><title>189. Rotate Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/189/</guid><description>LeetCode problem
Problem Statement Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
Naive Solution A simple, but inefficient, approach would be to rotate the array k times. In each rotation, we shift every element of the array to the right by one and move the last element to the start of the array. This solution has a time complexity of O(n*k), where n is the number of elements in the array and k is the number of rotations.</description></item><item><title>210. Course Schedule II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/210/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/210/</guid><description>LeetCode задача 210
Задача Вам дано ( n ) курсов для изучения, пронумерованных от ( 0 ) до ( n-1 ), и массив ( prerequisites ), где ( prerequisites[i] = [a, b] ) означает, что для изучения курса ( a ) предварительно необходимо пройти курс ( b ).
Напишите функцию для нахождения порядка, в котором можно пройти курсы. Если это невозможно, верните пустой массив.
Подсказки Топологическая сортировка может быть использована для решения этой задачи.
Подход Создадим граф, представляющий предварительные требования для каждого курса.</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/215/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/215/</guid><description>LeetCode задача 215
Задача Найти k-тый по величине элемент в неотсортированном массиве. Примечание: это k-тый по величине элемент в отсортированном порядке, а не k-тый различный элемент.
Подсказки Можно отсортировать массив и просто взять k-тый элемент с конца. Для более эффективного решения можно использовать алгоритм быстрой выборки. Подход В самом простом случае мы можем отсортировать массив и взять k-тый элемент с конца.
Алгоритм Сортируем массив. Возвращаем k-тый элемент с конца. Решение def findKthLargest(nums, k): nums.sort() return nums[-k]</description></item><item><title>229. Majority Element II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/229/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/229/</guid><description>LeetCode problem 229
Problem Statement Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Naive Solution The immediate solution would involve using a hashmap or dictionary to track the occurrence of each number in the array. After which, we can iterate over the dictionary to find numbers whose occurrences are greater than n/3.
Hints &amp;amp; Tips There can be at most one or two majority elements which appear more than n/3 times in the array.</description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/236/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/236/</guid><description>LeetCode задача 236
Задача Найдите наименьшего общего предка (LCA) двух заданных узлов в бинарном дереве.
Подсказки Используйте метод обхода в глубину (DFS) для решения этой задачи.
Подход Обход в глубину (DFS): Используйте рекурсивный метод для обхода дерева. Поиск узлов: При обходе дерева ищите заданные узлы p и q. Возврат значения: Если найден один из узлов, верните его как потенциального предка. Сравнение результатов: Если оба поддерева возвращают узлы, текущий узел является LCA. Пропуск пустых узлов: Если узел пуст, верните None.</description></item><item><title>237. Delete Node in a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/237/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/237/</guid><description>LeetCode задача 237
Задача Написать функцию для удаления узла (за исключением хвостового) в односвязном списке, дан только доступ к этому узлу.
Подсказки Обычно, для удаления узла из односвязного списка, нам нужен доступ к предыдущему узлу. В этом случае, у нас такого доступа нет. Как это обойти? Подход Поскольку доступа к предыдущему узлу нет, мы не можем просто &amp;ldquo;вырезать&amp;rdquo; текущий узел. Однако мы можем переписать значение текущего узла значением следующего узла и затем удалить следующий узел.
Алгоритм Перезаписываем значение текущего узла значением следующего узла.</description></item><item><title>238. Product of Array Except Self</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/238/</guid><description>LeetCode problem
Problem Statement The problem is to find a product of all elements in the given integer array nums, except for the i-th element, and return a new array with the results. You must design an algorithm that runs in O(n) time and doesn&amp;rsquo;t use the division operation. The challenge here is to solve this problem with O(1) extra space complexity.
Naive Solution A naive solution could be to calculate the product of all elements in the array, then iterate through the array and replace each element with the total product divided by the element.</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/240/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/240/</guid><description>LeetCode задача 240
Задача Вам дана двумерная матрица размера m x n, представляющая прямоугольник, и целое число target. Отсортированные строки матрицы по неубыванию с лева направо и столбцы отсортированы по неубыванию сверху вниз.
Найдите элемент target в матрице. Верните True, если элемент target есть в матрице, и False, если его нет.
Подсказки Попробуйте использовать двоичный поиск для каждого ряда.
Подход Самый простой подход - использовать двоичный поиск для каждого ряда. Хотя это не самый эффективный метод, он достаточно прост для понимания.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2512/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2512/</guid><description>LeetCode problem 251
class Vector2D: def __init__(self, vec: List[List[int]]): self.i = 0 self.j = 0 self.vec = vec def next(self) -&amp;gt; int: self.forward() res = self.vec[self.i][self.j] self.j += 1 return res def hasNext(self) -&amp;gt; bool: self.forward() return self.i &amp;lt; len(self.vec) def forward(self): while self.i &amp;lt; len(self.vec) and self.j &amp;gt;= len(self.vec[self.i]): self.i += 1 self.j = 0 # Your Vector2D object will be instantiated and called as such: # obj = Vector2D(vec) # param_1 = obj.next() # param_2 = obj.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/251/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/251/</guid><description>LeetCode задача 251
Задача Дизайн и реализация итератора для 2D вектора. Итератор должен быть инициализирован 2D вектором (vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;) и должен поддерживать следующие операции:
next(): Возвращает следующий элемент из 2D вектора. Если нет больше элементов, возвращает 0. hasNext(): Возвращает True, если в 2D векторе есть следующий элемент, и False в противном случае. Подход Мы можем использовать две переменные: одну для текущего индекса строки и одну для текущего индекса столбца, чтобы навигироваться по 2D вектору.
Алгоритм Инициализируем переменные row и col в конструкторе.</description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/277/</guid><description>LeetCode задача 277
Задача Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?
Имплементируйте функцию int findCelebrity(n), которая вернет знаменитость если она есть, иначе вернёт -1.
Вам дана функция bool knows(a, b), которая скажет вам, знает ли a человека b.
Подход Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.
Алгоритм Инициализируем переменную candidate значением 0.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode problem 287
Problem Statement Given an array of integers nums containing n + 1 integers where each integer is within the range [1, n], you need to find and return the only duplicate number present in nums.
The key constraints:
You shouldn&amp;rsquo;t modify the array nums. You should only use constant extra space. Naive Solution One possible naive solution would be to use a nested loop to compare each element with every other element in the array. This approach, however, is not efficient and has a time complexity of O(n^2), which doesn&amp;rsquo;t scale well with large inputs.</description></item><item><title>300. Longest Increasing Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/300/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/300/</guid><description>LeetCode задача 300
Задача Дан массив чисел, ваша задача — найти длину наибольшей возрастающей подпоследовательности.
Подсказки Для решения этой задачи вы можете использовать динамическое программирование.
Подход Инициализация: Инициализируйте массив, который будет хранить длины наибольших возрастающих подпоследовательностей для каждого элемента массива. Обход массива: Обойдите массив, и для каждого элемента обновите массив длин наибольших возрастающих подпоследовательностей. Максимум: По окончании обхода найдите максимальное значение в массиве длин. Простейший способ решения — это использовать двойной цикл для обхода массива и поиска наибольшей возрастающей подпоследовательности для каждого элемента.</description></item><item><title>328. Odd Even Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/328/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/328/</guid><description>LeetCode задача 328
Задача Дан односвязный список и задача переставить его узлы таким образом, чтобы все узлы с нечетными индексами шли перед всеми узлами с четными индексами.
Вариант решения 1 Рассмотрим вариант решения более простой для понимания и реализации.
Подсказки Использовать два связных списка.
Подход Во время прохода по связному списку указатель для чётных узлов добавлять связанный список с четными, то же самое делать с нечетными.
В конце прохода список с четными узлами добавить в конец списка с нечетными узлами.</description></item><item><title>334. Increasing Triplet Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/334/</guid><description>LeetCode problem
Problem Statement The task is to determine if the given list of numbers contains an increasing subsequence of length three. This means we need to find three indices i, j, and k in the list such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[j] &amp;lt; nums[k].
Naive Solution One possible naive solution is to use three nested loops to go through all possible triples in the list and check if they are increasing. But this solution is very inefficient, has a time complexity of O(n³), and does not meet the follow-up constraints of the problem.</description></item><item><title>341. Flatten Nested List Iterator</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/341/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/341/</guid><description>Задача Дан вложенный список целых чисел. Реализуйте итератор, который &amp;ldquo;разворачивает&amp;rdquo; этот вложенный список.
Подход Задача состоит в реализации итератора, который будет последовательно возвращать все элементы из вложенного списка. Вложенный список может содержать как обычные числа, так и другие вложенные списки. Наивное решение заключается в том, чтобы сначала полностью &amp;ldquo;развернуть&amp;rdquo; весь вложенный список в одномерный список, а затем реализовать итератор для этого одномерного списка.
Алгоритм Инициализация: Создать одномерный список и заполнить его элементами из вложенного списка. next(): Возвращает следующий элемент одномерного списка.</description></item><item><title>343. Integer Break</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/343/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/343/</guid><description>LeetCode problem 343
Problem Statement Given a positive integer n, our task is to divide it into the sum of k positive integers, where $k \geq 2$, in such a way that the product of these integers is maximized. Our goal is to determine the maximum possible product.
Naive Solution A straightforward or naive way to solve this would be to consider all potential combinations to divide the number n and calculate the product for each division. This method, while comprehensive, would be inefficient and impractical for larger values of n.</description></item><item><title>377. Combination Sum IV</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/377/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/377/</guid><description>LeetCode задача 377
Задача Дан массив различных целых чисел nums и целевое целое число target от 1 до 1000. Нужно вернуть количество возможных комбинаций, которые в сумме дают target.
Подсказки Построить дерево решений Задачу можно решить путем разложения ее на меньшие подзадачи с помощью динамического программирования. Нахождение целевого значения в дереве решений
Your browser does not support the video tag. LeetCode 377 Решение Подход Если целевое значение - target=7 и nums=[2, 3, 4], то в дереве решений может быть несколько путей до этого числа.</description></item><item><title>384. Shuffle an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/384/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/384/</guid><description>LeetCode задача 384
Задача Реализуйте класс, который принимает массив чисел в конструкторе и предоставляет метод для их случайного перемешивания, а также метод для возвращения исходного массива.
Подсказки Для создания случайного порядка элементов можно использовать алгоритм Фишера-Йетса или другие методы перемешивания.
Подход Инициализация: Сохранить исходный массив в переменной класса для дальнейшего использования. reset(): Вернуть исходный массив. shuffle(): Вернуть перемешанный массив. Из всех возможных подходов к решению этой задачи, наиболее простым является использование встроенного метода random.shuffle() из Python стандартной библиотеки для перемешивания массива.</description></item><item><title>387. First Unique Character in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/387/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/387/</guid><description>LeetCode задача 387
Задача Дана строка s. Найдите первый уникальный символ в строке и верните его индекс. Если такого символа нет, верните -1.
Подсказки Использование хеш-таблицы может ускорить процесс поиска уникальных символов.
Подход Инициализация: Создайте хеш-таблицу для хранения частоты каждого символа в строке. Первый проход: Пройдите по строке и заполните хеш-таблицу. Второй проход: Пройдите по строке второй раз и проверьте частоту каждого символа в хеш-таблице. Первый символ с частотой 1 будет ответом. Этот подход прост для понимания и реализации.</description></item><item><title>394. Decode String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/394/</guid><description>LeetCode problem
Problem Statement Given an encoded string, the task is to decode it to produce a string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.
Naive Solution A naive approach would be to repeatedly look for a pattern in the string where there is a number followed by square brackets. For each such pattern found, replace it with the string inside the square brackets repeated &amp;lsquo;k&amp;rsquo; times. This would work but might not be the most efficient solution, especially for nested brackets.</description></item><item><title>437. Path Sum III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/437/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/437/</guid><description>LeetCode задача 437
Задача Дан корень бинарного дерева и целое число targetSum. Верните количество путей, где сумма значений вдоль пути равна targetSum.
Путь не обязан начинаться или заканчиваться на корне или листе, но он должен идти вниз (т.е. только от родительских узлов к дочерним).
Подсказки Нам необходимо рассмотреть все возможные пути от каждого узла, идущие вниз. Это можно сделать, рекурсивно обходя дерево и считая количество путей для каждого узла.
Подход Рассмотрим решение с применением рекурсивного обхода дерева, начиная с корня.</description></item><item><title>443. String Compression</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/443/</guid><description>LeetCode problem
Problem Statement Given a list of characters, chars, you are required to compress the list using the following algorithm:
Start with an empty string, s. For each group of consecutive repeating characters in chars: If the group&amp;rsquo;s length is 1, append the character to s. Otherwise, append the character followed by the group&amp;rsquo;s length. The compressed string s should be stored back in the chars list. The length of the group that is 10 or longer will be split into multiple characters in chars.</description></item><item><title>454. 4Sum II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/454/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/454/</guid><description>LeetCode задача 454
Задача Даны четыре списка A, B, C, D целых чисел. Вычислите, сколько существует таких кортежей (i, j, k, l), что ( A[i] + B[j] + C[k] + D[l] = 0 ).
Подсказки Используйте хэш-таблицу для ускорения решения.
Подход Создание хэш-таблицы: Сначала создайте хэш-таблицу, которая будет хранить суммы пар чисел из массивов A и B. Подсчет сумм: Для каждой пары (i, j) из A и B, увеличьте соответствующий элемент хэш-таблицы на 1. Поиск в хэш-таблице: Для каждой пары (k, l) из C и D, проверьте, существует ли -(C[k] + D[l]) в хэш-таблице.</description></item><item><title>649. Dota2 Senate</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/649/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/649/</guid><description>LeetCode problem 649
Idea Think about how the bans affect the sequence of senators and how you can simulate the rounds efficiently.
The core idea is to simulate the banning process round by round, keeping track of which senators are available to ban others. A queue can efficiently manage this process. Radiant senators and Dire senators can be handled separately to easily manage the bans they are going to perform.
Approach Use two queues to represent the indices of Radiant and Dire senators, respectively.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode problem 725
Problem Statement The problem asks you to divide a given singly linked list into k different parts such that the sizes of these parts are as nearly equal as possible. The parts should appear in the same order as in the original list, and earlier parts should not be smaller than later parts.
Naive Solution A naive approach would involve counting the length of the list and then traversing the list multiple times to create each part.</description></item><item><title>735. Asteroid Collision</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/735/</guid><description>LeetCode problem
Problem Statement Imagine a row of asteroids moving in space. Each asteroid has a size (given by its absolute value) and a direction it&amp;rsquo;s moving in (given by its sign: positive for right, negative for left). All asteroids move at the same speed. Your task is to determine the final state of the asteroids after all collisions have been resolved.
Two important points to note:
When two asteroids of different directions meet, the smaller one explodes. If they are of the same size, both explode.</description></item><item><title>791. Custom Sort String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/791/</guid><description>LeetCode problem 791
class Solution: def customSortString(self, order: str, s: str) -&amp;gt; str: cnt = Counter(s) res = [] for c in order: res.append(c * cnt[c]) cnt[c] = 0 for c, v in cnt.items(): res.append(c * v) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/799/</guid><description>LeetCode problem 799
Problem Statement You are tasked with modeling a champagne tower. Glasses are stacked in a pyramid, with each row having one more glass than the previous. When champagne is poured into the top glass and it overflows, the overflowed champagne is split equally between the two glasses below. The objective is to determine how full a specified glass will be after pouring a given amount of champagne.
Naive Solution One could imagine a simulation, where we pour champagne into the top glass and then, glass-by-glass, simulate the overflow until we reach the desired glass.</description></item><item><title>880. Decoded String at Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/880/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/880/</guid><description>LeetCode problem 880
Problem Statement Given an encoded string s, the encoded string is transformed into a tape based on the following criteria:
When a letter is encountered, it&amp;rsquo;s written on the tape. When a digit d is encountered, the current content of the tape is repeated d - 1 more times. You are required to find and return the kth letter (1-indexed) on the decoded tape.
Naive Solution A straightforward solution would involve constructing the entire decoded tape and then simply accessing the kth character.</description></item><item><title>948. Bag of Tokens</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/948/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/948/</guid><description>LeetCode problem 948
class Solution: def bagOfTokensScore(self, tokens: List[int], power: int) -&amp;gt; int: tokens.sort() i, j = 0, len(tokens) - 1 res = t = 0 while i &amp;lt;= j: if power &amp;gt;= tokens[i]: power -= tokens[i] i, t = i + 1, t + 1 res = max(res, t) elif t: power += tokens[j] j, t = j - 1, t - 1 else: break return res</description></item><item><title>Largest Time for Given Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/949/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/949/</guid><description>LeetCode problem 949
class Solution: def largestTimeFromDigits(self, arr: List[int]) -&amp;gt; str: res = -1 for i in range(4): for j in range(4): for k in range(4): if i != j and i != k and j != k: h = arr[i] * 10 + arr[j] m = arr[k] * 10 + arr[6 - i - j - k] if h &amp;lt; 24 and m &amp;lt; 60: res = max(res, h * 60 + m) return &amp;#39;&amp;#39; if res &amp;lt; 0 else f&amp;#39;{res // 60:02}:{res % 60:02}&amp;#39;</description></item><item><title>Reveal Cards In Increasing Order</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/950/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/950/</guid><description>LeetCode problem 950
class Solution: def deckRevealedIncreasing(self, deck: List[int]) -&amp;gt; List[int]: q = deque() for v in sorted(deck, reverse=True): if q: q.appendleft(q.pop()) q.appendleft(v) return list(q)</description></item><item><title>Flip Equivalent Binary Trees</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/951/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/951/</guid><description>LeetCode problem 951
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&amp;gt; bool: def dfs(root1, root2): if root1 == root2 or (root1 is None and root2 is None): return True if root1 is None or root2 is None or root1.val != root2.val: return False return (dfs(root1.left, root2.left) and dfs(root1.right, root2.right)) or ( dfs(root1.</description></item><item><title>Array of Doubled Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/954/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/954/</guid><description>LeetCode problem 954
class Solution: def canReorderDoubled(self, arr: List[int]) -&amp;gt; bool: freq = Counter(arr) if freq[0] &amp;amp; 1: return False for x in sorted(freq, key=abs): if freq[x &amp;lt;&amp;lt; 1] &amp;lt; freq[x]: return False freq[x &amp;lt;&amp;lt; 1] -= freq[x] return True</description></item><item><title>Check Completeness of a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/958/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/958/</guid><description>LeetCode problem 958
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isCompleteTree(self, root: TreeNode) -&amp;gt; bool: q = deque([root]) while q: node = q.popleft() if node is None: break q.append(node.left) q.append(node.right) return all(node is None for node in q)</description></item><item><title>Regions Cut By Slashes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/959/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/959/</guid><description>LeetCode problem 959
class Solution: def regionsBySlashes(self, grid: List[str]) -&amp;gt; int: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def union(a, b): pa, pb = find(a), find(b) if pa != pb: p[pa] = pb nonlocal size size -= 1 n = len(grid) size = n * n * 4 p = list(range(size)) for i, row in enumerate(grid): for j, v in enumerate(row): k = i * n + j if i &amp;lt; n - 1: union(4 * k + 2, (k + n) * 4) if j &amp;lt; n - 1: union(4 * k + 1, (k + 1) * 4 + 3) if v == &amp;#39;/&amp;#39;: union(4 * k, 4 * k + 3) union(4 * k + 1, 4 * k + 2) elif v == &amp;#39;\\&amp;#39;: union(4 * k, 4 * k + 1) union(4 * k + 2, 4 * k + 3) else: union(4 * k, 4 * k + 1) union(4 * k + 1, 4 * k + 2) union(4 * k + 2, 4 * k + 3) return size</description></item><item><title>Maximum Width Ramp</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/962/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/962/</guid><description>LeetCode problem 962
class Solution: def maxWidthRamp(self, nums: List[int]) -&amp;gt; int: stk = [] for i, v in enumerate(nums): if not stk or nums[stk[-1]] &amp;gt; v: stk.append(i) res = 0 for i in range(len(nums) - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt;= nums[i]: res = max(res, i - stk.pop()) if not stk: break return res</description></item><item><title>Minimum Area Rectangle II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/963/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/963/</guid><description>LeetCode problem 963
class Solution: def minAreaFreeRect(self, points: List[List[int]]) -&amp;gt; float: s = {(x, y) for x, y in points} n = len(points) res = inf for i in range(n): x1, y1 = points[i] for j in range(n): if j != i: x2, y2 = points[j] for k in range(j + 1, n): if k != i: x3, y3 = points[k] x4 = x2 - x1 + x3 y4 = y2 - y1 + y3 if (x4, y4) in s: v21 = (x2 - x1, y2 - y1) v31 = (x3 - x1, y3 - y1) if v21[0] * v31[0] + v21[1] * v31[1] == 0: w = sqrt(v21[0] ** 2 + v21[1] ** 2) h = sqrt(v31[0] ** 2 + v31[1] ** 2) res = min(res, w * h) return 0 if res == inf else res</description></item><item><title>Vowel Spellchecker</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/966/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/966/</guid><description>LeetCode problem 966
class Solution: def spellchecker(self, wordlist: List[str], queries: List[str]) -&amp;gt; List[str]: def f(w): t = [] for c in w: t.append(&amp;#34;*&amp;#34; if c in &amp;#34;aeiou&amp;#34; else c) return &amp;#34;&amp;#34;.join(t) s = set(wordlist) low, pat = {}, {} for w in wordlist: t = w.lower() low.setdefault(t, w) pat.setdefault(f(t), w) res = [] for q in queries: if q in s: res.append(q) continue q = q.lower() if q in low: res.append(low[q]) continue q = f(q) if q in pat: res.</description></item><item><title>Numbers With Same Consecutive Differences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/967/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/967/</guid><description>LeetCode problem 967
class Solution: def numsSameConsecDiff(self, n: int, k: int) -&amp;gt; List[int]: res = [] def dfs(n, k, t): if n == 0: res.append(t) return last = t % 10 if last + k &amp;lt;= 9: dfs(n - 1, k, t * 10 + last + k) if last - k &amp;gt;= 0 and k != 0: dfs(n - 1, k, t * 10 + last - k) for i in range(1, 10): dfs(n - 1, k, i) return res</description></item><item><title>Pancake Sorting</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/969/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/969/</guid><description>LeetCode problem 969
class Solution: def pancakeSort(self, arr: List[int]) -&amp;gt; List[int]: def reverse(arr, j): i = 0 while i &amp;lt; j: arr[i], arr[j] = arr[j], arr[i] i, j = i + 1, j - 1 n = len(arr) res = [] for i in range(n - 1, 0, -1): j = i while j &amp;gt; 0 and arr[j] != i + 1: j -= 1 if j &amp;lt; i: if j &amp;gt; 0: res.append(j + 1) reverse(arr, j) res.</description></item><item><title>Powerful Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/970/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/970/</guid><description>LeetCode problem 970
class Solution: def powerfulIntegers(self, x: int, y: int, bound: int) -&amp;gt; List[int]: res = set() a = 1 while a &amp;lt;= bound: b = 1 while a + b &amp;lt;= bound: res.add(a + b) b *= y if y == 1: break if x == 1: break a *= x return list(res)</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</link><pubDate>Thu, 10 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1004/</guid><description>LeetCode Problem 1004
Problem Statement Given a binary array nums and an integer k, the task is to return the maximum number of consecutive 1&amp;rsquo;s in the array, with the possibility to flip at most k 0&amp;rsquo;s.
Naive Solution A straight forward approach is to try flipping every combination of k zeros and checking for the longest sequence of 1&amp;rsquo;s. This would involve nested loops, with the outer loop iterating through the array and the inner loops flipping zeros and calculating sequences of 1&amp;rsquo;s.</description></item><item><title>1048. Longest String Chain</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1048/</guid><description>LeetCode problem 1048
Problem Statement You are given an array of words where each word consists of lowercase English letters. Your task is to determine the longest string chain you can form given this list. A word A can be a predecessor of word B if by adding exactly one letter to A (at any position), B is formed. The objective is to find the longest sequence where each word is a predecessor of the next.
Naive Solution The straightforward brute-force way would be to try all possible combinations of word chains.</description></item><item><title>1138. Alphabet Board Path</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1138/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1138/</guid><description>LeetCode problem 1138
class Solution: def alphabetBoardPath(self, target: str) -&amp;gt; str: i = j = 0 res = [] for c in target: v = ord(c) - ord(&amp;#34;a&amp;#34;) x = v // 5 y = v % 5 while j &amp;gt; y: j -= 1 res.append(&amp;#34;L&amp;#34;) while i &amp;gt; x: i -= 1 res.append(&amp;#34;U&amp;#34;) while j &amp;lt; y: j += 1 res.append(&amp;#34;R&amp;#34;) while i &amp;lt; x: i += 1 res.append(&amp;#34;D&amp;#34;) res.append(&amp;#34;!&amp;#34;) return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1152. Analyze User Website Visit Pattern</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1152/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1152/</guid><description>LeetCode problem 1152
class Solution: def mostVisitedPattern( self, username: List[str], timestamp: List[int], website: List[str]) -&amp;gt; List[str]: d = defaultdict(list) for user, _, site in sorted(zip(username, timestamp, website), key=lambda x: x[1]): d[user].append(site) cnt = Counter() for sites in d.values(): m = len(sites) s = set() if m &amp;gt; 2: for i in range(m - 2): for j in range(i + 1, m - 1): for k in range(j + 1, m): s.add((sites[i], sites[j], sites[k])) for t in s: cnt[t] += 1 return sorted(cnt.</description></item><item><title>1162. As Far from Land as Possible</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1162/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1162/</guid><description>LeetCode problem 1162
class Solution: def maxDistance(self, grid: List[List[int]]) -&amp;gt; int: n = len(grid) q = deque((i, j) for i in range(n) for j in range(n) if grid[i][j]) res = -1 if len(q) in (0, n * n): return res dirs = (-1, 0, 1, 0, -1) while q: for _ in range(len(q)): i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; n and 0 &amp;lt;= y &amp;lt; n and grid[x][y] == 0: grid[x][y] = 1 q.</description></item><item><title>1171. Remove Zero Sum Consecutive Nodes from Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1171/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1171/</guid><description>LeetCode problem 1171
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeZeroSumSublists(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) last = {} s = 0 cur = dummy while cur: s += cur.val last[s] = cur cur = cur.next s = 0 cur = dummy while cur: s += cur.val cur.next = last[s].next cur = cur.next return dummy.next</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1372/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1372/</guid><description>LeetCode problem 1372
Problem Statement Given the root of a binary tree, the task is to find the longest ZigZag path contained in that tree. A ZigZag path is defined by a sequence starting at any node and switching between left and right directions at each subsequent step.
Naive Solution A simplistic approach would be to kick off from every node and emulate the ZigZag movement until it&amp;rsquo;s no longer feasible, all the while updating the longest path encountered.</description></item><item><title>1448. Count Good Nodes in Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1448/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1448/</guid><description>LeetCode задача 1448
Задача Дано бинарное дерево. Задача подсчитать количество &amp;ldquo;хороших&amp;rdquo; узлов. Узел считается &amp;ldquo;хорошим&amp;rdquo;, если на пути от корня дерева до этого узла (включительно) не встречается узлов с большим значением.
Подсказки &amp;ldquo;Хороший&amp;rdquo; узел в дереве — это узел, для которого все узлы на пути от корня до этого узла имеют значение не больше, чем значение этого узла.
Использовать метод обхода в глубину (DFS) для решения этой задачи.
Подход Идея решения задачи заключается в рекурсивном обходе дерева с сохранением максимального значения на пути от корня к текущему узлу.</description></item><item><title>1451. Rearrange Words in a Sentence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1451/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1451/</guid><description>LeetCode problem 1451
class Solution: def arrangeWords(self, text: str) -&amp;gt; str: words = text.split() words[0] = words[0].lower() words.sort(key=len) words[0] = words[0].title() return &amp;#34; &amp;#34;.join(words)</description></item><item><title>1452. People Whose List of Favorite Companies Is Not a Subset of Another List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1452/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1452/</guid><description>LeetCode problem 1452
class Solution: def peopleIndexes(self, favoriteCompanies: List[List[str]]) -&amp;gt; List[int]: d = {} idx = 0 t = [] for v in favoriteCompanies: for c in v: if c not in d: d[c] = idx idx += 1 t.append({d[c] for c in v}) res = [] for i, nums1 in enumerate(t): ok = True for j, nums2 in enumerate(t): if i == j: continue if not (nums1 - nums2): ok = False break if ok: res.append(i) return res</description></item><item><title>1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1456/</guid><description>LeetCode Problem 1456
Problem Statement Given a string s and an integer k, the task is to return the maximum number of vowel letters in any substring of s with length k.
Vowel letters in English are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;.
Naive Solution The most straightforward solution to this problem is to take every possible substring of length k and count the number of vowels in each of them. This can be done using nested loops. The outer loop runs through each character in the string while the inner loop counts the vowels for each substring of length k.</description></item><item><title>1457. Pseudo-Palindromic Paths in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1457/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1457/</guid><description>LeetCode problem 1457
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def pseudoPalindromicPaths(self, root: Optional[TreeNode]) -&amp;gt; int: def dfs(root: Optional[TreeNode], mask: int): if root is None: return 0 mask ^= 1 &amp;lt;&amp;lt; root.val if root.left is None and root.right is None: return int((mask &amp;amp; (mask - 1)) == 0) return dfs(root.left, mask) + dfs(root.right, mask) return dfs(root, 0)</description></item><item><title>1461. Check If a String Contains All Binary Codes of Size K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1461/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1461/</guid><description>LeetCode problem 1461
class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: if len(s) - k + 1 &amp;lt; (1 &amp;lt;&amp;lt; k): return False vis = [False] * (1 &amp;lt;&amp;lt; k) num = int(s[:k], 2) vis[num] = True for i in range(k, len(s)): a = (ord(s[i - k]) - ord(&amp;#39;0&amp;#39;)) &amp;lt;&amp;lt; (k - 1) b = ord(s[i]) - ord(&amp;#39;0&amp;#39;) num = ((num - a) &amp;lt;&amp;lt; 1) + b vis[num] = True return all(v for v in vis)</description></item><item><title>1462. Course Schedule IV</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1462/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1462/</guid><description>LeetCode problem 1462
class Solution: def checkIfPrerequisite( self, n: int, prerequisites: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[bool]: f = [[False] * n for _ in range(n)] g = [[] for _ in range(n)] indeg = [0] * n for a, b in prerequisites: g[a].append(b) indeg[b] += 1 q = deque(i for i, x in enumerate(indeg) if x == 0) while q: i = q.popleft() for j in g[i]: f[i][j] = True for h in range(n): f[h][j] = f[h][j] or f[h][i] indeg[j] -= 1 if indeg[j] == 0: q.</description></item><item><title>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1465/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1465/</guid><description>LeetCode problem 1465
class Solution: def maxArea( self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int] ) -&amp;gt; int: horizontalCuts.extend([0, h]) verticalCuts.extend([0, w]) horizontalCuts.sort() verticalCuts.sort() x = max(b - a for a, b in pairwise(horizontalCuts)) y = max(b - a for a, b in pairwise(verticalCuts)) return (x * y) % (10**9 + 7)</description></item><item><title>1466. Reorder Routes to Make All Paths Lead to the City Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1466/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1466/</guid><description>LeetCode problem 1466
class Solution: def minReorder(self, n: int, connections: List[List[int]]) -&amp;gt; int: def dfs(a: int, fa: int) -&amp;gt; int: return sum(c + dfs(b, a) for b, c in g[a] if b != fa) g = [[] for _ in range(n)] for a, b in connections: g[a].append((b, 1)) g[b].append((a, 0)) return dfs(0, -1)</description></item><item><title>1471. The k Strongest Values in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1471/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1471/</guid><description>LeetCode problem 1471
class Solution: def getStrongest(self, arr: List[int], k: int) -&amp;gt; List[int]: arr.sort() m = arr[(len(arr) - 1) &amp;gt;&amp;gt; 1] arr.sort(key=lambda x: (-abs(x - m), -x)) return arr[:k]</description></item><item><title>1472. Design Browser History</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1472/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1472/</guid><description>LeetCode problem 1472
class BrowserHistory: def __init__(self, homepage: str): self.stk1 = [] self.stk2 = [] self.visit(homepage) def visit(self, url: str) -&amp;gt; None: self.stk1.append(url) self.stk2.clear() def back(self, steps: int) -&amp;gt; str: while steps and len(self.stk1) &amp;gt; 1: self.stk2.append(self.stk1.pop()) steps -= 1 return self.stk1[-1] def forward(self, steps: int) -&amp;gt; str: while steps and self.stk2: self.stk1.append(self.stk2.pop()) steps -= 1 return self.stk1[-1] # Your BrowserHistory object will be instantiated and called as such: # obj = BrowserHistory(homepage) # obj.visit(url) # param_2 = obj.</description></item><item><title>1476. Subrectangle Queries</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1476/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1476/</guid><description>LeetCode problem 1476
class SubrectangleQueries: def __init__(self, rectangle: List[List[int]]): self.g = rectangle self.ops = [] def updateSubrectangle( self, row1: int, col1: int, row2: int, col2: int, newValue: int ) -&amp;gt; None: self.ops.append((row1, col1, row2, col2, newValue)) def getValue(self, row: int, col: int) -&amp;gt; int: for r1, c1, r2, c2, v in self.ops[::-1]: if r1 &amp;lt;= row &amp;lt;= r2 and c1 &amp;lt;= col &amp;lt;= c2: return v return self.g[row][col] # Your SubrectangleQueries object will be instantiated and called as such: # obj = SubrectangleQueries(rectangle) # obj.</description></item><item><title>1477. Find Two Non-overlapping Sub-arrays Each With Target Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1477/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1477/</guid><description>LeetCode problem 1477
class Solution: def minSumOfLengths(self, arr: List[int], target: int) -&amp;gt; int: d = {0: 0} s, n = 0, len(arr) f = [inf] * (n + 1) res = inf for i, v in enumerate(arr, 1): s += v f[i] = f[i - 1] if s - target in d: j = d[s - target] f[i] = min(f[i], i - j) res = min(res, f[j] + i - j) d[s] = i return -1 if res &amp;gt; n else res</description></item><item><title>1481. Least Number of Unique Integers after K Removals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1481/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1481/</guid><description>LeetCode problem 1481
class Solution: def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -&amp;gt; int: cnt = Counter(arr) for i, v in enumerate(sorted(cnt.values())): k -= v if k &amp;lt; 0: return len(cnt) - i return 0</description></item><item><title>1482. Minimum Number of Days to Make m Bouquets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1482/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1482/</guid><description>LeetCode problem 1482
class Solution: def minDays(self, bloomDay: List[int], m: int, k: int) -&amp;gt; int: if m * k &amp;gt; len(bloomDay): return -1 def check(day: int) -&amp;gt; bool: cnt = cur = 0 for bd in bloomDay: cur = cur + 1 if bd &amp;lt;= day else 0 if cur == k: cnt += 1 cur = 0 return cnt &amp;gt;= m left, right = min(bloomDay), max(bloomDay) while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if check(mid): right = mid else: left = mid + 1 return left</description></item><item><title>1485. Clone Binary Tree With Random Pointer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1485/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1485/</guid><description>LeetCode problem 1485
# Definition for Node. # class Node: # def __init__(self, val=0, left=None, right=None, random=None): # self.val = val # self.left = left # self.right = right # self.random = random class Solution: def copyRandomBinaryTree(self, root: &amp;#39;Optional[Node]&amp;#39;) -&amp;gt; &amp;#39;Optional[NodeCopy]&amp;#39;: def dfs(root): if root is None: return None if root in mp: return mp[root] copy = NodeCopy(root.val) mp[root] = copy copy.left = dfs(root.left) copy.right = dfs(root.right) copy.random = dfs(root.random) return copy mp = {} return dfs(root)</description></item><item><title>1487. Making File Names Unique</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1487/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1487/</guid><description>LeetCode problem 1487
class Solution: def getFolderNames(self, names: List[str]) -&amp;gt; List[str]: d = defaultdict(int) for i, name in enumerate(names): if name in d: k = d[name] while f&amp;#39;{name}({k})&amp;#39; in d: k += 1 d[name] = k + 1 names[i] = f&amp;#39;{name}({k})&amp;#39; d[names[i]] = 1 return names</description></item><item><title>1488. Avoid Flood in The City</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1488/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1488/</guid><description>LeetCode problem 1488
from sortedcontainers import SortedList class Solution: def avoidFlood(self, rains: List[int]) -&amp;gt; List[int]: n = len(rains) res = [-1] * n sunny = SortedList() rainy = {} for i, v in enumerate(rains): if v: if v in rainy: idx = sunny.bisect_right(rainy[v]) if idx == len(sunny): return [] res[sunny[idx]] = v sunny.discard(sunny[idx]) rainy[v] = i else: sunny.add(i) res[i] = 1 return res</description></item><item><title>1490. Clone N-ary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1490/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1490/</guid><description>LeetCode problem 1490
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] &amp;#34;&amp;#34;&amp;#34; class Solution: def cloneTree(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; &amp;#39;Node&amp;#39;: if root is None: return None children = [self.cloneTree(child) for child in root.children] return Node(root.val, children)</description></item><item><title>1492. The kth Factor of n</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1492/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1492/</guid><description>LeetCode problem 1492
class Solution: def kthFactor(self, n: int, k: int) -&amp;gt; int: i = 1 while i * i &amp;lt; n: if n % i == 0: k -= 1 if k == 0: return i i += 1 if i * i != n: i -= 1 while i: if (n % (n // i)) == 0: k -= 1 if k == 0: return n // i i -= 1 return -1</description></item><item><title>1493. Longest Subarray of 1's After Deleting One Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</link><pubDate>Fri, 11 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1493/</guid><description>LeetCode Problem 1493
Problem Statement Given a binary array nums, you should delete one element from it. The goal is to return the size of the longest subarray containing only 1&amp;rsquo;s after this deletion. If no such subarray exists, return 0.
Naive Solution A straightforward approach is to manually try deleting each element in the array and checking the length of the longest sequence of 1&amp;rsquo;s. This would involve nested loops: an outer loop for deleting an element and an inner loop to check sequences of 1&amp;rsquo;s.</description></item><item><title>1497. Check If Array Pairs Are Divisible by k</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1497/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1497/</guid><description>LeetCode problem 1497
class Solution: def canArrange(self, arr: List[int], k: int) -&amp;gt; bool: cnt = Counter(x % k for x in arr) return cnt[0] % 2 == 0 and all(cnt[i] == cnt[k - i] for i in range(1, k))</description></item><item><title>1498. Number of Subsequences That Satisfy the Given Sum Condition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1498/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1498/</guid><description>LeetCode problem 1498
class Solution: def numSubseq(self, nums: List[int], target: int) -&amp;gt; int: mod = 10**9 + 7 nums.sort() n = len(nums) f = [1] + [0] * n for i in range(1, n + 1): f[i] = f[i - 1] * 2 % mod res = 0 for i, x in enumerate(nums): if x * 2 &amp;gt; target: break j = bisect_right(nums, target - x, i + 1) - 1 res = (res + f[j - i]) % mod return res</description></item><item><title>1500. Design a File Sharing System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1500/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1500/</guid><description>LeetCode problem 1500
class FileSharing: def __init__(self, m: int): self.cur = 0 self.chunks = m self.reused = [] self.user_chunks = defaultdict(set) def join(self, ownedChunks: List[int]) -&amp;gt; int: if self.reused: userID = heappop(self.reused) else: self.cur += 1 userID = self.cur self.user_chunks[userID] = set(ownedChunks) return userID def leave(self, userID: int) -&amp;gt; None: heappush(self.reused, userID) self.user_chunks.pop(userID) def request(self, userID: int, chunkID: int) -&amp;gt; List[int]: if chunkID &amp;lt; 1 or chunkID &amp;gt; self.chunks: return [] res = [] for k, v in self.</description></item><item><title>1503. Last Moment Before All Ants Fall Out of a Plank</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1503/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1503/</guid><description>LeetCode problem 1503
class Solution: def getLastMoment(self, n: int, left: List[int], right: List[int]) -&amp;gt; int: res = 0 for x in left: res = max(res, x) for x in right: res = max(res, n - x) return res</description></item><item><title>1504. Count Submatrices With All Ones</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1504/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1504/</guid><description>LeetCode problem 1504
class Solution: def numSubmat(self, mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) g = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if mat[i][j]: g[i][j] = 1 if j == 0 else 1 + g[i][j - 1] res = 0 for i in range(m): for j in range(n): col = inf for k in range(i, -1, -1): col = min(col, g[k][j]) res += col return res</description></item><item><title>1506. Find Root of N-Ary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1506/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1506/</guid><description>LeetCode problem 1506
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] &amp;#34;&amp;#34;&amp;#34; class Solution: def findRoot(self, tree: List[&amp;#39;Node&amp;#39;]) -&amp;gt; &amp;#39;Node&amp;#39;: x = 0 for node in tree: x ^= node.val for child in node.children: x ^= child.val return next(node for node in tree if node.val == x)</description></item><item><title>1508. Range Sum of Sorted Subarray Sums</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1508/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1508/</guid><description>LeetCode problem 1508
class Solution: def rangeSum(self, nums: List[int], n: int, left: int, right: int) -&amp;gt; int: arr = [] for i in range(n): s = 0 for j in range(i, n): s += nums[j] arr.append(s) arr.sort() mod = 10**9 + 7 return sum(arr[left - 1 : right]) % mod</description></item><item><title>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1509/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1509/</guid><description>LeetCode problem 1509
class Solution: def minDifference(self, nums: List[int]) -&amp;gt; int: n = len(nums) if n &amp;lt; 5: return 0 nums.sort() res = inf for l in range(4): r = 3 - l res = min(res, nums[n - 1 - r] - nums[l]) return res</description></item><item><title>1514. Path with Maximum Probability</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1514/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1514/</guid><description>LeetCode problem 1514
class Solution: def maxProbability( self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int, ) -&amp;gt; float: g = defaultdict(list) for (a, b), s in zip(edges, succProb): g[a].append((b, s)) g[b].append((a, s)) d = [0] * n vis = [False] * n d[start] = 1 q = deque([start]) vis[start] = True while q: i = q.popleft() vis[i] = False for j, s in g[i]: if d[j] &amp;lt; d[i] * s: d[j] = d[i] * s if not vis[j]: q.</description></item><item><title>1519. Number of Nodes in the Sub-Tree With the Same Label</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1519/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1519/</guid><description>LeetCode problem 1519
class Solution: def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&amp;gt; List[int]: def dfs(i, fa): res[i] -= cnt[labels[i]] cnt[labels[i]] += 1 for j in g[i]: if j != fa: dfs(j, i) res[i] += cnt[labels[i]] g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) cnt = Counter() res = [0] * n dfs(0, -1) return res</description></item><item><title>1522. Diameter of N-Ary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1522/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1522/</guid><description>LeetCode problem 1522
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] &amp;#34;&amp;#34;&amp;#34; class Solution: def diameter(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; int: &amp;#34;&amp;#34;&amp;#34; :type root: &amp;#39;Node&amp;#39; :rtype: int &amp;#34;&amp;#34;&amp;#34; def build(root): nonlocal d if root is None: return for child in root.children: d[root].add(child) d[child].add(root) build(child) def dfs(u, t): nonlocal res, vis, d, next if u in vis: return vis.add(u) for v in d[u]: dfs(v, t + 1) if res &amp;lt; t: res = t next = u d = defaultdict(set) vis = set() build(root) res = 0 next = None dfs(root, 0) vis.</description></item><item><title>1524. Number of Sub-arrays With Odd Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1524/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1524/</guid><description>LeetCode problem 1524
class Solution: def numOfSubarrays(self, arr: List[int]) -&amp;gt; int: mod = 10**9 + 7 cnt = [1, 0] res = s = 0 for x in arr: s += x res = (res + cnt[s &amp;amp; 1 ^ 1]) % mod cnt[s &amp;amp; 1] += 1 return res</description></item><item><title>1525. Number of Good Ways to Split a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1525/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1525/</guid><description>LeetCode problem 1525
class Solution: def numSplits(self, s: str) -&amp;gt; int: cnt = Counter(s) vis = set() res = 0 for c in s: vis.add(c) cnt[c] -= 1 if cnt[c] == 0: cnt.pop(c) res += len(vis) == len(cnt) return res</description></item><item><title>1529. Minimum Suffix Flips</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1529/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1529/</guid><description>LeetCode problem 1529
class Solution: def minFlips(self, target: str) -&amp;gt; int: res = 0 for v in target: if (res &amp;amp; 1) ^ int(v): res += 1 return res</description></item><item><title>1530. Number of Good Leaf Nodes Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1530/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1530/</guid><description>LeetCode problem 1530
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def countPairs(self, root: TreeNode, distance: int) -&amp;gt; int: def dfs(root, cnt, i): if root is None or i &amp;gt;= distance: return if root.left is None and root.right is None: cnt[i] += 1 return dfs(root.left, cnt, i + 1) dfs(root.right, cnt, i + 1) if root is None: return 0 res = self.</description></item><item><title>1533. Find the Index of the Large Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1533/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1533/</guid><description>LeetCode problem 1533
# &amp;#34;&amp;#34;&amp;#34; # This is ArrayReader&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class ArrayReader(object): # # Compares the sum of arr[l..r] with the sum of arr[x..y] # # return 1 if sum(arr[l..r]) &amp;gt; sum(arr[x..y]) # # return 0 if sum(arr[l..r]) == sum(arr[x..y]) # # return -1 if sum(arr[l..r]) &amp;lt; sum(arr[x..y]) # def compareSub(self, l: int, r: int, x: int, y: int) -&amp;gt; int: # # # Returns the length of the array # def length(self) -&amp;gt; int: # class Solution: def getIndex(self, reader: &amp;#39;ArrayReader&amp;#39;) -&amp;gt; int: left, right = 0, reader.</description></item><item><title>1535. Find the Winner of an Array Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1535/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1535/</guid><description>LeetCode problem 1535
class Solution: def getWinner(self, arr: List[int], k: int) -&amp;gt; int: mx = arr[0] cnt = 0 for x in arr[1:]: if mx &amp;lt; x: mx = x cnt = 1 else: cnt += 1 if cnt == k: break return mx</description></item><item><title>1536. Minimum Swaps to Arrange a Binary Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1536/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1536/</guid><description>LeetCode problem 1536
class Solution: def minSwaps(self, grid: List[List[int]]) -&amp;gt; int: n = len(grid) pos = [-1] * n for i in range(n): for j in range(n - 1, -1, -1): if grid[i][j] == 1: pos[i] = j break res = 0 for i in range(n): k = -1 for j in range(i, n): if pos[j] &amp;lt;= i: res += j - i k = j break if k == -1: return -1 while k &amp;gt; i: pos[k], pos[k - 1] = pos[k - 1], pos[k] k -= 1 return res</description></item><item><title>1538. Guess the Majority in a Hidden Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1538/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1538/</guid><description>LeetCode problem 1538
# &amp;#34;&amp;#34;&amp;#34; # This is the ArrayReader&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class ArrayReader(object): # # Compares 4 different elements in the array # # return 4 if the values of the 4 elements are the same (0 or 1). # # return 2 if three elements have a value equal to 0 and one element has value equal to 1 or vice versa. # # return 0 : if two element have a value equal to 0 and two elements have a value equal to 1.</description></item><item><title>1540. Can Convert String in K Moves</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1540/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1540/</guid><description>LeetCode problem 1540
class Solution: def canConvertString(self, s: str, t: str, k: int) -&amp;gt; bool: if len(s) != len(t): return False cnt = [0] * 26 for a, b in zip(s, t): x = (ord(b) - ord(a) + 26) % 26 cnt[x] += 1 for i in range(1, 26): if i + 26 * (cnt[i] - 1) &amp;gt; k: return False return True</description></item><item><title>1541. Minimum Insertions to Balance a Parentheses String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1541/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1541/</guid><description>LeetCode problem 1541
class Solution: def minInsertions(self, s: str) -&amp;gt; int: res = x = 0 i, n = 0, len(s) while i &amp;lt; n: if s[i] == &amp;#39;(&amp;#39;: # 待匹配的左括号加 1 x += 1 else: if i &amp;lt; n - 1 and s[i + 1] == &amp;#39;)&amp;#39;: # 有连续两个右括号，i 往后移动 i += 1 else: # 只有一个右括号，插入一个 res += 1 if x == 0: # 无待匹配的左括号，插入一个 res += 1 else: # 待匹配的左括号减 1 x -= 1 i += 1 # 遍历结束，仍有待匹配的左括号，说明右括号不足，插入 x &amp;lt;&amp;lt; 1 个 res += x &amp;lt;&amp;lt; 1 return res</description></item><item><title>1545. Find Kth Bit in Nth Binary String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1545/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1545/</guid><description>LeetCode problem 1545
class Solution: def findKthBit(self, n: int, k: int) -&amp;gt; str: def dfs(n: int, k: int) -&amp;gt; int: if k == 1: return 0 if (k &amp;amp; (k - 1)) == 0: return 1 m = 1 &amp;lt;&amp;lt; n if k * 2 &amp;lt; m - 1: return dfs(n - 1, k) return dfs(n - 1, m - k) ^ 1 return str(dfs(n, k))</description></item><item><title>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1546/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1546/</guid><description>LeetCode problem 1546
class Solution: def maxNonOverlapping(self, nums: List[int], target: int) -&amp;gt; int: res = 0 i, n = 0, len(nums) while i &amp;lt; n: s = 0 vis = {0} while i &amp;lt; n: s += nums[i] if s - target in vis: res += 1 break i += 1 vis.add(s) i += 1 return res</description></item><item><title>1551. Minimum Operations to Make Array Equal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1551/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1551/</guid><description>LeetCode problem 1551
class Solution: def minOperations(self, n: int) -&amp;gt; int: return sum(n - (i &amp;lt;&amp;lt; 1 | 1) for i in range(n &amp;gt;&amp;gt; 1))</description></item><item><title>1552. Magnetic Force Between Two Balls</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1552/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1552/</guid><description>LeetCode problem 1552
class Solution: def maxDistance(self, position: List[int], m: int) -&amp;gt; int: def check(f): prev = position[0] cnt = 1 for curr in position[1:]: if curr - prev &amp;gt;= f: prev = curr cnt += 1 return cnt &amp;gt;= m position.sort() left, right = 1, position[-1] while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if check(mid): left = mid else: right = mid - 1 return left</description></item><item><title>1554. Strings Differ by One Character</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1554/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1554/</guid><description>LeetCode problem 1554
class Solution: def differByOne(self, dict: List[str]) -&amp;gt; bool: s = set() for word in dict: for i in range(len(word)): t = word[:i] + &amp;#34;*&amp;#34; + word[i + 1 :] if t in s: return True s.add(t) return False</description></item><item><title>1557. Minimum Number of Vertices to Reach All Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1557/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1557/</guid><description>LeetCode problem 1557
class Solution: def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: cnt = Counter(t for _, t in edges) return [i for i in range(n) if cnt[i] == 0]</description></item><item><title>1558. Minimum Numbers of Function Calls to Make Target Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1558/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1558/</guid><description>LeetCode problem 1558
class Solution: def minOperations(self, nums: List[int]) -&amp;gt; int: return sum(v.bit_count() for v in nums) + max(0, max(nums).bit_length() - 1)</description></item><item><title>1561. Maximum Number of Coins You Can Get</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1561/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1561/</guid><description>LeetCode problem 1561
class Solution: def maxCoins(self, piles: List[int]) -&amp;gt; int: piles.sort() return sum(piles[-2 : len(piles) // 3 - 1 : -2])</description></item><item><title>1562. Find Latest Group of Size M</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1562/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1562/</guid><description>LeetCode problem 1562
class Solution: def findLatestStep(self, arr: List[int], m: int) -&amp;gt; int: n = len(arr) if m == n: return n cnt = [0] * (n + 2) res = -1 for i, v in enumerate(arr): v -= 1 l, r = cnt[v - 1], cnt[v + 1] if l == m or r == m: res = i cnt[v - l] = cnt[v + r] = l + r + 1 return res</description></item><item><title>1564. Put Boxes Into the Warehouse I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1564/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1564/</guid><description>LeetCode problem 1564
class Solution: def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -&amp;gt; int: n = len(warehouse) left = [warehouse[0]] * n for i in range(1, n): left[i] = min(left[i - 1], warehouse[i]) boxes.sort() i, j = 0, n - 1 while i &amp;lt; len(boxes): while j &amp;gt;= 0 and left[j] &amp;lt; boxes[i]: j -= 1 if j &amp;lt; 0: break i, j = i + 1, j - 1 return i</description></item><item><title>1567. Maximum Length of Subarray With Positive Product</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1567/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1567/</guid><description>LeetCode problem 1567
class Solution: def getMaxLen(self, nums: List[int]) -&amp;gt; int: f1 = 1 if nums[0] &amp;gt; 0 else 0 f2 = 1 if nums[0] &amp;lt; 0 else 0 res = f1 for num in nums[1:]: pf1, pf2 = f1, f2 if num &amp;gt; 0: f1 += 1 if f2 &amp;gt; 0: f2 += 1 else: f2 = 0 elif num &amp;lt; 0: pf1, pf2 = f1, f2 f2 = pf1 + 1 if pf2 &amp;gt; 0: f1 = pf2 + 1 else: f1 = 0 else: f1 = 0 f2 = 0 res = max(res, f1) return res</description></item><item><title>1570. Dot Product of Two Sparse Vectors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1570/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1570/</guid><description>LeetCode problem 1570
class SparseVector: def __init__(self, nums: List[int]): self.d = {i: v for i, v in enumerate(nums) if v} # Return the dotProduct of two sparse vectors def dotProduct(self, vec: &amp;#34;SparseVector&amp;#34;) -&amp;gt; int: a, b = self.d, vec.d if len(b) &amp;lt; len(a): a, b = b, a return sum(v * b.get(i, 0) for i, v in a.items()) # Your SparseVector object will be instantiated and called as such: # v1 = SparseVector(nums1) # v2 = SparseVector(nums2) # res = v1.</description></item><item><title>1573. Number of Ways to Split a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1573/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1573/</guid><description>LeetCode problem 1573
class Solution: def numWays(self, s: str) -&amp;gt; int: def find(x): t = 0 for i, c in enumerate(s): t += int(c == &amp;#39;1&amp;#39;) if t == x: return i cnt, m = divmod(sum(c == &amp;#39;1&amp;#39; for c in s), 3) if m: return 0 n = len(s) mod = 10**9 + 7 if cnt == 0: return ((n - 1) * (n - 2) // 2) % mod i1, i2 = find(cnt), find(cnt + 1) j1, j2 = find(cnt * 2), find(cnt * 2 + 1) return (i2 - i1) * (j2 - j1) % (10**9 + 7)</description></item><item><title>1574. Shortest Subarray to be Removed to Make Array Sorted</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1574/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1574/</guid><description>LeetCode problem 1574
class Solution: def findLengthOfShortestSubarray(self, arr: List[int]) -&amp;gt; int: n = len(arr) i, j = 0, n - 1 while i + 1 &amp;lt; n and arr[i] &amp;lt;= arr[i + 1]: i += 1 while j - 1 &amp;gt;= 0 and arr[j - 1] &amp;lt;= arr[j]: j -= 1 if i &amp;gt;= j: return 0 res = min(n - i - 1, j) r = j for l in range(i + 1): while r &amp;lt; n and arr[r] &amp;lt; arr[l]: r += 1 res = min(res, r - l - 1) return res</description></item><item><title>1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1577/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1577/</guid><description>LeetCode problem 1577
class Solution: def numTriplets(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: cnt1 = Counter(nums1) cnt2 = Counter(nums2) res = 0 for a, x in cnt1.items(): for b, y in cnt2.items(): if a * a % b == 0: c = a * a // b if b == c: res += x * y * (y - 1) else: res += x * y * cnt2[c] if b * b % a == 0: c = b * b // a if a == c: res += x * (x - 1) * y else: res += x * y * cnt1[c] return res &amp;gt;&amp;gt; 1</description></item><item><title>1578. Minimum Time to Make Rope Colorful</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1578/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1578/</guid><description>LeetCode problem 1578
class Solution: def minCost(self, colors: str, neededTime: List[int]) -&amp;gt; int: res = i = 0 n = len(colors) while i &amp;lt; n: j = i s = mx = 0 while j &amp;lt; n and colors[j] == colors[i]: s += neededTime[j] if mx &amp;lt; neededTime[j]: mx = neededTime[j] j += 1 if j - i &amp;gt; 1: res += s - mx i = j return res</description></item><item><title>1580. Put Boxes Into the Warehouse II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1580/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1580/</guid><description>LeetCode problem 1580
class Solution: def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -&amp;gt; int: n = len(warehouse) left = [0] * n right = [0] * n left[0] = right[-1] = inf for i in range(1, n): left[i] = min(left[i - 1], warehouse[i - 1]) for i in range(n - 2, -1, -1): right[i] = min(right[i + 1], warehouse[i + 1]) for i in range(n): warehouse[i] = min(warehouse[i], max(left[i], right[i])) boxes.sort() warehouse.sort() res = i = 0 for x in boxes: while i &amp;lt; n and warehouse[i] &amp;lt; x: i += 1 if i == n: break res, i = res + 1, i + 1 return res</description></item><item><title>1583. Count Unhappy Friends</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1583/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1583/</guid><description>LeetCode problem 1583
class Solution: def unhappyFriends( self, n: int, preferences: List[List[int]], pairs: List[List[int]] ) -&amp;gt; int: d = [{p: i for i, p in enumerate(v)} for v in preferences] p = {} for x, y in pairs: p[x] = y p[y] = x res = 0 for x in range(n): y = p[x] res += any(d[u][x] &amp;lt; d[u][p[u]] for u in preferences[x][: d[x][y]]) return res</description></item><item><title>1584. Min Cost to Connect All Points</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1584/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1584/</guid><description>LeetCode problem 1584
class Solution: def minCostConnectPoints(self, points: List[List[int]]) -&amp;gt; int: def find(x: int) -&amp;gt; int: if p[x] != x: p[x] = find(p[x]) return p[x] n = len(points) g = [] for i, (x1, y1) in enumerate(points): for j in range(i + 1, n): x2, y2 = points[j] t = abs(x1 - x2) + abs(y1 - y2) g.append((t, i, j)) p = list(range(n)) res = 0 for cost, i, j in sorted(g): pa, pb = find(i), find(j) if pa == pb: continue p[pa] = pb res += cost n -= 1 if n == 1: break return res</description></item><item><title>1586. Binary Search Tree Iterator II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1586/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1586/</guid><description>LeetCode problem 1586
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator: def __init__(self, root: Optional[TreeNode]): self.nums = [] def dfs(root): if root is None: return dfs(root.left) self.nums.append(root.val) dfs(root.right) dfs(root) self.i = -1 def hasNext(self) -&amp;gt; bool: return self.i &amp;lt; len(self.nums) - 1 def next(self) -&amp;gt; int: self.i += 1 return self.nums[self.i] def hasPrev(self) -&amp;gt; bool: return self.</description></item><item><title>1589. Maximum Sum Obtained of Any Permutation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1589/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1589/</guid><description>LeetCode problem 1589
class Solution: def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -&amp;gt; int: n = len(nums) d = [0] * n for l, r in requests: d[l] += 1 if r + 1 &amp;lt; n: d[r + 1] -= 1 for i in range(1, n): d[i] += d[i - 1] nums.sort() d.sort() mod = 10**9 + 7 return sum(a * b for a, b in zip(nums, d)) % mod</description></item><item><title>1590. Make Sum Divisible by P</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1590/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1590/</guid><description>LeetCode problem 1590
class Solution: def minSubarray(self, nums: List[int], p: int) -&amp;gt; int: k = sum(nums) % p if k == 0: return 0 last = {0: -1} cur = 0 res = len(nums) for i, x in enumerate(nums): cur = (cur + x) % p target = (cur - k + p) % p if target in last: res = min(res, i - last[target]) last[cur] = i return -1 if res == len(nums) else res</description></item><item><title>1593. Split a String Into the Max Number of Unique Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1593/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1593/</guid><description>LeetCode problem 1593
class Solution: def maxUniqueSplit(self, s: str) -&amp;gt; int: def dfs(i, t): if i &amp;gt;= len(s): nonlocal res res = max(res, t) return for j in range(i + 1, len(s) + 1): if s[i:j] not in vis: vis.add(s[i:j]) dfs(j, t + 1) vis.remove(s[i:j]) vis = set() res = 1 dfs(0, 0) return res</description></item><item><title>1594. Maximum Non Negative Product in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1594/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1594/</guid><description>LeetCode problem 1594
class Solution: def maxProductPath(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) mod = 10**9 + 7 dp = [[[grid[0][0]] * 2 for _ in range(n)] for _ in range(m)] for i in range(1, m): dp[i][0] = [dp[i - 1][0][0] * grid[i][0]] * 2 for j in range(1, n): dp[0][j] = [dp[0][j - 1][0] * grid[0][j]] * 2 for i in range(1, m): for j in range(1, n): v = grid[i][j] if v &amp;gt;= 0: dp[i][j][0] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v dp[i][j][1] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v else: dp[i][j][0] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v dp[i][j][1] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v res = dp[-1][-1][1] return -1 if res &amp;lt; 0 else res % mod</description></item><item><title>1599. Maximum Profit of Operating a Centennial Wheel</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1599/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1599/</guid><description>LeetCode problem 1599
class Solution: def minOperationsMaxProfit( self, customers: List[int], boardingCost: int, runningCost: int ) -&amp;gt; int: res = -1 mx = t = 0 wait = 0 i = 0 while wait or i &amp;lt; len(customers): wait += customers[i] if i &amp;lt; len(customers) else 0 up = wait if wait &amp;lt; 4 else 4 wait -= up t += up * boardingCost - runningCost i += 1 if t &amp;gt; mx: mx = t res = i return res</description></item><item><title>1600. Throne Inheritance</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1600/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1600/</guid><description>LeetCode problem 1600
class ThroneInheritance: def __init__(self, kingName: str): self.g = defaultdict(list) self.dead = set() self.king = kingName def birth(self, parentName: str, childName: str) -&amp;gt; None: self.g[parentName].append(childName) def death(self, name: str) -&amp;gt; None: self.dead.add(name) def getInheritanceOrder(self) -&amp;gt; List[str]: def dfs(x): if x not in self.dead: res.append(x) for y in self.g[x]: dfs(y) res = [] dfs(self.king) return res # Your ThroneInheritance object will be instantiated and called as such: # obj = ThroneInheritance(kingName) # obj.birth(parentName,childName) # obj.death(name) # param_3 = obj.</description></item><item><title>1602. Find Nearest Right Node in Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1602/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1602/</guid><description>LeetCode problem 1602
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findNearestRightNode(self, root: TreeNode, u: TreeNode) -&amp;gt; Optional[TreeNode]: def dfs(root, i): nonlocal d, res if root is None or res: return if d == i: res = root return if root == u: d = i return dfs(root.left, i + 1) dfs(root.right, i + 1) d = 0 res = None dfs(root, 1) return res</description></item><item><title>1604. Alert Using Same Key-Card Three or More Times in a One Hour Period</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1604/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1604/</guid><description>LeetCode problem 1604
class Solution: def alertNames(self, keyName: List[str], keyTime: List[str]) -&amp;gt; List[str]: d = defaultdict(list) for name, t in zip(keyName, keyTime): t = int(t[:2]) * 60 + int(t[3:]) d[name].append(t) res = [] for name, ts in d.items(): if (n := len(ts)) &amp;gt; 2: ts.sort() for i in range(n - 2): if ts[i + 2] - ts[i] &amp;lt;= 60: res.append(name) break res.sort() return res</description></item><item><title>1605. Find Valid Matrix Given Row and Column Sums</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1605/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1605/</guid><description>LeetCode problem 1605
class Solution: def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -&amp;gt; List[List[int]]: m, n = len(rowSum), len(colSum) res = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): x = min(rowSum[i], colSum[j]) res[i][j] = x rowSum[i] -= x colSum[j] -= x return res</description></item><item><title>1609. Even Odd Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1609/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1609/</guid><description>LeetCode problem 1609
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isEvenOddTree(self, root: Optional[TreeNode]) -&amp;gt; bool: def dfs(root, i): if root is None: return True even = i % 2 == 0 prev = d.get(i, 0 if even else inf) if even and (root.val % 2 == 0 or prev &amp;gt;= root.val): return False if not even and (root.</description></item><item><title>1612. Check If Two Expression Trees are Equivalent</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1612/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1612/</guid><description>LeetCode problem 1612
# Definition for a binary tree node. # class Node(object): # def __init__(self, val=&amp;#34; &amp;#34;, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def checkEquivalence(self, root1: &amp;#39;Node&amp;#39;, root2: &amp;#39;Node&amp;#39;) -&amp;gt; bool: def dfs(root): cnt = [0] * 26 if root is None: return cnt if root.val in &amp;#39;+-&amp;#39;: l, r = dfs(root.left), dfs(root.right) k = 1 if root.val == &amp;#39;+&amp;#39; else -1 for i in range(26): cnt[i] += l[i] + r[i] * k else: cnt[ord(root.</description></item><item><title>1615. Maximal Network Rank</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1615/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1615/</guid><description>LeetCode problem 1615
class Solution: def maximalNetworkRank(self, n: int, roads: List[List[int]]) -&amp;gt; int: g = [[0] * n for _ in range(n)] cnt = [0] * n for a, b in roads: g[a][b] = g[b][a] = 1 cnt[a] += 1 cnt[b] += 1 return max(cnt[a] + cnt[b] - g[a][b] for a in range(n) for b in range(a + 1, n))</description></item><item><title>1616. Split Two Strings to Make Palindrome</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1616/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1616/</guid><description>LeetCode problem 1616
class Solution: def checkPalindromeFormation(self, a: str, b: str) -&amp;gt; bool: def check1(a: str, b: str) -&amp;gt; bool: i, j = 0, len(b) - 1 while i &amp;lt; j and a[i] == b[j]: i, j = i + 1, j - 1 return i &amp;gt;= j or check2(a, i, j) or check2(b, i, j) def check2(a: str, i: int, j: int) -&amp;gt; bool: return a[i : j + 1] == a[i : j + 1][::-1] return check1(a, b) or check1(b, a)</description></item><item><title>1618. Maximum Font to Fit a Sentence in a Screen</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1618/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1618/</guid><description>LeetCode problem 1618
# &amp;#34;&amp;#34;&amp;#34; # This is FontInfo&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class FontInfo(object): # Return the width of char ch when fontSize is used. # def getWidth(self, fontSize, ch): # &amp;#34;&amp;#34;&amp;#34; # :type fontSize: int # :type ch: char # :rtype int # &amp;#34;&amp;#34;&amp;#34; # # def getHeight(self, fontSize): # &amp;#34;&amp;#34;&amp;#34; # :type fontSize: int # :rtype int # &amp;#34;&amp;#34;&amp;#34; class Solution: def maxFont( self, text: str, w: int, h: int, fonts: List[int], fontInfo: &amp;#39;FontInfo&amp;#39; ) -&amp;gt; int: def check(size): if fontInfo.</description></item><item><title>1620. Coordinate With Maximum Network Quality</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1620/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1620/</guid><description>LeetCode problem 1620
class Solution: def bestCoordinate(self, towers: List[List[int]], radius: int) -&amp;gt; List[int]: mx = 0 res = [0, 0] for i in range(51): for j in range(51): t = 0 for x, y, q in towers: d = ((x - i) ** 2 + (y - j) ** 2) ** 0.5 if d &amp;lt;= radius: t += floor(q / (1 + d)) if t &amp;gt; mx: mx = t res = [i, j] return res</description></item><item><title>1621. Number of Sets of K Non-Overlapping Line Segments</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1621/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1621/</guid><description>LeetCode problem 1621
class Solution: def numberOfSets(self, n: int, k: int) -&amp;gt; int: mod = 10**9 + 7 f = [[0] * (k + 1) for _ in range(n + 1)] g = [[0] * (k + 1) for _ in range(n + 1)] f[1][0] = 1 for i in range(2, n + 1): for j in range(k + 1): f[i][j] = (f[i - 1][j] + g[i - 1][j]) % mod g[i][j] = g[i - 1][j] if j: g[i][j] += f[i - 1][j - 1] g[i][j] %= mod g[i][j] += g[i - 1][j - 1] g[i][j] %= mod return (f[-1][-1] + g[-1][-1]) % mod</description></item><item><title>1625. Lexicographically Smallest String After Applying Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1625/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1625/</guid><description>LeetCode problem 1625
class Solution: def findLexSmallestString(self, s: str, a: int, b: int) -&amp;gt; str: res = s n = len(s) s = list(s) for _ in range(n): s = s[-b:] + s[:-b] for j in range(10): for k in range(1, n, 2): s[k] = str((int(s[k]) + a) % 10) if b &amp;amp; 1: for p in range(10): for k in range(0, n, 2): s[k] = str((int(s[k]) + a) % 10) t = &amp;#39;&amp;#39;.join(s) if res &amp;gt; t: res = t else: t = &amp;#39;&amp;#39;.</description></item><item><title>1626. Best Team With No Conflicts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1626/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1626/</guid><description>LeetCode problem 1626
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) def update(self, x, val): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], val) x += x &amp;amp; -x def query(self, x): s = 0 while x: s = max(s, self.c[x]) x -= x &amp;amp; -x return s class Solution: def bestTeamScore(self, scores: List[int], ages: List[int]) -&amp;gt; int: m = max(ages) tree = BinaryIndexedTree(m) for score, age in sorted(zip(scores, ages)): tree.update(age, score + tree.</description></item><item><title>1628. Design an Expression Tree With Evaluate Function</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1628/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1628/</guid><description>LeetCode problem 1628
import abc from abc import ABC, abstractmethod &amp;#34;&amp;#34;&amp;#34; This is the interface for the expression tree Node. You should not remove it, and you can define some classes to implement it. &amp;#34;&amp;#34;&amp;#34; class Node(ABC): @abstractmethod # define your fields here def evaluate(self) -&amp;gt; int: pass class MyNode(Node): def __init__(self, val): self.val = val self.left = None self.right = None def evaluate(self) -&amp;gt; int: x = self.val if x.isdigit(): return int(x) left, right = self.left.evaluate(), self.right.evaluate() if x == &amp;#39;+&amp;#39;: return left + right if x == &amp;#39;-&amp;#39;: return left - right if x == &amp;#39;*&amp;#39;: return left * right if x == &amp;#39;/&amp;#39;: return left // right &amp;#34;&amp;#34;&amp;#34; This is the TreeBuilder class.</description></item><item><title>1630. Arithmetic Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1630/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1630/</guid><description>LeetCode problem 1630
class Solution: def checkArithmeticSubarrays( self, nums: List[int], l: List[int], r: List[int] ) -&amp;gt; List[bool]: def check(nums, l, r): n = r - l + 1 s = set(nums[l : l + n]) a1, an = min(nums[l : l + n]), max(nums[l : l + n]) d, mod = divmod(an - a1, n - 1) return mod == 0 and all((a1 + (i - 1) * d) in s for i in range(1, n)) return [check(nums, left, right) for left, right in zip(l, r)]</description></item><item><title>1631. Path With Minimum Effort</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1631/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1631/</guid><description>LeetCode problem 1631
class Solution: def minimumEffortPath(self, heights: List[List[int]]) -&amp;gt; int: m, n = len(heights), len(heights[0]) dist = [[inf] * n for _ in range(m)] dist[0][0] = 0 dirs = (-1, 0, 1, 0, -1) q = [(0, 0, 0)] while q: t, i, j = heappop(q) for a, b in pairwise(dirs): x, y = i + a, j + b if ( 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and (d := max(t, abs(heights[i][j] - heights[x][y]))) &amp;lt; dist[x][y] ): dist[x][y] = d heappush(q, (d, x, y)) return int(dist[-1][-1])</description></item><item><title>1634. Add Two Polynomials Represented as Linked Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1634/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1634/</guid><description>LeetCode problem 1634
# Definition for polynomial singly-linked list. # class PolyNode: # def __init__(self, x=0, y=0, next=None): # self.coefficient = x # self.power = y # self.next = next class Solution: def addPoly(self, poly1: &amp;#34;PolyNode&amp;#34;, poly2: &amp;#34;PolyNode&amp;#34;) -&amp;gt; &amp;#34;PolyNode&amp;#34;: dummy = curr = PolyNode() while poly1 and poly2: if poly1.power &amp;gt; poly2.power: curr.next = poly1 poly1 = poly1.next curr = curr.next elif poly1.power &amp;lt; poly2.power: curr.next = poly2 poly2 = poly2.next curr = curr.next else: if c := poly1.</description></item><item><title>1638. Count Substrings That Differ by One Character</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1638/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1638/</guid><description>LeetCode problem 1638
class Solution: def countSubstrings(self, s: str, t: str) -&amp;gt; int: res = 0 m, n = len(s), len(t) f = [[0] * (n + 1) for _ in range(m + 1)] g = [[0] * (n + 1) for _ in range(m + 1)] for i, a in enumerate(s, 1): for j, b in enumerate(t, 1): if a == b: f[i][j] = f[i - 1][j - 1] + 1 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): if s[i] == t[j]: g[i][j] = g[i + 1][j + 1] + 1 else: res += (f[i][j] + 1) * (g[i + 1][j + 1] + 1) return res</description></item><item><title>1641. Count Sorted Vowel Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1641/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1641/</guid><description>LeetCode problem 1641
class Solution: def countVowelStrings(self, n: int) -&amp;gt; int: f = [1] * 5 for _ in range(n - 1): s = 0 for j in range(5): s += f[j] f[j] = s return sum(f)</description></item><item><title>1642. Furthest Building You Can Reach</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1642/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1642/</guid><description>LeetCode problem 1642
class Solution: def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -&amp;gt; int: h = [] for i, a in enumerate(heights[:-1]): b = heights[i + 1] d = b - a if d &amp;gt; 0: heappush(h, d) if len(h) &amp;gt; ladders: bricks -= heappop(h) if bricks &amp;lt; 0: return i return len(heights) - 1</description></item><item><title>1644. Lowest Common Ancestor of a Binary Tree II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1644/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1644/</guid><description>LeetCode problem 1644
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor( self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39; ) -&amp;gt; &amp;#39;TreeNode&amp;#39;: def dfs(root, p, q): if root is None: return False l = dfs(root.left, p, q) r = dfs(root.right, p, q) nonlocal res if l and r: res = root if (l or r) and (root.val == p.</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1647/</guid><description>LeetCode задача 1647
Задача Строка s называется хорошей, если в ней нет двух разных символов с одинаковой частотой.
Дана строка s, верните минимальное количество символов, которое необходимо удалить, чтобы сделать s хорошим.
Подход Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.
Если проверять встречалась ли частота текущего символа ранее, то
Алгоритм / Абстрактный алгоритм Считаем частоты всех символов в строке. Сортируем частоты в порядке убывания.</description></item><item><title>1648. Sell Diminishing-Valued Colored Balls</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1648/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1648/</guid><description>LeetCode problem 1648
class Solution: def maxProfit(self, inventory: List[int], orders: int) -&amp;gt; int: inventory.sort(reverse=True) mod = 10**9 + 7 res = i = 0 n = len(inventory) while orders &amp;gt; 0: while i &amp;lt; n and inventory[i] &amp;gt;= inventory[0]: i += 1 nxt = 0 if i &amp;lt; n: nxt = inventory[i] cnt = i x = inventory[0] - nxt tot = cnt * x if tot &amp;gt; orders: decr = orders // cnt a1, an = inventory[0] - decr + 1, inventory[0] res += (a1 + an) * decr // 2 * cnt res += (inventory[0] - decr) * (orders % cnt) else: a1, an = nxt + 1, inventory[0] res += (a1 + an) * x // 2 * cnt inventory[0] = nxt orders -= tot res %= mod return res</description></item><item><title>1650. Lowest Common Ancestor of a Binary Tree III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1650/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1650/</guid><description>LeetCode problem 1650
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val): self.val = val self.left = None self.right = None self.parent = None &amp;#34;&amp;#34;&amp;#34; class Solution: def lowestCommonAncestor(self, p: &amp;#39;Node&amp;#39;, q: &amp;#39;Node&amp;#39;) -&amp;gt; &amp;#39;Node&amp;#39;: a, b = p, q while a != b: a = a.parent if a.parent else q b = b.parent if b.parent else p return a</description></item><item><title>1653. Minimum Deletions to Make String Balanced</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1653/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1653/</guid><description>LeetCode problem 1653
class Solution: def minimumDeletions(self, s: str) -&amp;gt; int: lb, ra = 0, s.count(&amp;#39;a&amp;#39;) res = len(s) for c in s: ra -= c == &amp;#39;a&amp;#39; res = min(res, lb + ra) lb += c == &amp;#39;b&amp;#39; return res</description></item><item><title>1654. Minimum Jumps to Reach Home</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1654/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1654/</guid><description>LeetCode problem 1654
class Solution: def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -&amp;gt; int: s = set(forbidden) q = deque([(0, 1)]) vis = {(0, 1)} res = 0 while q: for _ in range(len(q)): i, k = q.popleft() if i == x: return res nxt = [(i + a, 1)] if k &amp;amp; 1: nxt.append((i - b, 0)) for j, k in nxt: if 0 &amp;lt;= j &amp;lt; 6000 and j not in s and (j, k) not in vis: q.</description></item><item><title>1657. Determine if Two Strings Are Close</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1657/</guid><description>LeetCode problem
Problem Statement Two strings are considered close if you can attain one from the other using two operations:
Swap any two existing characters. Transform every occurrence of one existing character into another existing character, and do the same with the other character. The challenge is to determine whether two given strings are close or not.
Naive Solution A naive approach might involve trying every possible combination of operations on the two strings until they match or until you&amp;rsquo;ve exhausted all possibilities.</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1658/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1658/</guid><description>LeetCode problem 1658
Problem Statement You have an integer array nums and another integer x. In a single operation, you can either remove the leftmost or the rightmost element from the array nums and decrement x by the value of the removed element. The question is: What is the minimum number of operations required to reduce x to exactly zero? If it&amp;rsquo;s not feasible, the answer should be -1.
Naive Solution The naive approach would be to explore every possible combination of removing elements from the start or the end, recursively.</description></item><item><title>1660. Correct a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1660/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1660/</guid><description>LeetCode problem 1660
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def correctBinaryTree(self, root: TreeNode) -&amp;gt; TreeNode: def dfs(root): if root is None or root.right in vis: return None vis.add(root) root.right = dfs(root.right) root.left = dfs(root.left) return root vis = set() return dfs(root)</description></item><item><title>1663. Smallest String With A Given Numeric Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1663/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1663/</guid><description>LeetCode problem 1663
class Solution: def getSmallestString(self, n: int, k: int) -&amp;gt; str: res = [&amp;#39;a&amp;#39;] * n i, d = n - 1, k - n while d &amp;gt; 25: res[i] = &amp;#39;z&amp;#39; d -= 25 i -= 1 res[i] = chr(ord(res[i]) + d) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1664. Ways to Make a Fair Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1664/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1664/</guid><description>LeetCode problem 1664
class Solution: def waysToMakeFair(self, nums: List[int]) -&amp;gt; int: s1, s2 = sum(nums[::2]), sum(nums[1::2]) res = t1 = t2 = 0 for i, v in enumerate(nums): res += i % 2 == 0 and t2 + s1 - t1 - v == t1 + s2 - t2 res += i % 2 == 1 and t2 + s1 - t1 == t1 + s2 - t2 - v t1 += v if i % 2 == 0 else 0 t2 += v if i % 2 == 1 else 0 return res</description></item><item><title>1666. Change the Root of a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1666/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1666/</guid><description>LeetCode problem 1666
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val): self.val = val self.left = None self.right = None self.parent = None &amp;#34;&amp;#34;&amp;#34; class Solution: def flipBinaryTree(self, root: &amp;#34;Node&amp;#34;, leaf: &amp;#34;Node&amp;#34;) -&amp;gt; &amp;#34;Node&amp;#34;: cur = leaf p = cur.parent while cur != root: gp = p.parent if cur.left: cur.right = cur.left cur.left = p p.parent = cur if p.left == cur: p.left = None elif p.right == cur: p.right = None cur = p p = gp leaf.</description></item><item><title>1669. Merge In Between Linked Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1669/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1669/</guid><description>LeetCode problem 1669
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeInBetween( self, list1: ListNode, a: int, b: int, list2: ListNode ) -&amp;gt; ListNode: p = q = list1 for _ in range(a - 1): p = p.next for _ in range(b): q = q.next p.next = list2 while p.next: p = p.next p.next = q.next q.next = None return list1</description></item><item><title>1670. Design Front Middle Back Queue</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1670/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1670/</guid><description>LeetCode problem 1670
class FrontMiddleBackQueue: def __init__(self): self.q1 = deque() self.q2 = deque() def pushFront(self, val: int) -&amp;gt; None: self.q1.appendleft(val) self.rebalance() def pushMiddle(self, val: int) -&amp;gt; None: self.q1.append(val) self.rebalance() def pushBack(self, val: int) -&amp;gt; None: self.q2.append(val) self.rebalance() def popFront(self) -&amp;gt; int: if not self.q1 and not self.q2: return -1 if self.q1: val = self.q1.popleft() else: val = self.q2.popleft() self.rebalance() return val def popMiddle(self) -&amp;gt; int: if not self.q1 and not self.q2: return -1 if len(self.q1) == len(self.q2): val = self.</description></item><item><title>1673. Find the Most Competitive Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1673/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1673/</guid><description>LeetCode problem 1673
class Solution: def mostCompetitive(self, nums: List[int], k: int) -&amp;gt; List[int]: stk = [] n = len(nums) for i, v in enumerate(nums): while stk and stk[-1] &amp;gt; v and len(stk) + n - i &amp;gt; k: stk.pop() if len(stk) &amp;lt; k: stk.append(v) return stk</description></item><item><title>1674. Minimum Moves to Make Array Complementary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1674/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1674/</guid><description>LeetCode problem 1674
class Solution: def minMoves(self, nums: List[int], limit: int) -&amp;gt; int: d = [0] * (limit * 2 + 2) n = len(nums) for i in range(n &amp;gt;&amp;gt; 1): a, b = min(nums[i], nums[n - i - 1]), max(nums[i], nums[n - i - 1]) d[2] += 2 d[limit * 2 + 1] -= 2 d[a + 1] -= 1 d[b + limit + 1] += 1 d[a + b] -= 1 d[a + b + 1] += 1 res, s = n, 0 for v in d[2 : limit * 2 + 1]: s += v if res &amp;gt; s: res = s return res</description></item><item><title>1676. Lowest Common Ancestor of a Binary Tree IV</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1676/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1676/</guid><description>LeetCode problem 1676
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor( self, root: &amp;#39;TreeNode&amp;#39;, nodes: &amp;#39;List[TreeNode]&amp;#39; ) -&amp;gt; &amp;#39;TreeNode&amp;#39;: def dfs(root): if root is None or root.val in s: return root left, right = dfs(root.left), dfs(root.right) if left and right: return root return left or right s = {node.val for node in nodes} return dfs(root)</description></item><item><title>1679. Max Number of K-Sum Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1679/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1679/</guid><description>LeetCode задача 1679
Задача Вам дан массив чисел nums и целое число k. Задача — найти максимальное количество пар в массиве, сумма элементов которых равна k.
Подсказки Используйте технику двух указателей(pointers) после сортировки массива для оптимизации поиска пар.
Подход Центральная идея решения задачи заключается в использовании техники двух указателей для быстрого нахождения пар чисел с заданной суммой k. Прежде чем применить эту технику, массив сортируется в возрастающем порядке. Затем создаются два указателя: один, указывающий на начало массива, и второй — на конец.</description></item><item><title>1680. Concatenation of Consecutive Binary Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1680/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1680/</guid><description>LeetCode problem 1680
class Solution: def concatenatedBinary(self, n: int) -&amp;gt; int: mod = 10**9 + 7 res = shift = 0 for i in range(1, n + 1): if (i &amp;amp; (i - 1)) == 0: shift += 1 res = (res &amp;lt;&amp;lt; shift | i) % mod return res</description></item><item><title>1682. Longest Palindromic Subsequence II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1682/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1682/</guid><description>LeetCode problem 1682
class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: @cache def dfs(i, j, x): if i &amp;gt;= j: return 0 if s[i] == s[j] and s[i] != x: return dfs(i + 1, j - 1, s[i]) + 2 return max(dfs(i + 1, j, x), dfs(i, j - 1, x)) res = dfs(0, len(s) - 1, &amp;#39;&amp;#39;) dfs.cache_clear() return res</description></item><item><title>1685. Sum of Absolute Differences in a Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1685/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1685/</guid><description>LeetCode problem 1685
class Solution: def getSumAbsoluteDifferences(self, nums: List[int]) -&amp;gt; List[int]: res = [] s, t = sum(nums), 0 for i, x in enumerate(nums): v = x * i - t + s - t - x * (len(nums) - i) res.append(v) t += x return res</description></item><item><title>1686. Stone Game VI</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1686/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1686/</guid><description>LeetCode problem 1686
class Solution: def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -&amp;gt; int: vals = [(a + b, i) for i, (a, b) in enumerate(zip(aliceValues, bobValues))] vals.sort(reverse=True) a = sum(aliceValues[i] for _, i in vals[::2]) b = sum(bobValues[i] for _, i in vals[1::2]) if a &amp;gt; b: return 1 if a &amp;lt; b: return -1 return 0</description></item><item><title>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1689/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1689/</guid><description>LeetCode problem 1689
class Solution: def minPartitions(self, n: str) -&amp;gt; int: return int(max(n))</description></item><item><title>1690. Stone Game VII</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1690/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1690/</guid><description>LeetCode problem 1690
class Solution: def stoneGameVII(self, stones: List[int]) -&amp;gt; int: s = list(accumulate(stones, initial=0)) n = len(stones) f = [[0] * n for _ in range(n)] for i in range(n - 2, -1, -1): for j in range(i + 1, n): a = s[j + 1] - s[i + 1] - f[i + 1][j] b = s[j] - s[i] - f[i][j - 1] f[i][j] = max(a, b) return f[0][-1]</description></item><item><title>1695. Maximum Erasure Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1695/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1695/</guid><description>LeetCode problem 1695
class Solution: def maximumUniqueSubarray(self, nums: List[int]) -&amp;gt; int: d = defaultdict(int) s = list(accumulate(nums, initial=0)) res = j = 0 for i, v in enumerate(nums, 1): j = max(j, d[v]) res = max(res, s[i] - s[j]) d[v] = i return res</description></item><item><title>1696. Jump Game VI</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1696/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1696/</guid><description>LeetCode problem 1696
class Solution: def maxResult(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) f = [0] * n q = deque([0]) for i in range(n): if i - q[0] &amp;gt; k: q.popleft() f[i] = nums[i] + f[q[0]] while q and f[q[-1]] &amp;lt;= f[i]: q.pop() q.append(i) return f[-1]</description></item><item><title>1698. Number of Distinct Substrings in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1698/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1698/</guid><description>LeetCode problem 1698
class Solution: def countDistinct(self, s: str) -&amp;gt; int: base = 131 n = len(s) p = [0] * (n + 10) h = [0] * (n + 10) p[0] = 1 for i, c in enumerate(s): p[i + 1] = p[i] * base h[i + 1] = h[i] * base + ord(c) ss = set() for i in range(1, n + 1): for j in range(i, n + 1): t = h[j] - h[i - 1] * p[j - i + 1] ss.</description></item><item><title>1701. Average Waiting Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1701/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1701/</guid><description>LeetCode problem 1701
class Solution: def averageWaitingTime(self, customers: List[List[int]]) -&amp;gt; float: tot = t = 0 for a, b in customers: t = max(t, a) + b tot += t - a return tot / len(customers)</description></item><item><title>1702. Maximum Binary String After Change</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1702/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1702/</guid><description>LeetCode problem 1702
class Solution: def maximumBinaryString(self, binary: str) -&amp;gt; str: k = binary.find(&amp;#39;0&amp;#39;) if k == -1: return binary k += binary[k + 1 :].count(&amp;#39;0&amp;#39;) return &amp;#39;1&amp;#39; * k + &amp;#39;0&amp;#39; + &amp;#39;1&amp;#39; * (len(binary) - k - 1)</description></item><item><title>1705. Maximum Number of Eaten Apples</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1705/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1705/</guid><description>LeetCode problem 1705
class Solution: def eatenApples(self, apples: List[int], days: List[int]) -&amp;gt; int: n = len(days) i = res = 0 q = [] while i &amp;lt; n or q: if i &amp;lt; n and apples[i]: heappush(q, (i + days[i] - 1, apples[i])) while q and q[0][0] &amp;lt; i: heappop(q) if q: t, v = heappop(q) v -= 1 res += 1 if v and t &amp;gt; i: heappush(q, (t, v)) i += 1 return res</description></item><item><title>1706. Where Will the Ball Fall</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1706/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1706/</guid><description>LeetCode problem 1706
class Solution: def findBall(self, grid: List[List[int]]) -&amp;gt; List[int]: def dfs(i: int, j: int) -&amp;gt; int: if i == m: return j if j == 0 and grid[i][j] == -1: return -1 if j == n - 1 and grid[i][j] == 1: return -1 if grid[i][j] == 1 and grid[i][j + 1] == -1: return -1 if grid[i][j] == -1 and grid[i][j - 1] == 1: return -1 return dfs(i + 1, j + 1) if grid[i][j] == 1 else dfs(i + 1, j - 1) m, n = len(grid), len(grid[0]) return [dfs(0, j) for j in range(n)]</description></item><item><title>1711. Count Good Meals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1711/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1711/</guid><description>LeetCode problem 1711
class Solution: def countPairs(self, deliciousness: List[int]) -&amp;gt; int: mod = 10**9 + 7 cnt = Counter(deliciousness) res = 0 for i in range(22): s = 1 &amp;lt;&amp;lt; i for a, m in cnt.items(): if (b := s - a) in cnt: res += m * (m - 1) if a == b else m * cnt[b] return (res &amp;gt;&amp;gt; 1) % mod</description></item><item><title>1712. Ways to Split Array Into Three Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1712/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1712/</guid><description>LeetCode problem 1712
class Solution: def waysToSplit(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 s = list(accumulate(nums)) res, n = 0, len(nums) for i in range(n - 2): j = bisect_left(s, s[i] &amp;lt;&amp;lt; 1, i + 1, n - 1) k = bisect_right(s, (s[-1] + s[i]) &amp;gt;&amp;gt; 1, j, n - 1) res += k - j return res % mod</description></item><item><title>1717. Maximum Score From Removing Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1717/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1717/</guid><description>LeetCode problem 1717
class Solution: def maximumGain(self, s: str, x: int, y: int) -&amp;gt; int: if x &amp;lt; y: return self.maximumGain(s[::-1], y, x) res = 0 stk1, stk2 = [], [] for c in s: if c != &amp;#39;b&amp;#39;: stk1.append(c) else: if stk1 and stk1[-1] == &amp;#39;a&amp;#39;: stk1.pop() res += x else: stk1.append(c) while stk1: c = stk1.pop() if c != &amp;#39;b&amp;#39;: stk2.append(c) else: if stk2 and stk2[-1] == &amp;#39;a&amp;#39;: stk2.pop() res += y else: stk2.append(c) return res</description></item><item><title>1718. Construct the Lexicographically Largest Valid Sequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1718/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1718/</guid><description>LeetCode problem 1718
class Solution: def constructDistancedSequence(self, n: int) -&amp;gt; List[int]: def dfs(u): if u == n * 2: return True if path[u]: return dfs(u + 1) for i in range(n, 1, -1): if cnt[i] and u + i &amp;lt; n * 2 and path[u + i] == 0: cnt[i] = 0 path[u] = path[u + i] = i if dfs(u + 1): return True path[u] = path[u + i] = 0 cnt[i] = 2 if cnt[1]: cnt[1], path[u] = 0, 1 if dfs(u + 1): return True path[u], cnt[1] = 0, 1 return False path = [0] * (n * 2) cnt = [2] * (n * 2) cnt[1] = 1 dfs(1) return path[1:]</description></item><item><title>1721. Swapping Nodes in a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1721/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1721/</guid><description>LeetCode problem 1721
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def swapNodes(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: fast = slow = head for _ in range(k - 1): fast = fast.next p = fast while fast.next: fast, slow = fast.next, slow.next q = slow p.val, q.val = q.val, p.val return head</description></item><item><title>1722. Minimize Hamming Distance After Swap Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1722/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1722/</guid><description>LeetCode problem 1722
class Solution: def minimumHammingDistance( self, source: List[int], target: List[int], allowedSwaps: List[List[int]] ) -&amp;gt; int: def find(x: int) -&amp;gt; int: if p[x] != x: p[x] = find(p[x]) return p[x] n = len(source) p = list(range(n)) for a, b in allowedSwaps: p[find(a)] = find(b) cnt = defaultdict(Counter) for i, x in enumerate(source): j = find(i) cnt[j][x] += 1 res = 0 for i, x in enumerate(target): j = find(i) cnt[j][x] -= 1 res += cnt[j][x] &amp;lt; 0 return res</description></item><item><title>1726. Tuple with Same Product</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1726/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1726/</guid><description>LeetCode problem 1726
class Solution: def tupleSameProduct(self, nums: List[int]) -&amp;gt; int: cnt = defaultdict(int) for i in range(1, len(nums)): for j in range(i): x = nums[i] * nums[j] cnt[x] += 1 return sum(v * (v - 1) // 2 for v in cnt.values()) &amp;lt;&amp;lt; 3</description></item><item><title>1727. Largest Submatrix With Rearrangements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1727/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1727/</guid><description>LeetCode problem 1727
class Solution: def largestSubmatrix(self, matrix: List[List[int]]) -&amp;gt; int: for i in range(1, len(matrix)): for j in range(len(matrix[0])): if matrix[i][j]: matrix[i][j] = matrix[i - 1][j] + 1 res = 0 for row in matrix: row.sort(reverse=True) for j, v in enumerate(row, 1): res = max(res, j * v) return res</description></item><item><title>1730. Shortest Path to Get Food</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1730/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1730/</guid><description>LeetCode problem 1730
class Solution: def getFood(self, grid: List[List[str]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) i, j = next((i, j) for i in range(m) for j in range(n) if grid[i][j] == &amp;#39;*&amp;#39;) q = deque([(i, j)]) dirs = (-1, 0, 1, 0, -1) res = 0 while q: res += 1 for _ in range(len(q)): i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n: if grid[x][y] == &amp;#39;#&amp;#39;: return res if grid[x][y] == &amp;#39;O&amp;#39;: grid[x][y] = &amp;#39;X&amp;#39; q.</description></item><item><title>1733. Minimum Number of People to Teach</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1733/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1733/</guid><description>LeetCode problem 1733
class Solution: def minimumTeachings( self, n: int, languages: List[List[int]], friendships: List[List[int]] ) -&amp;gt; int: def check(u, v): for x in languages[u - 1]: for y in languages[v - 1]: if x == y: return True return False s = set() for u, v in friendships: if not check(u, v): s.add(u) s.add(v) cnt = Counter() for u in s: for l in languages[u - 1]: cnt[l] += 1 return len(s) - max(cnt.values(), default=0)</description></item><item><title>1734. Decode XORed Permutation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1734/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1734/</guid><description>LeetCode problem 1734
class Solution: def decode(self, encoded: List[int]) -&amp;gt; List[int]: n = len(encoded) + 1 a = b = 0 for i in range(0, n - 1, 2): a ^= encoded[i] for i in range(1, n + 1): b ^= i perm = [0] * n perm[-1] = a ^ b for i in range(n - 2, -1, -1): perm[i] = encoded[i] ^ perm[i + 1] return perm</description></item><item><title>1737. Change Minimum Characters to Satisfy One of Three Conditions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1737/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1737/</guid><description>LeetCode problem 1737
class Solution: def minCharacters(self, a: str, b: str) -&amp;gt; int: def f(cnt1, cnt2): for i in range(1, 26): t = sum(cnt1[i:]) + sum(cnt2[:i]) nonlocal res res = min(res, t) m, n = len(a), len(b) cnt1 = [0] * 26 cnt2 = [0] * 26 for c in a: cnt1[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 for c in b: cnt2[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 res = m + n for c1, c2 in zip(cnt1, cnt2): res = min(res, m + n - c1 - c2) f(cnt1, cnt2) f(cnt2, cnt1) return res</description></item><item><title>1738. Find Kth Largest XOR Coordinate Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1738/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1738/</guid><description>LeetCode problem 1738
class Solution: def kthLargestValue(self, matrix: List[List[int]], k: int) -&amp;gt; int: m, n = len(matrix), len(matrix[0]) s = [[0] * (n + 1) for _ in range(m + 1)] res = [] for i in range(m): for j in range(n): s[i + 1][j + 1] = s[i + 1][j] ^ s[i][j + 1] ^ s[i][j] ^ matrix[i][j] res.append(s[i + 1][j + 1]) return nlargest(k, res)[-1]</description></item><item><title>1740. Find Distance in a Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1740/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1740/</guid><description>LeetCode problem 1740
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findDistance(self, root: Optional[TreeNode], p: int, q: int) -&amp;gt; int: def lca(root, p, q): if root is None or root.val in [p, q]: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left is None: return right if right is None: return left return root def dfs(root, v): if root is None: return -1 if root.</description></item><item><title>1743. Restore the Array From Adjacent Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1743/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1743/</guid><description>LeetCode problem 1743
class Solution: def restoreArray(self, adjacentPairs: List[List[int]]) -&amp;gt; List[int]: def dfs(i, fa): res.append(i) for j in g[i]: if j != fa: dfs(j, i) g = defaultdict(list) for a, b in adjacentPairs: g[a].append(b) g[b].append(a) i = next(i for i, v in g.items() if len(v) == 1) res = [] dfs(i, 1e6) return res</description></item><item><title>1744. Can You Eat Your Favorite Candy on Your Favorite Day</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1744/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1744/</guid><description>LeetCode problem 1744
class Solution: def canEat(self, candiesCount: List[int], queries: List[List[int]]) -&amp;gt; List[bool]: s = list(accumulate(candiesCount, initial=0)) res = [] for t, day, mx in queries: least, most = day, (day + 1) * mx res.append(least &amp;lt; s[t + 1] and most &amp;gt; s[t]) return res</description></item><item><title>1746. Maximum Subarray Sum After One Operation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1746/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1746/</guid><description>LeetCode problem 1746
class Solution: def maxSumAfterOperation(self, nums: List[int]) -&amp;gt; int: f = g = 0 res = -inf for x in nums: ff = max(f, 0) + x gg = max(max(f, 0) + x * x, g + x) f, g = ff, gg res = max(res, f, g) return res</description></item><item><title>1749. Maximum Absolute Sum of Any Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1749/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1749/</guid><description>LeetCode problem 1749
class Solution: def maxAbsoluteSum(self, nums: List[int]) -&amp;gt; int: f = g = 0 res = 0 for x in nums: f = max(f, 0) + x g = min(g, 0) + x res = max(res, f, abs(g)) return res</description></item><item><title>1750. Minimum Length of String After Deleting Similar Ends</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1750/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1750/</guid><description>LeetCode problem 1750
class Solution: def minimumLength(self, s: str) -&amp;gt; int: p1 = 0 p2 = len(s) - 1 while p1 &amp;lt; p2 and s[p1] == s[p2]: c = s[p1] while p1 &amp;lt;= p2 and s[p1] == c: p1 += 1 while p1 &amp;lt;= p2 and s[p2] == c: p2 -= 1 return p2 - p1 + 1</description></item><item><title>1753. Maximum Score From Removing Stones</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1753/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1753/</guid><description>LeetCode problem 1753
class Solution: def maximumScore(self, a: int, b: int, c: int) -&amp;gt; int: a, b, c = sorted([a, b, c]) if a + b &amp;lt; c: return a + b return (a + b + c) &amp;gt;&amp;gt; 1</description></item><item><title>1754. Largest Merge Of Two Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1754/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1754/</guid><description>LeetCode problem 1754
class Solution: def largestMerge(self, word1: str, word2: str) -&amp;gt; str: i = j = 0 res = [] while i &amp;lt; len(word1) and j &amp;lt; len(word2): if word1[i:] &amp;gt; word2[j:]: res.append(word1[i]) i += 1 else: res.append(word2[j]) j += 1 res.append(word1[i:]) res.append(word2[j:]) return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1756. Design Most Recently Used Queue</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1756/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1756/</guid><description>LeetCode problem 1756
class BinaryIndexedTree: def __init__(self, n: int): self.n = n self.c = [0] * (n + 1) def update(self, x: int, v: int): while x &amp;lt;= self.n: self.c[x] += v x += x &amp;amp; -x def query(self, x: int) -&amp;gt; int: s = 0 while x: s += self.c[x] x -= x &amp;amp; -x return s class MRUQueue: def __init__(self, n: int): self.q = list(range(n + 1)) self.tree = BinaryIndexedTree(n + 2010) def fetch(self, k: int) -&amp;gt; int: l, r = 1, len(self.</description></item><item><title>1759. Count Number of Homogenous Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1759/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1759/</guid><description>LeetCode problem 1759
class Solution: def countHomogenous(self, s: str) -&amp;gt; int: mod = 10**9 + 7 res = cnt = 1 for a, b in pairwise(s): cnt = cnt + 1 if a == b else 1 res = (res + cnt) % mod return res</description></item><item><title>1760. Minimum Limit of Balls in a Bag</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1760/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1760/</guid><description>LeetCode problem 1760
class Solution: def minimumSize(self, nums: List[int], maxOperations: int) -&amp;gt; int: def check(mx: int) -&amp;gt; bool: return sum((x - 1) // mx for x in nums) &amp;lt;= maxOperations return bisect_left(range(1, max(nums)), True, key=check) + 1</description></item><item><title>1762. Buildings With an Ocean View</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1762/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1762/</guid><description>LeetCode problem 1762
class Solution: def findBuildings(self, heights: List[int]) -&amp;gt; List[int]: res = [] mx = 0 for i in range(len(heights) - 1, -1, -1): if heights[i] &amp;gt; mx: res.append(i) mx = heights[i] return res[::-1]</description></item><item><title>1764. Form Array by Concatenating Subarrays of Another Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1764/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1764/</guid><description>LeetCode problem 1764
class Solution: def canChoose(self, groups: List[List[int]], nums: List[int]) -&amp;gt; bool: n, m = len(groups), len(nums) i = j = 0 while i &amp;lt; n and j &amp;lt; m: g = groups[i] if g == nums[j : j + len(g)]: j += len(g) i += 1 else: j += 1 return i == n</description></item><item><title>1765. Map of Highest Peak</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1765/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1765/</guid><description>LeetCode problem 1765
class Solution: def highestPeak(self, isWater: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(isWater), len(isWater[0]) res = [[-1] * n for _ in range(m)] q = deque() for i, row in enumerate(isWater): for j, v in enumerate(row): if v: q.append((i, j)) res[i][j] = 0 while q: for _ in range(len(q)): i, j = q.popleft() for a, b in pairwise((-1, 0, 1, 0, -1)): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and res[x][y] == -1: res[x][y] = res[i][j] + 1 q.</description></item><item><title>1769. Minimum Number of Operations to Move All Balls to Each Box</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1769/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1769/</guid><description>LeetCode problem 1769
class Solution: def minOperations(self, boxes: str) -&amp;gt; List[int]: n = len(boxes) res = [0] * n cnt = 0 for i in range(1, n): if boxes[i - 1] == &amp;#39;1&amp;#39;: cnt += 1 res[i] = res[i - 1] + cnt cnt = s = 0 for i in range(n - 2, -1, -1): if boxes[i + 1] == &amp;#39;1&amp;#39;: cnt += 1 s += cnt res[i] += s return res</description></item><item><title>1772. Sort Features by Popularity</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1772/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1772/</guid><description>LeetCode problem 1772
class Solution: def sortFeatures(self, features: List[str], responses: List[str]) -&amp;gt; List[str]: cnt = Counter() for s in responses: for w in set(s.split()): cnt[w] += 1 return sorted(features, key=lambda w: -cnt[w])</description></item><item><title>1774. Closest Dessert Cost</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1774/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1774/</guid><description>LeetCode problem 1774
class Solution: def closestCost( self, baseCosts: List[int], toppingCosts: List[int], target: int ) -&amp;gt; int: def dfs(i, t): if i &amp;gt;= len(toppingCosts): arr.append(t) return dfs(i + 1, t) dfs(i + 1, t + toppingCosts[i]) arr = [] dfs(0, 0) arr.sort() d = res = inf # 选择一种冰激淋基料 for x in baseCosts: # 枚举子集和 for y in arr: # 二分查找 i = bisect_left(arr, target - x - y) for j in (i, i - 1): if 0 &amp;lt;= j &amp;lt; len(arr): t = abs(x + y + arr[j] - target) if d &amp;gt; t or (d == t and res &amp;gt; x + y + arr[j]): d = t res = x + y + arr[j] return res</description></item><item><title>1775. Equal Sum Arrays With Minimum Number of Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1775/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1775/</guid><description>LeetCode problem 1775
class Solution: def minOperations(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: s1, s2 = sum(nums1), sum(nums2) if s1 == s2: return 0 if s1 &amp;gt; s2: return self.minOperations(nums2, nums1) cnt = Counter([6 - v for v in nums1] + [v - 1 for v in nums2]) d = s2 - s1 res = 0 for i in range(5, 0, -1): while cnt[i] and d &amp;gt; 0: d -= i cnt[i] -= 1 res += 1 return res if d &amp;lt;= 0 else -1</description></item><item><title>1778. Shortest Path in a Hidden Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1778/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1778/</guid><description>LeetCode problem 1778
# &amp;#34;&amp;#34;&amp;#34; # This is GridMaster&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class GridMaster(object): # def canMove(self, direction: str) -&amp;gt; bool: # # # def move(self, direction: str) -&amp;gt; bool: # # # def isTarget(self) -&amp;gt; None: # # class Solution(object): def findShortestPath(self, master: &amp;#34;GridMaster&amp;#34;) -&amp;gt; int: def dfs(i: int, j: int): if master.isTarget(): nonlocal target target = (i, j) return for k, c in enumerate(s): x, y = i + dirs[k], j + dirs[k + 1] if master.</description></item><item><title>1780. Check if Number is a Sum of Powers of Three</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1780/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1780/</guid><description>LeetCode problem 1780
class Solution: def checkPowersOfThree(self, n: int) -&amp;gt; bool: while n: if n % 3 &amp;gt; 1: return False n //= 3 return True</description></item><item><title>1781. Sum of Beauty of All Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1781/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1781/</guid><description>LeetCode problem 1781
class Solution: def beautySum(self, s: str) -&amp;gt; int: res, n = 0, len(s) for i in range(n): cnt = Counter() freq = Counter() mi = mx = 1 for j in range(i, n): freq[cnt[s[j]]] -= 1 cnt[s[j]] += 1 freq[cnt[s[j]]] += 1 if cnt[s[j]] == 1: mi = 1 if freq[mi] == 0: mi += 1 if cnt[s[j]] &amp;gt; mx: mx = cnt[s[j]] res += mx - mi return res</description></item><item><title>1785. Minimum Elements to Add to Form a Given Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1785/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1785/</guid><description>LeetCode problem 1785
class Solution: def minElements(self, nums: List[int], limit: int, goal: int) -&amp;gt; int: d = abs(sum(nums) - goal) return (d + limit - 1) // limit</description></item><item><title>1786. Number of Restricted Paths From First to Last Node</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1786/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1786/</guid><description>LeetCode problem 1786
class Solution: def countRestrictedPaths(self, n: int, edges: List[List[int]]) -&amp;gt; int: g = defaultdict(list) for u, v, w in edges: g[u].append((v, w)) g[v].append((u, w)) dist = [inf] * (n + 1) dist[n] = 0 q = [(0, n)] mod = 10**9 + 7 while q: _, u = heappop(q) for v, w in g[u]: if dist[v] &amp;gt; dist[u] + w: dist[v] = dist[u] + w heappush(q, (dist[v], v)) arr = list(range(1, n + 1)) arr.sort(key=lambda i: dist[i]) f = [0] * (n + 1) f[n] = 1 for i in arr: for j, _ in g[i]: if dist[i] &amp;gt; dist[j]: f[i] = (f[i] + f[j]) % mod return f[1]</description></item><item><title>1792. Maximum Average Pass Ratio</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1792/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1792/</guid><description>LeetCode problem 1792
class Solution: def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -&amp;gt; float: h = [(a / b - (a + 1) / (b + 1), a, b) for a, b in classes] heapify(h) for _ in range(extraStudents): _, a, b = heappop(h) a, b = a + 1, b + 1 heappush(h, (a / b - (a + 1) / (b + 1), a, b)) return sum(v[1] / v[2] for v in h) / len(classes)</description></item><item><title>1794. Count Pairs of Equal Substrings With Minimum Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1794/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1794/</guid><description>LeetCode problem 1794
class Solution: def countQuadruples(self, firstString: str, secondString: str) -&amp;gt; int: last = {c: i for i, c in enumerate(secondString)} res, mi = 0, inf for i, c in enumerate(firstString): if c in last: t = i - last[c] if mi &amp;gt; t: mi = t res = 1 elif mi == t: res += 1 return res</description></item><item><title>1797. Design Authentication Manager</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1797/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1797/</guid><description>LeetCode problem 1797
class AuthenticationManager: def __init__(self, timeToLive: int): self.t = timeToLive self.d = defaultdict(int) def generate(self, tokenId: str, currentTime: int) -&amp;gt; None: self.d[tokenId] = currentTime + self.t def renew(self, tokenId: str, currentTime: int) -&amp;gt; None: if self.d[tokenId] &amp;lt;= currentTime: return self.d[tokenId] = currentTime + self.t def countUnexpiredTokens(self, currentTime: int) -&amp;gt; int: return sum(exp &amp;gt; currentTime for exp in self.d.values()) # Your AuthenticationManager object will be instantiated and called as such: # obj = AuthenticationManager(timeToLive) # obj.generate(tokenId,currentTime) # obj.</description></item><item><title>1798. Maximum Number of Consecutive Values You Can Make</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1798/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1798/</guid><description>LeetCode problem 1798
class Solution: def getMaximumConsecutive(self, coins: List[int]) -&amp;gt; int: res = 1 for v in sorted(coins): if v &amp;gt; res: break res += v return res</description></item><item><title>1801. Number of Orders in the Backlog</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1801/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1801/</guid><description>LeetCode problem 1801
class Solution: def getNumberOfBacklogOrders(self, orders: List[List[int]]) -&amp;gt; int: buy, sell = [], [] for p, a, t in orders: if t == 0: while a and sell and sell[0][0] &amp;lt;= p: x, y = heappop(sell) if a &amp;gt;= y: a -= y else: heappush(sell, (x, y - a)) a = 0 if a: heappush(buy, (-p, a)) else: while a and buy and -buy[0][0] &amp;gt;= p: x, y = heappop(buy) if a &amp;gt;= y: a -= y else: heappush(buy, (x, y - a)) a = 0 if a: heappush(sell, (p, a)) mod = 10**9 + 7 return sum(v[1] for v in buy + sell) % mod</description></item><item><title>1802. Maximum Value at a Given Index in a Bounded Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1802/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1802/</guid><description>LeetCode problem 1802
class Solution: def maxValue(self, n: int, index: int, maxSum: int) -&amp;gt; int: def sum(x, cnt): return ( (x + x - cnt + 1) * cnt // 2 if x &amp;gt;= cnt else (x + 1) * x // 2 + cnt - x ) left, right = 1, maxSum while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if sum(mid - 1, index) + sum(mid, n - index) &amp;lt;= maxSum: left = mid else: right = mid - 1 return left</description></item><item><title>1804. Implement Trie II (Prefix Tree)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1804/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1804/</guid><description>LeetCode problem 1804
class Trie: def __init__(self): self.children = [None] * 26 self.v = self.pv = 0 def insert(self, word: str) -&amp;gt; None: node = self for c in word: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: node.children[idx] = Trie() node = node.children[idx] node.pv += 1 node.v += 1 def countWordsEqualTo(self, word: str) -&amp;gt; int: node = self.search(word) return 0 if node is None else node.v def countWordsStartingWith(self, prefix: str) -&amp;gt; int: node = self.search(prefix) return 0 if node is None else node.</description></item><item><title>1806. Minimum Number of Operations to Reinitialize a Permutation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1806/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1806/</guid><description>LeetCode problem 1806
class Solution: def reinitializePermutation(self, n: int) -&amp;gt; int: res, i = 0, 1 while 1: res += 1 if i &amp;lt; n &amp;gt;&amp;gt; 1: i &amp;lt;&amp;lt;= 1 else: i = (i - (n &amp;gt;&amp;gt; 1)) &amp;lt;&amp;lt; 1 | 1 if i == 1: return res</description></item><item><title>1807. Evaluate the Bracket Pairs of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1807/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1807/</guid><description>LeetCode problem 1807
class Solution: def evaluate(self, s: str, knowledge: List[List[str]]) -&amp;gt; str: d = {a: b for a, b in knowledge} i, n = 0, len(s) res = [] while i &amp;lt; n: if s[i] == &amp;#39;(&amp;#39;: j = s.find(&amp;#39;)&amp;#39;, i + 1) res.append(d.get(s[i + 1 : j], &amp;#39;?&amp;#39;)) i = j else: res.append(s[i]) i += 1 return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1810. Minimum Path Cost in a Hidden Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1810/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1810/</guid><description>LeetCode problem 1810
# &amp;#34;&amp;#34;&amp;#34; # This is GridMaster&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class GridMaster(object): # def canMove(self, direction: str) -&amp;gt; bool: # # # def move(self, direction: str) -&amp;gt; int: # # # def isTarget(self) -&amp;gt; None: # # class Solution(object): def findShortestPath(self, master: &amp;#39;GridMaster&amp;#39;) -&amp;gt; int: def dfs(i, j): nonlocal target if master.isTarget(): target = (i, j) for dir, (a, b, ndir) in dirs.items(): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; N and 0 &amp;lt;= y &amp;lt; N and master.</description></item><item><title>1813. Sentence Similarity III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1813/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1813/</guid><description>LeetCode problem 1813
class Solution: def areSentencesSimilar(self, sentence1: str, sentence2: str) -&amp;gt; bool: words1, words2 = sentence1.split(), sentence2.split() m, n = len(words1), len(words2) if m &amp;lt; n: words1, words2 = words2, words1 m, n = n, m i = j = 0 while i &amp;lt; n and words1[i] == words2[i]: i += 1 while j &amp;lt; n and words1[m - 1 - j] == words2[n - 1 - j]: j += 1 return i + j &amp;gt;= n</description></item><item><title>1814. Count Nice Pairs in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1814/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1814/</guid><description>LeetCode problem 1814
class Solution: def countNicePairs(self, nums: List[int]) -&amp;gt; int: def rev(x): y = 0 while x: y = y * 10 + x % 10 x //= 10 return y res = 0 mod = 10**9 + 7 cnt = Counter() for x in nums: y = x - rev(x) res += cnt[y] cnt[y] += 1 return res % mod</description></item><item><title>1817. Finding the Users Active Minutes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1817/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1817/</guid><description>LeetCode problem 1817
class Solution: def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -&amp;gt; List[int]: d = defaultdict(set) for i, t in logs: d[i].add(t) res = [0] * k for ts in d.values(): res[len(ts) - 1] += 1 return res</description></item><item><title>1818. Minimum Absolute Sum Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1818/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1818/</guid><description>LeetCode problem 1818
class Solution: def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: mod = 10**9 + 7 nums = sorted(nums1) s = sum(abs(a - b) for a, b in zip(nums1, nums2)) % mod mx = 0 for a, b in zip(nums1, nums2): d1, d2 = abs(a - b), inf i = bisect_left(nums, b) if i &amp;lt; len(nums): d2 = min(d2, abs(nums[i] - b)) if i: d2 = min(d2, abs(nums[i - 1] - b)) mx = max(mx, d1 - d2) return (s - mx + mod) % mod</description></item><item><title>1820. Maximum Number of Accepted Invitations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1820/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1820/</guid><description>LeetCode problem 1820
class Solution: def maximumInvitations(self, grid: List[List[int]]) -&amp;gt; int: def find(i): for j, v in enumerate(grid[i]): if v and j not in vis: vis.add(j) if match[j] == -1 or find(match[j]): match[j] = i return True return False m, n = len(grid), len(grid[0]) match = [-1] * n res = 0 for i in range(m): vis = set() res += find(i) return res</description></item><item><title>1823. Find the Winner of the Circular Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1823/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1823/</guid><description>LeetCode problem 1823
class Solution: def findTheWinner(self, n: int, k: int) -&amp;gt; int: if n == 1: return 1 res = (k + self.findTheWinner(n - 1, k)) % n return n if res == 0 else res</description></item><item><title>1824. Minimum Sideway Jumps</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1824/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1824/</guid><description>LeetCode problem 1824
class Solution: def minSideJumps(self, obstacles: List[int]) -&amp;gt; int: f = [1, 0, 1] for v in obstacles[1:]: for j in range(3): if v == j + 1: f[j] = inf break x = min(f) + 1 for j in range(3): if v != j + 1: f[j] = min(f[j], x) return min(f)</description></item><item><title>1828. Queries on Number of Points Inside a Circle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1828/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1828/</guid><description>LeetCode problem 1828
class Solution: def countPoints( self, points: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: res = [] for x, y, r in queries: cnt = 0 for i, j in points: dx, dy = i - x, j - y cnt += dx * dx + dy * dy &amp;lt;= r * r res.append(cnt) return res</description></item><item><title>1829. Maximum XOR for Each Query</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1829/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1829/</guid><description>LeetCode problem 1829
class Solution: def getMaximumXor(self, nums: List[int], maximumBit: int) -&amp;gt; List[int]: res = [] xs = reduce(xor, nums) mask = (1 &amp;lt;&amp;lt; maximumBit) - 1 for x in nums[::-1]: k = xs ^ mask res.append(k) xs ^= x return res</description></item><item><title>1833. Maximum Ice Cream Bars</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1833/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1833/</guid><description>LeetCode problem 1833
class Solution: def maxIceCream(self, costs: List[int], coins: int) -&amp;gt; int: costs.sort() for i, c in enumerate(costs): if coins &amp;lt; c: return i coins -= c return len(costs)</description></item><item><title>1834. Single-Threaded CPU</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1834/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1834/</guid><description>LeetCode problem 1834
class Solution: def getOrder(self, tasks: List[List[int]]) -&amp;gt; List[int]: for i, task in enumerate(tasks): task.append(i) tasks.sort() res = [] q = [] n = len(tasks) i = t = 0 while q or i &amp;lt; n: if not q: t = max(t, tasks[i][0]) while i &amp;lt; n and tasks[i][0] &amp;lt;= t: heappush(q, (tasks[i][1], tasks[i][2])) i += 1 pt, j = heappop(q) res.append(j) t += pt return res</description></item><item><title>1836. Remove Duplicates From an Unsorted Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1836/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1836/</guid><description>LeetCode problem 1836
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteDuplicatesUnsorted(self, head: ListNode) -&amp;gt; ListNode: cnt = Counter() cur = head while cur: cnt[cur.val] += 1 cur = cur.next dummy = ListNode(0, head) pre, cur = dummy, head while cur: if cnt[cur.val] &amp;gt; 1: pre.next = cur.next else: pre = cur cur = cur.next return dummy.next</description></item><item><title>1838. Frequency of the Most Frequent Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1838/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1838/</guid><description>LeetCode problem 1838
class Solution: def maxFrequency(self, nums: List[int], k: int) -&amp;gt; int: def check(cnt): for i in range(n + 1 - cnt): j = i + cnt - 1 if nums[j] * cnt - (s[j + 1] - s[i]) &amp;lt;= k: return True return False nums.sort() s = list(accumulate(nums, initial=0)) n = len(nums) left, right = 1, n while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if check(mid): left = mid else: right = mid - 1 return left</description></item><item><title>1839. Longest Substring Of All Vowels in Order</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1839/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1839/</guid><description>LeetCode problem 1839
class Solution: def longestBeautifulSubstring(self, word: str) -&amp;gt; int: arr = [] n = len(word) i = 0 while i &amp;lt; n: j = i while j &amp;lt; n and word[j] == word[i]: j += 1 arr.append((word[i], j - i)) i = j res = 0 for i in range(len(arr) - 4): a, b, c, d, e = arr[i : i + 5] if a[0] + b[0] + c[0] + d[0] + e[0] == &amp;#34;aeiou&amp;#34;: res = max(res, a[1] + b[1] + c[1] + d[1] + e[1]) return res</description></item><item><title>1845. Seat Reservation Manager</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1845/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1845/</guid><description>LeetCode problem 1845
class SeatManager: def __init__(self, n: int): self.q = list(range(1, n + 1)) heapify(self.q) def reserve(self) -&amp;gt; int: return heappop(self.q) def unreserve(self, seatNumber: int) -&amp;gt; None: heappush(self.q, seatNumber) # Your SeatManager object will be instantiated and called as such: # obj = SeatManager(n) # param_1 = obj.reserve() # obj.unreserve(seatNumber)</description></item><item><title>1846. Maximum Element After Decreasing and Rearranging</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1846/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1846/</guid><description>LeetCode problem 1846
class Solution: def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -&amp;gt; int: arr.sort() arr[0] = 1 for i in range(1, len(arr)): d = max(0, arr[i] - arr[i - 1] - 1) arr[i] -= d return max(arr)</description></item><item><title>1849. Splitting a String Into Descending Consecutive Values</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1849/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1849/</guid><description>LeetCode problem 1849
class Solution: def splitString(self, s: str) -&amp;gt; bool: def dfs(i, x, k): if i == len(s): return k &amp;gt; 1 y = 0 for j in range(i, len(s)): y = y * 10 + int(s[j]) if (x == -1 or x - y == 1) and dfs(j + 1, y, k + 1): return True return False return dfs(0, -1, 0)</description></item><item><title>1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1850/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1850/</guid><description>LeetCode problem 1850
class Solution: def getMinSwaps(self, num: str, k: int) -&amp;gt; int: def next_permutation(nums: List[str]) -&amp;gt; bool: n = len(nums) i = n - 2 while i &amp;gt;= 0 and nums[i] &amp;gt;= nums[i + 1]: i -= 1 if i &amp;lt; 0: return False j = n - 1 while j &amp;gt;= 0 and nums[j] &amp;lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1 : n] = nums[i + 1 : n][::-1] return True s = list(num) for _ in range(k): next_permutation(s) d = [[] for _ in range(10)] idx = [0] * 10 n = len(s) for i, c in enumerate(num): j = ord(c) - ord(&amp;#34;0&amp;#34;) d[j].</description></item><item><title>1852. Distinct Numbers in Each Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1852/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1852/</guid><description>LeetCode problem 1852
class Solution: def distinctNumbers(self, nums: List[int], k: int) -&amp;gt; List[int]: cnt = Counter(nums[:k]) res = [len(cnt)] for i in range(k, len(nums)): cnt[nums[i]] += 1 cnt[nums[i - k]] -= 1 if cnt[nums[i - k]] == 0: cnt.pop(nums[i - k]) res.append(len(cnt)) return res</description></item><item><title>1855. Maximum Distance Between a Pair of Values</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1855/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1855/</guid><description>LeetCode problem 1855
class Solution: def maxDistance(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: m, n = len(nums1), len(nums2) res = i = j = 0 while i &amp;lt; m: while j &amp;lt; n and nums1[i] &amp;lt;= nums2[j]: j += 1 res = max(res, j - i - 1) i += 1 return res</description></item><item><title>1856. Maximum Subarray Min-Product</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1856/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1856/</guid><description>LeetCode problem 1856
class Solution: def maxSumMinProduct(self, nums: List[int]) -&amp;gt; int: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, x in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt; nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) s = list(accumulate(nums, initial=0)) mod = 10**9 + 7 return max((s[right[i]] - s[left[i] + 1]) * x for i, x in enumerate(nums)) % mod</description></item><item><title>1858. Longest Word With All Prefixes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1858/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1858/</guid><description>LeetCode problem 1858
class Trie: __slots__ = [&amp;#34;children&amp;#34;, &amp;#34;is_end&amp;#34;] def __init__(self): self.children: List[Trie | None] = [None] * 26 self.is_end: bool = False def insert(self, w: str) -&amp;gt; None: node = self for c in w: idx = ord(c) - ord(&amp;#34;a&amp;#34;) if not node.children[idx]: node.children[idx] = Trie() node = node.children[idx] node.is_end = True def search(self, w: str) -&amp;gt; bool: node = self for c in w: idx = ord(c) - ord(&amp;#34;a&amp;#34;) node = node.children[idx] if not node.is_end: return False return True class Solution: def longestWord(self, words: List[str]) -&amp;gt; str: trie = Trie() for w in words: trie.</description></item><item><title>1860. Incremental Memory Leak</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1860/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1860/</guid><description>LeetCode problem 1860
class Solution: def memLeak(self, memory1: int, memory2: int) -&amp;gt; List[int]: i = 1 while i &amp;lt;= max(memory1, memory2): if memory1 &amp;gt;= memory2: memory1 -= i else: memory2 -= i i += 1 return [i, memory1, memory2]</description></item><item><title>1861. Rotating the Box</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1861/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1861/</guid><description>LeetCode problem 1861
class Solution: def rotateTheBox(self, box: List[List[str]]) -&amp;gt; List[List[str]]: m, n = len(box), len(box[0]) res = [[None] * m for _ in range(n)] for i in range(m): for j in range(n): res[j][m - i - 1] = box[i][j] for j in range(m): q = deque() for i in range(n - 1, -1, -1): if res[i][j] == &amp;#39;*&amp;#39;: q.clear() elif res[i][j] == &amp;#39;.&amp;#39;: q.append(i) elif q: res[q.popleft()][j] = &amp;#39;#&amp;#39; res[i][j] = &amp;#39;.&amp;#39; q.append(i) return res</description></item><item><title>1864. Minimum Number of Swaps to Make the Binary String Alternating</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1864/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1864/</guid><description>LeetCode problem 1864
class Solution: def minSwaps(self, s: str) -&amp;gt; int: s0n0 = s0n1 = s1n0 = s1n1 = 0 for i in range(len(s)): if (i &amp;amp; 1) == 0: if s[i] != &amp;#39;0&amp;#39;: s0n0 += 1 else: s1n1 += 1 else: if s[i] != &amp;#39;0&amp;#39;: s1n0 += 1 else: s0n1 += 1 if s0n0 != s0n1 and s1n0 != s1n1: return -1 if s0n0 != s0n1: return s1n0 if s1n0 != s1n1: return s0n0 return min(s0n0, s1n0)</description></item><item><title>1865. Finding Pairs With a Certain Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1865/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1865/</guid><description>LeetCode problem 1865
class FindSumPairs: def __init__(self, nums1: List[int], nums2: List[int]): self.nums1 = nums1 self.nums2 = nums2 self.cnt = Counter(nums2) def add(self, index: int, val: int) -&amp;gt; None: old = self.nums2[index] self.cnt[old] -= 1 self.cnt[old + val] += 1 self.nums2[index] += val def count(self, tot: int) -&amp;gt; int: return sum(self.cnt[tot - v] for v in self.nums1) # Your FindSumPairs object will be instantiated and called as such: # obj = FindSumPairs(nums1, nums2) # obj.add(index,val) # param_2 = obj.count(tot)</description></item><item><title>1868. Product of Two Run-Length Encoded Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1868/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1868/</guid><description>LeetCode problem 1868
class Solution: def findRLEArray( self, encoded1: List[List[int]], encoded2: List[List[int]] ) -&amp;gt; List[List[int]]: res = [] j = 0 for vi, fi in encoded1: while fi: f = min(fi, encoded2[j][1]) v = vi * encoded2[j][0] if res and res[-1][0] == v: res[-1][1] += f else: res.append([v, f]) fi -= f encoded2[j][1] -= f if encoded2[j][1] == 0: j += 1 return res</description></item><item><title>1870. Minimum Speed to Arrive on Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1870/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1870/</guid><description>LeetCode problem 1870
class Solution: def minSpeedOnTime(self, dist: List[int], hour: float) -&amp;gt; int: def check(speed): res = 0 for i, d in enumerate(dist): res += (d / speed) if i == len(dist) - 1 else math.ceil(d / speed) return res &amp;lt;= hour r = 10**7 + 1 res = bisect_left(range(1, r), True, key=check) + 1 return -1 if res == r else res</description></item><item><title>1871. Jump Game VII</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1871/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1871/</guid><description>LeetCode problem 1871
class Solution: def canReach(self, s: str, minJump: int, maxJump: int) -&amp;gt; bool: n = len(s) pre = [0] * (n + 1) pre[1] = 1 f = [True] + [False] * (n - 1) for i in range(1, n): if s[i] == &amp;#34;0&amp;#34;: l, r = max(0, i - maxJump), i - minJump f[i] = l &amp;lt;= r and pre[r + 1] - pre[l] &amp;gt; 0 pre[i + 1] = pre[i] + f[i] return f[-1]</description></item><item><title>1874. Minimize Product Sum of Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1874/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1874/</guid><description>LeetCode problem 1874
class Solution: def minProductSum(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: nums1.sort() nums2.sort() n, res = len(nums1), 0 for i in range(n): res += nums1[i] * nums2[n - i - 1] return res</description></item><item><title>1877. Minimize Maximum Pair Sum in Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1877/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1877/</guid><description>LeetCode problem 1877
class Solution: def minPairSum(self, nums: List[int]) -&amp;gt; int: nums.sort() n = len(nums) return max(x + nums[n - i - 1] for i, x in enumerate(nums[: n &amp;gt;&amp;gt; 1]))</description></item><item><title>1878. Get Biggest Three Rhombus Sums in a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1878/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1878/</guid><description>LeetCode problem 1878
from sortedcontainers import SortedSet class Solution: def getBiggestThree(self, grid: List[List[int]]) -&amp;gt; List[int]: m, n = len(grid), len(grid[0]) s1 = [[0] * (n + 2) for _ in range(m + 1)] s2 = [[0] * (n + 2) for _ in range(m + 1)] for i, row in enumerate(grid, 1): for j, x in enumerate(row, 1): s1[i][j] = s1[i - 1][j - 1] + x s2[i][j] = s2[i - 1][j + 1] + x ss = SortedSet() for i, row in enumerate(grid, 1): for j, x in enumerate(row, 1): l = min(i - 1, m - i, j - 1, n - j) ss.</description></item><item><title>1881. Maximum Value after Insertion</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1881/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1881/</guid><description>LeetCode problem 1881
class Solution: def maxValue(self, n: str, x: int) -&amp;gt; str: if n[0] != &amp;#39;-&amp;#39;: for i, c in enumerate(n): if int(c) &amp;lt; x: return n[:i] + str(x) + n[i:] return n + str(x) else: for i, c in enumerate(n[1:]): if int(c) &amp;gt; x: return n[: i + 1] + str(x) + n[i + 1 :] return n + str(x)</description></item><item><title>1882. Process Tasks Using Servers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1882/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1882/</guid><description>LeetCode problem 1882
class Solution: def assignTasks(self, servers: List[int], tasks: List[int]) -&amp;gt; List[int]: idle, busy = [], [] for i, weight in enumerate(servers): heappush(idle, (weight, i)) res = [] for start, cost in enumerate(tasks): while busy and busy[0][0] &amp;lt;= start: _, s, i = heappop(busy) heappush(idle, (s, i)) if idle: s, i = heappop(idle) heappush(busy, (start + cost, s, i)) else: t, s, i = heappop(busy) heappush(busy, (t + cost, s, i)) res.append(i) return res</description></item><item><title>1885. Count Pairs in Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1885/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1885/</guid><description>LeetCode problem 1885
class Solution: def countPairs(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) d = [nums1[i] - nums2[i] for i in range(n)] d.sort() return sum(n - bisect_right(d, -v, lo=i + 1) for i, v in enumerate(d))</description></item><item><title>1887. Reduction Operations to Make the Array Elements Equal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1887/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1887/</guid><description>LeetCode Problem 1887
Problem Statement The goal of this problem is to make all elements in a given integer array nums equal, through a series of reduction operations. In each operation, we find the largest element in the array, find the next largest element that is strictly smaller than the largest, and reduce the largest element to this next largest value. The task is to return the number of such operations needed to make all array elements equal.</description></item><item><title>1888. Minimum Number of Flips to Make the Binary String Alternating</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1888/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1888/</guid><description>LeetCode problem 1888
class Solution: def minFlips(self, s: str) -&amp;gt; int: n = len(s) target = &amp;#34;01&amp;#34; cnt = sum(c != target[i &amp;amp; 1] for i, c in enumerate(s)) res = min(cnt, n - cnt) for i in range(n): cnt -= s[i] != target[i &amp;amp; 1] cnt += s[i] != target[(i + n) &amp;amp; 1] res = min(res, cnt, n - cnt) return res</description></item><item><title>1891. Cutting Ribbons</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1891/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1891/</guid><description>LeetCode problem 1891
class Solution: def maxLength(self, ribbons: List[int], k: int) -&amp;gt; int: left, right = 0, max(ribbons) while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 cnt = sum(x // mid for x in ribbons) if cnt &amp;gt;= k: left = mid else: right = mid - 1 return left</description></item><item><title>1894. Find the Student that Will Replace the Chalk</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1894/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1894/</guid><description>LeetCode problem 1894
class Solution: def chalkReplacer(self, chalk: List[int], k: int) -&amp;gt; int: s = sum(chalk) k %= s for i, x in enumerate(chalk): if k &amp;lt; x: return i k -= x</description></item><item><title>1895. Largest Magic Square</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1895/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1895/</guid><description>LeetCode problem 1895
class Solution: def largestMagicSquare(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) rowsum = [[0] * (n + 1) for _ in range(m + 1)] colsum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): rowsum[i][j] = rowsum[i][j - 1] + grid[i - 1][j - 1] colsum[i][j] = colsum[i - 1][j] + grid[i - 1][j - 1] def check(x1, y1, x2, y2): val = rowsum[x1 + 1][y2 + 1] - rowsum[x1 + 1][y1] for i in range(x1 + 1, x2 + 1): if rowsum[i + 1][y2 + 1] - rowsum[i + 1][y1] !</description></item><item><title>1898. Maximum Number of Removable Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1898/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1898/</guid><description>LeetCode problem 1898
class Solution: def maximumRemovals(self, s: str, p: str, removable: List[int]) -&amp;gt; int: def check(k): i = j = 0 ids = set(removable[:k]) while i &amp;lt; m and j &amp;lt; n: if i not in ids and s[i] == p[j]: j += 1 i += 1 return j == n m, n = len(s), len(p) left, right = 0, len(removable) while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if check(mid): left = mid else: right = mid - 1 return left</description></item><item><title>1899. Merge Triplets to Form Target Triplet</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1899/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1899/</guid><description>LeetCode problem 1899
class Solution: def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -&amp;gt; bool: x, y, z = target d = e = f = 0 for a, b, c in triplets: if a &amp;lt;= x and b &amp;lt;= y and c &amp;lt;= z: d = max(d, a) e = max(e, b) f = max(f, c) return [d, e, f] == target</description></item><item><title>1901. Find a Peak Element II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1901/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1901/</guid><description>LeetCode problem 1901
class Solution: def findPeakGrid(self, mat: List[List[int]]) -&amp;gt; List[int]: l, r = 0, len(mat) - 1 while l &amp;lt; r: mid = (l + r) &amp;gt;&amp;gt; 1 j = mat[mid].index(max(mat[mid])) if mat[mid][j] &amp;gt; mat[mid + 1][j]: r = mid else: l = mid + 1 return [l, mat[l].index(max(mat[l]))]</description></item><item><title>1902. Depth of BST Given Insertion Order</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1902/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1902/</guid><description>LeetCode problem 1902
from sortedcontainers import SortedDict class Solution: def maxDepthBST(self, order: List[int]) -&amp;gt; int: sd = SortedDict({0: 0, inf: 0, order[0]: 1}) res = 1 for v in order[1:]: lower = sd.bisect_left(v) - 1 higher = lower + 1 depth = 1 + max(sd.values()[lower], sd.values()[higher]) res = max(res, depth) sd[v] = depth return res</description></item><item><title>1904. The Number of Full Rounds You Have Played</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1904/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1904/</guid><description>LeetCode problem 1904
class Solution: def numberOfRounds(self, loginTime: str, logoutTime: str) -&amp;gt; int: def f(s: str) -&amp;gt; int: return int(s[:2]) * 60 + int(s[3:]) a, b = f(loginTime), f(logoutTime) if a &amp;gt; b: b += 1440 a, b = (a + 14) // 15, b // 15 return max(0, b - a)</description></item><item><title>1905. Count Sub Islands</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1905/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1905/</guid><description>LeetCode problem 1905
class Solution: def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -&amp;gt; int: def bfs(i: int, j: int) -&amp;gt; int: ok = grid1[i][j] q = deque([(i, j)]) grid2[i][j] = 0 while q: i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and grid2[x][y]: q.append((x, y)) ok = ok &amp;amp; grid1[x][y] grid2[x][y] = 0 return ok m, n = len(grid1), len(grid1[0]) dirs = (-1, 0, 1, 0, -1) return sum(bfs(i, j) for i in range(m) for j in range(n) if grid2[i][j])</description></item><item><title>1906. Minimum Absolute Difference Queries</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1906/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1906/</guid><description>LeetCode problem 1906
class Solution: def minDifference(self, nums: List[int], queries: List[List[int]]) -&amp;gt; List[int]: m, n = len(nums), len(queries) pre_sum = [[0] * 101 for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, 101): t = 1 if nums[i - 1] == j else 0 pre_sum[i][j] = pre_sum[i - 1][j] + t res = [] for i in range(n): left, right = queries[i][0], queries[i][1] + 1 t = inf last = -1 for j in range(1, 101): if pre_sum[right][j] - pre_sum[left][j] &amp;gt; 0: if last !</description></item><item><title>1908. Game of Nim</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1908/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1908/</guid><description>LeetCode problem 1908
class Solution: def nimGame(self, piles: List[int]) -&amp;gt; bool: @cache def dfs(st): lst = list(st) for i, x in enumerate(lst): for j in range(1, x + 1): lst[i] -= j if not dfs(tuple(lst)): return True lst[i] += j return False return dfs(tuple(piles))</description></item><item><title>1910. Remove All Occurrences of a Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1910/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1910/</guid><description>LeetCode problem 1910
class Solution: def removeOccurrences(self, s: str, part: str) -&amp;gt; str: while part in s: s = s.replace(part, &amp;#39;&amp;#39;, 1) return s</description></item><item><title>1911. Maximum Alternating Subsequence Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1911/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1911/</guid><description>LeetCode problem 1911
class Solution: def maxAlternatingSum(self, nums: List[int]) -&amp;gt; int: f = g = 0 for x in nums: f, g = max(g - x, f), max(f + x, g) return max(f, g)</description></item><item><title>1914. Cyclically Rotating a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1914/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1914/</guid><description>LeetCode problem 1914
class Solution: def rotateGrid(self, grid: List[List[int]], k: int) -&amp;gt; List[List[int]]: def rotate(p: int, k: int): nums = [] for j in range(p, n - p - 1): nums.append(grid[p][j]) for i in range(p, m - p - 1): nums.append(grid[i][n - p - 1]) for j in range(n - p - 1, p, -1): nums.append(grid[m - p - 1][j]) for i in range(m - p - 1, p, -1): nums.append(grid[i][p]) k %= len(nums) if k == 0: return nums = nums[k:] + nums[:k] k = 0 for j in range(p, n - p - 1): grid[p][j] = nums[k] k += 1 for i in range(p, m - p - 1): grid[i][n - p - 1] = nums[k] k += 1 for j in range(n - p - 1, p, -1): grid[m - p - 1][j] = nums[k] k += 1 for i in range(m - p - 1, p, -1): grid[i][p] = nums[k] k += 1 m, n = len(grid), len(grid[0]) for p in range(min(m, n) &amp;gt;&amp;gt; 1): rotate(p, k) return grid</description></item><item><title>1915. Number of Wonderful Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1915/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1915/</guid><description>LeetCode problem 1915
class Solution: def wonderfulSubstrings(self, word: str) -&amp;gt; int: cnt = Counter({0: 1}) res = st = 0 for c in word: st ^= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) res += cnt[st] for i in range(10): res += cnt[st ^ (1 &amp;lt;&amp;lt; i)] cnt[st] += 1 return res</description></item><item><title>1918. Kth Smallest Subarray Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1918/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1918/</guid><description>LeetCode problem 1918
class Solution: def kthSmallestSubarraySum(self, nums: List[int], k: int) -&amp;gt; int: def f(s): t = j = 0 cnt = 0 for i, x in enumerate(nums): t += x while t &amp;gt; s: t -= nums[j] j += 1 cnt += i - j + 1 return cnt &amp;gt;= k l, r = min(nums), sum(nums) return l + bisect_left(range(l, r + 1), True, key=f)</description></item><item><title>1921. Eliminate Maximum Number of Monsters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1921/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1921/</guid><description>LeetCode problem 1921
class Solution: def eliminateMaximum(self, dist: List[int], speed: List[int]) -&amp;gt; int: times = sorted((d - 1) // s for d, s in zip(dist, speed)) for i, t in enumerate(times): if t &amp;lt; i: return i return len(times)</description></item><item><title>1922. Count Good Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1922/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1922/</guid><description>LeetCode problem 1922
class Solution: def countGoodNumbers(self, n: int) -&amp;gt; int: mod = 10**9 + 7 def myPow(x, n): res = 1 while n: if (n &amp;amp; 1) == 1: res = res * x % mod x = x * x % mod n &amp;gt;&amp;gt;= 1 return res return myPow(5, (n + 1) &amp;gt;&amp;gt; 1) * myPow(4, n &amp;gt;&amp;gt; 1) % mod</description></item><item><title>1926. Nearest Exit from Entrance in Maze</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1926/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1926/</guid><description>LeetCode problem 1926
class Solution: def nearestExit(self, maze: List[List[str]], entrance: List[int]) -&amp;gt; int: m, n = len(maze), len(maze[0]) i, j = entrance q = deque([(i, j)]) maze[i][j] = &amp;#39;+&amp;#39; res = 0 while q: res += 1 for _ in range(len(q)): i, j = q.popleft() for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]: x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and maze[x][y] == &amp;#39;.</description></item><item><title>1927. Sum Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1927/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1927/</guid><description>LeetCode problem 1927
class Solution: def sumGame(self, num: str) -&amp;gt; bool: n = len(num) cnt1 = num[: n // 2].count(&amp;#34;?&amp;#34;) cnt2 = num[n // 2 :].count(&amp;#34;?&amp;#34;) s1 = sum(int(x) for x in num[: n // 2] if x != &amp;#34;?&amp;#34;) s2 = sum(int(x) for x in num[n // 2 :] if x != &amp;#34;?&amp;#34;) return (cnt1 + cnt2) % 2 == 1 or s1 - s2 != 9 * (cnt2 - cnt1) // 2</description></item><item><title>1936. Add Minimum Number of Rungs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1936/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1936/</guid><description>LeetCode problem 1936
class Solution: def addRungs(self, rungs: List[int], dist: int) -&amp;gt; int: rungs = [0] + rungs return sum((b - a - 1) // dist for a, b in pairwise(rungs))</description></item><item><title>1937. Maximum Number of Points with Cost</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1937/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1937/</guid><description>LeetCode problem 1937
class Solution: def maxPoints(self, points: List[List[int]]) -&amp;gt; int: n = len(points[0]) f = points[0][:] for p in points[1:]: g = [0] * n lmx = -inf for j in range(n): lmx = max(lmx, f[j] + j) g[j] = max(g[j], p[j] + lmx - j) rmx = -inf for j in range(n - 1, -1, -1): rmx = max(rmx, f[j] - j) g[j] = max(g[j], p[j] + rmx + j) f = g return max(f)</description></item><item><title>1940. Longest Common Subsequence Between Sorted Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1940/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1940/</guid><description>LeetCode problem 1940
class Solution: def longestCommomSubsequence(self, arrays: List[List[int]]) -&amp;gt; List[int]: def common(l1, l2): i, j, n1, n2 = 0, 0, len(l1), len(l2) res = [] while i &amp;lt; n1 and j &amp;lt; n2: if l1[i] == l2[j]: res.append(l1[i]) i += 1 j += 1 elif l1[i] &amp;gt; l2[j]: j += 1 else: i += 1 return res n = len(arrays) for i in range(1, n): arrays[i] = common(arrays[i - 1], arrays[i]) return arrays[n - 1]</description></item><item><title>1942. The Number of the Smallest Unoccupied Chair</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1942/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1942/</guid><description>LeetCode problem 1942
class Solution: def smallestChair(self, times: List[List[int]], targetFriend: int) -&amp;gt; int: n = len(times) h = list(range(n)) heapify(h) for i in range(n): times[i].append(i) times.sort() busy = [] for a, b, i in times: while busy and busy[0][0] &amp;lt;= a: heappush(h, heappop(busy)[1]) c = heappop(h) if i == targetFriend: return c heappush(busy, (b, c)) return -1</description></item><item><title>1943. Describe the Painting</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1943/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1943/</guid><description>LeetCode problem 1943
class Solution: def splitPainting(self, segments: List[List[int]]) -&amp;gt; List[List[int]]: d = defaultdict(int) for l, r, c in segments: d[l] += c d[r] -= c s = sorted([[k, v] for k, v in d.items()]) n = len(s) for i in range(1, n): s[i][1] += s[i - 1][1] return [[s[i][0], s[i + 1][0], s[i][1]] for i in range(n - 1) if s[i][1]]</description></item><item><title>1946. Largest Number After Mutating Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1946/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1946/</guid><description>LeetCode problem 1946
class Solution: def maximumNumber(self, num: str, change: List[int]) -&amp;gt; str: s = list(num) for i, c in enumerate(s): if change[int(c)] &amp;gt; int(c): while i &amp;lt; len(s) and int(s[i]) &amp;lt;= change[int(s[i])]: s[i] = str(change[int(s[i])]) i += 1 break return &amp;#39;&amp;#39;.join(s)</description></item><item><title>1947. Maximum Compatibility Score Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1947/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1947/</guid><description>LeetCode problem 1947
class Solution: def maxCompatibilitySum( self, students: List[List[int]], mentors: List[List[int]] ) -&amp;gt; int: def dfs(i, t): if i == m: nonlocal res res = max(res, t) return for j in range(m): if not vis[j]: vis[j] = True dfs(i + 1, t + g[i][j]) vis[j] = False m = len(students) g = [[0] * m for _ in range(m)] for i in range(m): for j in range(m): g[i][j] = sum(a == b for a, b in zip(students[i], mentors[j])) vis = [False] * m res = 0 dfs(0, 0) return res</description></item><item><title>1950. Maximum of Minimum Values in All Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1950/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1950/</guid><description>LeetCode problem 1950
class Solution: def findMaximums(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, x in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt;= nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) res = [0] * n for i in range(n): m = right[i] - left[i] - 1 res[m - 1] = max(res[m - 1], nums[i]) for i in range(n - 2, -1, -1): res[i] = max(res[i], res[i + 1]) return res</description></item><item><title>1953. Maximum Number of Weeks for Which You Can Work</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1953/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1953/</guid><description>LeetCode problem 1953
class Solution: def numberOfWeeks(self, milestones: List[int]) -&amp;gt; int: mx, s = max(milestones), sum(milestones) rest = s - mx return rest * 2 + 1 if mx &amp;gt; rest + 1 else s</description></item><item><title>1954. Minimum Garden Perimeter to Collect Enough Apples</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1954/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1954/</guid><description>LeetCode problem 1954
class Solution: def minimumPerimeter(self, neededApples: int) -&amp;gt; int: l, r = 1, 100000 while l &amp;lt; r: mid = (l + r) &amp;gt;&amp;gt; 1 if 2 * mid * (mid + 1) * (2 * mid + 1) &amp;gt;= neededApples: r = mid else: l = mid + 1 return l * 8</description></item><item><title>1958. Check if Move is Legal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1958/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1958/</guid><description>LeetCode problem 1958
class Solution: def checkMove( self, board: List[List[str]], rMove: int, cMove: int, color: str ) -&amp;gt; bool: dirs = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)] n = 8 for a, b in dirs: i, j = rMove, cMove t = 0 while 0 &amp;lt;= i + a &amp;lt; n and 0 &amp;lt;= j + b &amp;lt; n: t += 1 i, j = i + a, j + b if board[i][j] in [&amp;#39;.</description></item><item><title>1959. Minimum Total Space Wasted With K Resizing Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1959/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1959/</guid><description>LeetCode problem 1959
class Solution: def minSpaceWastedKResizing(self, nums: List[int], k: int) -&amp;gt; int: k += 1 n = len(nums) g = [[0] * n for _ in range(n)] for i in range(n): s = mx = 0 for j in range(i, n): s += nums[j] mx = max(mx, nums[j]) g[i][j] = mx * (j - i + 1) - s f = [[inf] * (k + 1) for _ in range(n + 1)] f[0][0] = 0 for i in range(1, n + 1): for j in range(1, k + 1): for h in range(i): f[i][j] = min(f[i][j], f[h][j - 1] + g[h][i - 1]) return f[-1][-1]</description></item><item><title>1962. Remove Stones to Minimize the Total</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1962/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1962/</guid><description>LeetCode problem 1962
class Solution: def minStoneSum(self, piles: List[int], k: int) -&amp;gt; int: pq = [-x for x in piles] heapify(pq) for _ in range(k): heapreplace(pq, pq[0] // 2) return -sum(pq)</description></item><item><title>1963. Minimum Number of Swaps to Make the String Balanced</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1963/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1963/</guid><description>LeetCode problem 1963
class Solution: def minSwaps(self, s: str) -&amp;gt; int: x = 0 for c in s: if c == &amp;#34;[&amp;#34;: x += 1 elif x: x -= 1 return (x + 1) &amp;gt;&amp;gt; 1</description></item><item><title>1966. Binary Searchable Numbers in an Unsorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1966/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1966/</guid><description>LeetCode problem 1966
class Solution: def binarySearchableNumbers(self, nums: List[int]) -&amp;gt; int: n = len(nums) ok = [1] * n mx, mi = -1000000, 1000000 for i, x in enumerate(nums): if x &amp;lt; mx: ok[i] = 0 else: mx = x for i in range(n - 1, -1, -1): if nums[i] &amp;gt; mi: ok[i] = 0 else: mi = nums[i] return sum(ok)</description></item><item><title>1968. Array With Elements Not Equal to Average of Neighbors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1968/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1968/</guid><description>LeetCode problem 1968
class Solution: def rearrangeArray(self, nums: List[int]) -&amp;gt; List[int]: nums.sort() n = len(nums) m = (n + 1) &amp;gt;&amp;gt; 1 res = [] for i in range(m): res.append(nums[i]) if i + m &amp;lt; n: res.append(nums[i + m]) return res</description></item><item><title>1969. Minimum Non-Zero Product of the Array Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1969/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1969/</guid><description>LeetCode problem 1969
class Solution: def minNonZeroProduct(self, p: int) -&amp;gt; int: mod = 10**9 + 7 return (2**p - 1) * pow(2**p - 2, 2 ** (p - 1) - 1, mod) % mod</description></item><item><title>1973. Count Nodes Equal to Sum of Descendants</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1973/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1973/</guid><description>LeetCode problem 1973
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def equalToDescendants(self, root: Optional[TreeNode]) -&amp;gt; int: def dfs(root): if root is None: return 0 l, r = dfs(root.left), dfs(root.right) if l + r == root.val: nonlocal res res += 1 return root.val + l + r res = 0 dfs(root) return res</description></item><item><title>1975. Maximum Matrix Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1975/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1975/</guid><description>LeetCode problem 1975
class Solution: def maxMatrixSum(self, matrix: List[List[int]]) -&amp;gt; int: s = cnt = 0 mi = inf for row in matrix: for v in row: s += abs(v) mi = min(mi, abs(v)) if v &amp;lt; 0: cnt += 1 if cnt % 2 == 0 or mi == 0: return s return s - mi * 2</description></item><item><title>1976. Number of Ways to Arrive at Destination</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1976/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1976/</guid><description>LeetCode problem 1976
class Solution: def countPaths(self, n: int, roads: List[List[int]]) -&amp;gt; int: INF = inf MOD = 10**9 + 7 g = [[INF] * n for _ in range(n)] for u, v, t in roads: g[u][v] = t g[v][u] = t g[0][0] = 0 dist = [INF] * n w = [0] * n dist[0] = 0 w[0] = 1 vis = [False] * n for _ in range(n): t = -1 for i in range(n): if not vis[i] and (t == -1 or dist[i] &amp;lt; dist[t]): t = i vis[t] = True for i in range(n): if i == t: continue ne = dist[t] + g[t][i] if dist[i] &amp;gt; ne: dist[i] = ne w[i] = w[t] elif dist[i] == ne: w[i] += w[t] return w[-1] % MOD</description></item><item><title>1980. Find Unique Binary String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1980/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1980/</guid><description>LeetCode problem 1980
class Solution: def findDifferentBinaryString(self, nums: List[str]) -&amp;gt; str: mask = 0 for x in nums: mask |= 1 &amp;lt;&amp;lt; x.count(&amp;#34;1&amp;#34;) n = len(nums) for i in range(n + 1): if mask &amp;gt;&amp;gt; i &amp;amp; 1 ^ 1: return &amp;#34;1&amp;#34; * i + &amp;#34;0&amp;#34; * (n - i)</description></item><item><title>1981. Minimize the Difference Between Target and Chosen Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1981/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1981/</guid><description>LeetCode problem 1981
class Solution: def minimizeTheDifference(self, mat: List[List[int]], target: int) -&amp;gt; int: f = {0} for row in mat: f = set(a + b for a in f for b in row) return min(abs(v - target) for v in f)</description></item><item><title>1983. Widest Pair of Indices With Equal Range Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1983/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1983/</guid><description>LeetCode problem 1983
class Solution: def widestPairOfIndices(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: d = {0: -1} res = s = 0 for i, (a, b) in enumerate(zip(nums1, nums2)): s += a - b if s in d: res = max(res, i - d[s]) else: d[s] = i return res</description></item><item><title>1985. Find the Kth Largest Integer in the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1985/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1985/</guid><description>LeetCode problem 1985
class Solution: def kthLargestNumber(self, nums: List[str], k: int) -&amp;gt; str: def cmp(a, b): if len(a) != len(b): return len(b) - len(a) return 1 if b &amp;gt; a else -1 nums.sort(key=cmp_to_key(cmp)) return nums[k - 1]</description></item><item><title>1986. Minimum Number of Work Sessions to Finish the Tasks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1986/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1986/</guid><description>LeetCode problem 1986
class Solution: def minSessions(self, tasks: List[int], sessionTime: int) -&amp;gt; int: n = len(tasks) ok = [False] * (1 &amp;lt;&amp;lt; n) for i in range(1, 1 &amp;lt;&amp;lt; n): t = sum(tasks[j] for j in range(n) if i &amp;gt;&amp;gt; j &amp;amp; 1) ok[i] = t &amp;lt;= sessionTime f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): j = i while j: if ok[j]: f[i] = min(f[i], f[i ^ j] + 1) j = (j - 1) &amp;amp; i return f[-1]</description></item><item><title>1989. Maximum Number of People That Can Be Caught in Tag</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1989/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1989/</guid><description>LeetCode problem 1989
class Solution: def catchMaximumAmountofPeople(self, team: List[int], dist: int) -&amp;gt; int: res = j = 0 n = len(team) for i, x in enumerate(team): if x: while j &amp;lt; n and (team[j] or i - j &amp;gt; dist): j += 1 if j &amp;lt; n and abs(i - j) &amp;lt;= dist: res += 1 j += 1 return res</description></item><item><title>1992. Find All Groups of Farmland</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1992/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1992/</guid><description>LeetCode problem 1992
class Solution: def findFarmland(self, land: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(land), len(land[0]) res = [] for i in range(m): for j in range(n): if ( land[i][j] == 0 or (j &amp;gt; 0 and land[i][j - 1] == 1) or (i &amp;gt; 0 and land[i - 1][j] == 1) ): continue x, y = i, j while x + 1 &amp;lt; m and land[x + 1][j] == 1: x += 1 while y + 1 &amp;lt; n and land[x][y + 1] == 1: y += 1 res.</description></item><item><title>1993. Operations on Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1993/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1993/</guid><description>LeetCode problem 1993
class LockingTree: def __init__(self, parent: List[int]): n = len(parent) self.locked = [-1] * n self.parent = parent self.children = [[] for _ in range(n)] for son, fa in enumerate(parent[1:], 1): self.children[fa].append(son) def lock(self, num: int, user: int) -&amp;gt; bool: if self.locked[num] == -1: self.locked[num] = user return True return False def unlock(self, num: int, user: int) -&amp;gt; bool: if self.locked[num] == user: self.locked[num] = -1 return True return False def upgrade(self, num: int, user: int) -&amp;gt; bool: def dfs(x: int): nonlocal find for y in self.</description></item><item><title>1996. The Number of Weak Characters in the Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1996/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1996/</guid><description>LeetCode problem 1996
class Solution: def numberOfWeakCharacters(self, properties: List[List[int]]) -&amp;gt; int: properties.sort(key=lambda x: (-x[0], x[1])) res = mx = 0 for _, x in properties: res += x &amp;lt; mx mx = max(mx, x) return res</description></item><item><title>1997. First Day Where You Have Been in All the Rooms</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1997/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1997/</guid><description>LeetCode problem 1997
class Solution: def firstDayBeenInAllRooms(self, nextVisit: List[int]) -&amp;gt; int: n = len(nextVisit) f = [0] * n mod = 10**9 + 7 for i in range(1, n): f[i] = (f[i - 1] + 1 + f[i - 1] - f[nextVisit[i - 1]] + 1) % mod return f[-1]</description></item><item><title>1999. Smallest Greater Multiple Made of Two Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1999/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/1999/</guid><description>LeetCode problem 1999
class Solution: def findInteger(self, k: int, digit1: int, digit2: int) -&amp;gt; int: if digit1 == 0 and digit2 == 0: return -1 if digit1 &amp;gt; digit2: return self.findInteger(k, digit2, digit1) q = deque([0]) while 1: x = q.popleft() if x &amp;gt; 2**31 - 1: return -1 if x &amp;gt; k and x % k == 0: return x q.append(x * 10 + digit1) if digit1 != digit2: q.append(x * 10 + digit2)</description></item><item><title>2001. Number of Pairs of Interchangeable Rectangles</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2001/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2001/</guid><description>LeetCode problem 2001
class Solution: def interchangeableRectangles(self, rectangles: List[List[int]]) -&amp;gt; int: res = 0 cnt = Counter() for w, h in rectangles: g = gcd(w, h) w, h = w // g, h // g res += cnt[(w, h)] cnt[(w, h)] += 1 return res</description></item><item><title>2002. Maximum Product of the Length of Two Palindromic Subsequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2002/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2002/</guid><description>LeetCode problem 2002
class Solution: def maxProduct(self, s: str) -&amp;gt; int: n = len(s) p = [True] * (1 &amp;lt;&amp;lt; n) for k in range(1, 1 &amp;lt;&amp;lt; n): i, j = 0, n - 1 while i &amp;lt; j: while i &amp;lt; j and (k &amp;gt;&amp;gt; i &amp;amp; 1) == 0: i += 1 while i &amp;lt; j and (k &amp;gt;&amp;gt; j &amp;amp; 1) == 0: j -= 1 if i &amp;lt; j and s[i] != s[j]: p[k] = False break i, j = i + 1, j - 1 res = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): if p[i]: mx = ((1 &amp;lt;&amp;lt; n) - 1) ^ i j = mx a = i.</description></item><item><title>2007. Find Original Array From Doubled Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2007/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2007/</guid><description>LeetCode problem 2007
class Solution: def findOriginalArray(self, changed: List[int]) -&amp;gt; List[int]: n = len(changed) if n &amp;amp; 1: return [] cnt = Counter(changed) changed.sort() res = [] for x in changed: if cnt[x] == 0: continue if cnt[x * 2] &amp;lt;= 0: return [] res.append(x) cnt[x] -= 1 cnt[x * 2] -= 1 return res if len(res) == n // 2 else []</description></item><item><title>2008. Maximum Earnings From Taxi</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2008/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2008/</guid><description>LeetCode problem 2008
class Solution: def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&amp;gt; int: rides.sort(key=lambda x: x[1]) f = [0] * (len(rides) + 1) for i, (st, ed, tip) in enumerate(rides, 1): j = bisect_left(rides, st + 1, hi=i, key=lambda x: x[1]) f[i] = max(f[i - 1], f[j] + ed - st + tip) return f[-1]</description></item><item><title>2012. Sum of Beauty in the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2012/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2012/</guid><description>LeetCode problem 2012
class Solution: def sumOfBeauties(self, nums: List[int]) -&amp;gt; int: n = len(nums) right = [nums[-1]] * n for i in range(n - 2, -1, -1): right[i] = min(right[i + 1], nums[i]) res = 0 l = nums[0] for i in range(1, n - 1): r = right[i + 1] if l &amp;lt; nums[i] &amp;lt; r: res += 2 elif nums[i - 1] &amp;lt; nums[i] &amp;lt; nums[i + 1]: res += 1 l = max(l, nums[i]) return res</description></item><item><title>2013. Detect Squares</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2013/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2013/</guid><description>LeetCode problem 2013
class DetectSquares: def __init__(self): self.cnt = defaultdict(Counter) def add(self, point: List[int]) -&amp;gt; None: x, y = point self.cnt[x][y] += 1 def count(self, point: List[int]) -&amp;gt; int: x1, y1 = point if x1 not in self.cnt: return 0 res = 0 for x2 in self.cnt.keys(): if x2 != x1: d = x2 - x1 res += self.cnt[x2][y1] * self.cnt[x1][y1 + d] * self.cnt[x2][y1 + d] res += self.cnt[x2][y1] * self.cnt[x1][y1 - d] * self.cnt[x2][y1 - d] return res # Your DetectSquares object will be instantiated and called as such: # obj = DetectSquares() # obj.</description></item><item><title>2015. Average Height of Buildings in Each Segment</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2015/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2015/</guid><description>LeetCode problem 2015
class Solution: def averageHeightOfBuildings(self, buildings: List[List[int]]) -&amp;gt; List[List[int]]: height = defaultdict(int) cnt = defaultdict(int) for s, e, h in buildings: cnt[s] += 1 cnt[e] -= 1 height[s] += h height[e] -= h res = [] i = h = n = 0 for j in sorted(cnt.keys()): if n: t = [i, j, h // n] if res and res[-1][1] == i and res[-1][2] == t[-1]: res[-1][1] = j else: res.append(t) i = j h += height[j] n += cnt[j] return res</description></item><item><title>2017. Grid Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2017/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2017/</guid><description>LeetCode problem 2017
class Solution: def gridGame(self, grid: List[List[int]]) -&amp;gt; int: res = inf s1, s2 = sum(grid[0]), 0 for j, v in enumerate(grid[0]): s1 -= v res = min(res, max(s1, s2)) s2 += grid[1][j] return res</description></item><item><title>2018. Check if Word Can Be Placed In Crossword</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2018/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2018/</guid><description>LeetCode problem 2018
class Solution: def placeWordInCrossword(self, board: List[List[str]], word: str) -&amp;gt; bool: def check(i, j, a, b): x, y = i + a * k, j + b * k if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and board[x][y] != &amp;#39;#&amp;#39;: return False for c in word: if ( i &amp;lt; 0 or i &amp;gt;= m or j &amp;lt; 0 or j &amp;gt;= n or (board[i][j] != &amp;#39; &amp;#39; and board[i][j] != c) ): return False i, j = i + a, j + b return True m, n = len(board), len(board[0]) k = len(word) for i in range(m): for j in range(n): left_to_right = (j == 0 or board[i][j - 1] == &amp;#39;#&amp;#39;) and check(i, j, 0, 1) right_to_left = (j == n - 1 or board[i][j + 1] == &amp;#39;#&amp;#39;) and check( i, j, 0, -1 ) up_to_down = (i == 0 or board[i - 1][j] == &amp;#39;#&amp;#39;) and check(i, j, 1, 0) down_to_up = (i == m - 1 or board[i + 1][j] == &amp;#39;#&amp;#39;) and check( i, j, -1, 0 ) if left_to_right or right_to_left or up_to_down or down_to_up: return True return False</description></item><item><title>2021. Brightest Position on Street</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2021/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2021/</guid><description>LeetCode problem 2021
class Solution: def brightestPosition(self, lights: List[List[int]]) -&amp;gt; int: d = defaultdict(int) for i, j in lights: l, r = i - j, i + j d[l] += 1 d[r + 1] -= 1 res = s = mx = 0 for k in sorted(d): s += d[k] if mx &amp;lt; s: mx = s res = k return res</description></item><item><title>2023. Number of Pairs of Strings With Concatenation Equal to Target</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2023/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2023/</guid><description>LeetCode problem 2023
class Solution: def numOfPairs(self, nums: List[str], target: str) -&amp;gt; int: cnt = Counter(nums) res = 0 for i in range(1, len(target)): a, b = target[:i], target[i:] if a != b: res += cnt[a] * cnt[b] else: res += cnt[a] * (cnt[a] - 1) return res</description></item><item><title>2024. Maximize the Confusion of an Exam</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2024/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2024/</guid><description>LeetCode problem 2024
class Solution: def maxConsecutiveAnswers(self, answerKey: str, k: int) -&amp;gt; int: def get(c, k): l = r = -1 while r &amp;lt; len(answerKey) - 1: r += 1 if answerKey[r] == c: k -= 1 if k &amp;lt; 0: l += 1 if answerKey[l] == c: k += 1 return r - l return max(get(&amp;#39;T&amp;#39;, k), get(&amp;#39;F&amp;#39;, k))</description></item><item><title>2028. Find Missing Observations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2028/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2028/</guid><description>LeetCode problem 2028
class Solution: def missingRolls(self, rolls: List[int], mean: int, n: int) -&amp;gt; List[int]: m = len(rolls) s = (n + m) * mean - sum(rolls) if s &amp;gt; n * 6 or s &amp;lt; n: return [] res = [s // n] * n for i in range(s % n): res[i] += 1 return res</description></item><item><title>2029. Stone Game IX</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2029/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2029/</guid><description>LeetCode problem 2029
class Solution: def stoneGameIX(self, stones: List[int]) -&amp;gt; bool: def check(c): if c[1] == 0: return False c[1] -= 1 turn = 1 + min(c[1], c[2]) * 2 + c[0] if c[1] &amp;gt; c[2]: turn += 1 c[1] -= 1 return turn % 2 == 1 and c[1] != c[2] c = [0] * 3 for s in stones: c[s % 3] += 1 c1 = [c[0], c[2], c[1]] return check(c) or check(c1)</description></item><item><title>2031. Count Subarrays With More Ones Than Zeros</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2031/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2031/</guid><description>LeetCode problem 2031
from sortedcontainers import SortedList class Solution: def subarraysWithMoreZerosThanOnes(self, nums: List[int]) -&amp;gt; int: sl = SortedList([0]) mod = 10**9 + 7 res = s = 0 for x in nums: s += x or -1 res += sl.bisect_left(s) res %= mod sl.add(s) return res</description></item><item><title>2033. Minimum Operations to Make a Uni-Value Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2033/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2033/</guid><description>LeetCode problem 2033
class Solution: def minOperations(self, grid: List[List[int]], x: int) -&amp;gt; int: nums = [] mod = grid[0][0] % x for row in grid: for v in row: if v % x != mod: return -1 nums.append(v) nums.sort() mid = nums[len(nums) &amp;gt;&amp;gt; 1] return sum(abs(v - mid) // x for v in nums)</description></item><item><title>2034. Stock Price Fluctuation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2034/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2034/</guid><description>LeetCode problem 2034
from sortedcontainers import SortedList class StockPrice: def __init__(self): self.d = {} self.ls = SortedList() self.last = 0 def update(self, timestamp: int, price: int) -&amp;gt; None: if timestamp in self.d: self.ls.remove(self.d[timestamp]) self.d[timestamp] = price self.ls.add(price) self.last = max(self.last, timestamp) def current(self) -&amp;gt; int: return self.d[self.last] def maximum(self) -&amp;gt; int: return self.ls[-1] def minimum(self) -&amp;gt; int: return self.ls[0] # Your StockPrice object will be instantiated and called as such: # obj = StockPrice() # obj.update(timestamp,price) # param_2 = obj.</description></item><item><title>2036. Maximum Alternating Subarray Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2036/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2036/</guid><description>LeetCode problem 2036
class Solution: def maximumAlternatingSubarraySum(self, nums: List[int]) -&amp;gt; int: res = f = g = -inf for x in nums: f, g = max(g, 0) + x, f - x res = max(res, f, g) return res</description></item><item><title>2038. Remove Colored Pieces if Both Neighbors are the Same Color</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2038/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2038/</guid><description>LeetCode problem 2038
class Solution: def winnerOfGame(self, colors: str) -&amp;gt; bool: a = b = 0 for c, v in groupby(colors): m = len(list(v)) - 2 if m &amp;gt; 0 and c == &amp;#39;A&amp;#39;: a += m elif m &amp;gt; 0 and c == &amp;#39;B&amp;#39;: b += m return a &amp;gt; b</description></item><item><title>2039. The Time When the Network Becomes Idle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2039/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2039/</guid><description>LeetCode problem 2039
class Solution: def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -&amp;gt; int: g = defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) q = deque([0]) vis = {0} res = d = 0 while q: d += 1 t = d * 2 for _ in range(len(q)): u = q.popleft() for v in g[u]: if v not in vis: vis.add(v) q.append(v) res = max(res, (t - 1) // patience[v] * patience[v] + t + 1) return res</description></item><item><title>2043. Simple Bank System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2043/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2043/</guid><description>LeetCode problem 2043
class Bank: def __init__(self, balance: List[int]): self.balance = balance self.n = len(balance) def transfer(self, account1: int, account2: int, money: int) -&amp;gt; bool: if account1 &amp;gt; self.n or account2 &amp;gt; self.n or self.balance[account1 - 1] &amp;lt; money: return False self.balance[account1 - 1] -= money self.balance[account2 - 1] += money return True def deposit(self, account: int, money: int) -&amp;gt; bool: if account &amp;gt; self.n: return False self.balance[account - 1] += money return True def withdraw(self, account: int, money: int) -&amp;gt; bool: if account &amp;gt; self.</description></item><item><title>2044. Count Number of Maximum Bitwise-OR Subsets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2044/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2044/</guid><description>LeetCode problem 2044
class Solution: def countMaxOrSubsets(self, nums: List[int]) -&amp;gt; int: n = len(nums) res = 0 mx = 0 for mask in range(1 &amp;lt;&amp;lt; n): t = 0 for i, v in enumerate(nums): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: t |= v if mx &amp;lt; t: mx = t res = 1 elif mx == t: res += 1 return res</description></item><item><title>2046. Sort Linked List Already Sorted Using Absolute Values</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2046/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2046/</guid><description>LeetCode problem 2046
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortLinkedList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, curr = head, head.next while curr: if curr.val &amp;lt; 0: t = curr.next prev.next = t curr.next = head head = curr curr = t else: prev, curr = curr, curr.next return head</description></item><item><title>2048. Next Greater Numerically Balanced Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2048/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2048/</guid><description>LeetCode problem 2048
class Solution: def nextBeautifulNumber(self, n: int) -&amp;gt; int: for x in count(n + 1): y = x cnt = [0] * 10 while y: y, v = divmod(y, 10) cnt[v] += 1 if all(v == 0 or i == v for i, v in enumerate(cnt)): return x</description></item><item><title>2049. Count Nodes With the Highest Score</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2049/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2049/</guid><description>LeetCode problem 2049
class Solution: def countHighestScoreNodes(self, parents: List[int]) -&amp;gt; int: def dfs(i: int, fa: int): cnt = score = 1 for j in g[i]: if j != fa: t = dfs(j, i) score *= t cnt += t if n - cnt: score *= n - cnt nonlocal res, mx if mx &amp;lt; score: mx = score res = 1 elif mx == score: res += 1 return cnt n = len(parents) g = [[] for _ in range(n)] for i in range(1, n): g[parents[i]].</description></item><item><title>2052. Minimum Cost to Separate Sentence Into Rows</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2052/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2052/</guid><description>LeetCode problem 2052
class Solution: def minimumCost(self, sentence: str, k: int) -&amp;gt; int: @cache def dfs(i): if s[-1] - s[i] + n - i - 1 &amp;lt;= k: return 0 res, j = inf, i + 1 while j &amp;lt; n and (t := s[j] - s[i] + j - i - 1) &amp;lt;= k: res = min(res, (k - t) ** 2 + dfs(j)) j += 1 return res t = [len(w) for w in sentence.split()] n = len(t) s = list(accumulate(t, initial=0)) return dfs(0)</description></item><item><title>2054. Two Best Non-Overlapping Events</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2054/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2054/</guid><description>LeetCode problem 2054
class Solution: def maxTwoEvents(self, events: List[List[int]]) -&amp;gt; int: events.sort() n = len(events) f = [events[-1][2]] * n for i in range(n - 2, -1, -1): f[i] = max(f[i + 1], events[i][2]) res = 0 for _, e, v in events: idx = bisect_right(events, e, key=lambda x: x[0]) if idx &amp;lt; n: v += f[idx] res = max(res, v) return res</description></item><item><title>2055. Plates Between Candles</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2055/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2055/</guid><description>LeetCode problem 2055
class Solution: def platesBetweenCandles(self, s: str, queries: List[List[int]]) -&amp;gt; List[int]: n = len(s) presum = [0] * (n + 1) for i, c in enumerate(s): presum[i + 1] = presum[i] + (c == &amp;#39;*&amp;#39;) left, right = [0] * n, [0] * n l = r = -1 for i, c in enumerate(s): if c == &amp;#39;|&amp;#39;: l = i left[i] = l for i in range(n - 1, -1, -1): if s[i] == &amp;#39;|&amp;#39;: r = i right[i] = r res = [0] * len(queries) for k, (l, r) in enumerate(queries): i, j = right[l], left[r] if i &amp;gt;= 0 and j &amp;gt;= 0 and i &amp;lt; j: res[k] = presum[j] - presum[i + 1] return res</description></item><item><title>2058. Find the Minimum and Maximum Number of Nodes Between Critical Points</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2058/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2058/</guid><description>LeetCode problem 2058
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -&amp;gt; List[int]: prev, curr = head, head.next first = last = None i = 1 res = [inf, -inf] while curr.next: if curr.val &amp;lt; min(prev.val, curr.next.val) or curr.val &amp;gt; max( prev.val, curr.next.val ): if last is None: first = last = i else: res[0] = min(res[0], i - last) res[1] = i - first last = i i += 1 prev, curr = curr, curr.</description></item><item><title>2059. Minimum Operations to Convert Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2059/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2059/</guid><description>LeetCode problem 2059
class Solution: def minimumOperations(self, nums: List[int], start: int, goal: int) -&amp;gt; int: def next(x): res = [] for num in nums: res.append(x + num) res.append(x - num) res.append(x ^ num) return res def extend(m1, m2, q): for _ in range(len(q)): x = q.popleft() step = m1[x] for y in next(x): if y in m1: continue if y in m2: return step + 1 + m2[y] if 0 &amp;lt;= y &amp;lt;= 1000: m1[y] = step + 1 q.</description></item><item><title>2061. Number of Spaces Cleaning Robot Cleaned</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2061/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2061/</guid><description>LeetCode problem 2061
class Solution: def numberOfCleanRooms(self, room: List[List[int]]) -&amp;gt; int: dirs = (0, 1, 0, -1, 0) i = j = k = 0 res = 0 vis = set() while (i, j, k) not in vis: vis.add((i, j, k)) res += room[i][j] == 0 room[i][j] = -1 x, y = i + dirs[k], j + dirs[k + 1] if 0 &amp;lt;= x &amp;lt; len(room) and 0 &amp;lt;= y &amp;lt; len(room[0]) and room[x][y] != 1: i, j = x, y else: k = (k + 1) % 4 return res</description></item><item><title>2063. Vowels of All Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2063/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2063/</guid><description>LeetCode problem 2063
class Solution: def countVowels(self, word: str) -&amp;gt; int: n = len(word) return sum((i + 1) * (n - i) for i, c in enumerate(word) if c in &amp;#39;aeiou&amp;#39;)</description></item><item><title>2064. Minimized Maximum of Products Distributed to Any Store</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2064/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2064/</guid><description>LeetCode problem 2064
class Solution: def minimizedMaximum(self, n: int, quantities: List[int]) -&amp;gt; int: def check(x): return sum((v + x - 1) // x for v in quantities) &amp;lt;= n return 1 + bisect_left(range(1, 10**6), True, key=check)</description></item><item><title>2067. Number of Equal Count Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2067/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2067/</guid><description>LeetCode problem 2067
class Solution: def equalCountSubstrings(self, s: str, count: int) -&amp;gt; int: res = 0 for x in range(1, 27): m = count * x if m &amp;gt; len(s): break cnt = Counter() y = 0 for i, c in enumerate(s): cnt[c] += 1 y += cnt[c] == count y -= cnt[c] == count + 1 j = i - m if j &amp;gt;= 0: cnt[s[j]] -= 1 y += cnt[s[j]] == count y -= cnt[s[j]] == count - 1 res += x == y return res</description></item><item><title>2070. Most Beautiful Item for Each Query</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2070/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2070/</guid><description>LeetCode problem 2070
class Solution: def maximumBeauty(self, items: List[List[int]], queries: List[int]) -&amp;gt; List[int]: items.sort() prices = [p for p, _ in items] mx = [items[0][1]] for _, b in items[1:]: mx.append(max(mx[-1], b)) res = [0] * len(queries) for i, q in enumerate(queries): j = bisect_right(prices, q) if j: res[i] = mx[j - 1] return res</description></item><item><title>2074. Reverse Nodes in Even Length Groups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2074/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2074/</guid><description>LeetCode problem 2074
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseEvenLengthGroups(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def reverse(head, l): prev, cur, tail = None, head, head i = 0 while cur and i &amp;lt; l: t = cur.next cur.next = prev prev = cur cur = t i += 1 tail.next = cur return prev n = 0 t = head while t: t = t.</description></item><item><title>2075. Decode the Slanted Ciphertext</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2075/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2075/</guid><description>LeetCode problem 2075
class Solution: def decodeCiphertext(self, encodedText: str, rows: int) -&amp;gt; str: res = [] cols = len(encodedText) // rows for j in range(cols): x, y = 0, j while x &amp;lt; rows and y &amp;lt; cols: res.append(encodedText[x * cols + y]) x, y = x + 1, y + 1 return &amp;#39;&amp;#39;.join(res).rstrip()</description></item><item><title>2077. Paths in Maze That Lead to Same Room</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2077/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2077/</guid><description>LeetCode problem 2077
class Solution: def numberOfPaths(self, n: int, corridors: List[List[int]]) -&amp;gt; int: g = defaultdict(set) for a, b in corridors: g[a].add(b) g[b].add(a) res = 0 for i in range(1, n + 1): for j, k in combinations(g[i], 2): if j in g[k]: res += 1 return res // 3</description></item><item><title>2079. Watering Plants</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2079/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2079/</guid><description>LeetCode problem 2079
class Solution: def wateringPlants(self, plants: List[int], capacity: int) -&amp;gt; int: res, cap = 0, capacity for i, x in enumerate(plants): if cap &amp;gt;= x: cap -= x res += 1 else: cap = capacity - x res += i * 2 + 1 return res</description></item><item><title>2080. Range Frequency Queries</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2080/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2080/</guid><description>LeetCode problem 2080
class RangeFreqQuery: def __init__(self, arr: List[int]): self.mp = defaultdict(list) for i, x in enumerate(arr): self.mp[x].append(i) def query(self, left: int, right: int, value: int) -&amp;gt; int: if value not in self.mp: return 0 arr = self.mp[value] l, r = bisect_right(arr, left - 1), bisect_right(arr, right) return r - l # Your RangeFreqQuery object will be instantiated and called as such: # obj = RangeFreqQuery(arr) # param_1 = obj.query(left,right,value)</description></item><item><title>2083. Substrings That Begin and End With the Same Letter</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2083/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2083/</guid><description>LeetCode problem 2083
class Solution: def numberOfSubstrings(self, s: str) -&amp;gt; int: cnt = Counter() res = 0 for c in s: cnt[c] += 1 res += cnt[c] return res</description></item><item><title>2086. Minimum Number of Food Buckets to Feed the Hamsters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2086/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2086/</guid><description>LeetCode problem 2086
class Solution: def minimumBuckets(self, street: str) -&amp;gt; int: res = 0 i, n = 0, len(street) while i &amp;lt; n: if street[i] == &amp;#39;H&amp;#39;: if i + 1 &amp;lt; n and street[i + 1] == &amp;#39;.&amp;#39;: i += 2 res += 1 elif i and street[i - 1] == &amp;#39;.&amp;#39;: res += 1 else: return -1 i += 1 return res</description></item><item><title>2087. Minimum Cost Homecoming of a Robot in a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2087/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2087/</guid><description>LeetCode problem 2087
class Solution: def minCost( self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int], ) -&amp;gt; int: i, j = startPos x, y = homePos res = 0 if i &amp;lt; x: res += sum(rowCosts[i + 1 : x + 1]) else: res += sum(rowCosts[x:i]) if j &amp;lt; y: res += sum(colCosts[j + 1 : y + 1]) else: res += sum(colCosts[y:j]) return res</description></item><item><title>2090. K Radius Subarray Averages</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2090/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2090/</guid><description>LeetCode problem 2090
class Solution: def getAverages(self, nums: List[int], k: int) -&amp;gt; List[int]: s = 0 res = [-1] * len(nums) for i, v in enumerate(nums): s += v if i &amp;gt;= k * 2: res[i - k] = s // (k * 2 + 1) s -= nums[i - k * 2] return res</description></item><item><title>2091. Removing Minimum and Maximum From Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2091/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2091/</guid><description>LeetCode problem 2091
class Solution: def minimumDeletions(self, nums: List[int]) -&amp;gt; int: mi = mx = 0 for i, num in enumerate(nums): if num &amp;lt; nums[mi]: mi = i if num &amp;gt; nums[mx]: mx = i if mi &amp;gt; mx: mi, mx = mx, mi return min(mx + 1, len(nums) - mi, mi + 1 + len(nums) - mx)</description></item><item><title>2093. Minimum Cost to Reach City With Discounts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2093/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2093/</guid><description>LeetCode problem 2093
class Solution: def minimumCost(self, n: int, highways: List[List[int]], discounts: int) -&amp;gt; int: g = defaultdict(list) for a, b, c in highways: g[a].append((b, c)) g[b].append((a, c)) q = [(0, 0, 0)] dist = [[inf] * (discounts + 1) for _ in range(n)] while q: cost, i, k = heappop(q) if k &amp;gt; discounts: continue if i == n - 1: return cost if dist[i][k] &amp;gt; cost: dist[i][k] = cost for j, v in g[i]: heappush(q, (cost + v, j, k)) heappush(q, (cost + v // 2, j, k + 1)) return -1</description></item><item><title>2095. Delete the Middle Node of a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2095/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2095/</guid><description>LeetCode задача 2095
Задача Дан связный список (linked list). Задача — удалить средний узел из этого списка и вернуть начало(head) измененного списка.
Подсказки Мы можем использовать метод двух указателей для того, чтобы найти средний узел в одном проходе по списку, где второй указатель проходит весь список в два раза быстрее первого указателя.
Подход Используем два указателя для прохода по списку: один медленный и один быстрый. Оба начинают с головного узла списка. Быстрый указатель будет двигаться в два раза быстрее медленного.</description></item><item><title>2096. Step-By-Step Directions From a Binary Tree Node to Another</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2096/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2096/</guid><description>LeetCode problem 2096
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getDirections( self, root: Optional[TreeNode], startValue: int, destValue: int ) -&amp;gt; str: edges = defaultdict(list) res = None visited = set() def traverse(root): if not root: return if root.left: edges[root.val].append([root.left.val, &amp;#39;L&amp;#39;]) edges[root.left.val].append([root.val, &amp;#39;U&amp;#39;]) if root.right: edges[root.val].append([root.right.val, &amp;#39;R&amp;#39;]) edges[root.right.val].append([root.val, &amp;#39;U&amp;#39;]) traverse(root.left) traverse(root.right) def dfs(start, dest, t): nonlocal res if start in visited: return if start == dest: if res is None or len(res) &amp;gt; len(t): res = &amp;#39;&amp;#39;.</description></item><item><title>2098. Subsequence of Size K With the Largest Even Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2098/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2098/</guid><description>LeetCode problem 2098
class Solution: def largestEvenSum(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() res = sum(nums[-k:]) if res % 2 == 0: return res n = len(nums) mx1 = mx2 = -inf for x in nums[: n - k]: if x &amp;amp; 1: mx1 = x else: mx2 = x mi1 = mi2 = inf for x in nums[-k:][::-1]: if x &amp;amp; 1: mi2 = x else: mi1 = x res = max(res - mi1 + mx1, res - mi2 + mx2, -1) return -1 if res % 2 else res</description></item><item><title>2100. Find Good Days to Rob the Bank</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2100/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2100/</guid><description>LeetCode problem 2100
class Solution: def goodDaysToRobBank(self, security: List[int], time: int) -&amp;gt; List[int]: n = len(security) if n &amp;lt;= time * 2: return [] left, right = [0] * n, [0] * n for i in range(1, n): if security[i] &amp;lt;= security[i - 1]: left[i] = left[i - 1] + 1 for i in range(n - 2, -1, -1): if security[i] &amp;lt;= security[i + 1]: right[i] = right[i + 1] + 1 return [i for i in range(n) if time &amp;lt;= min(left[i], right[i])]</description></item><item><title>2101. Detonate the Maximum Bombs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2101/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2101/</guid><description>LeetCode problem 2101
class Solution: def maximumDetonation(self, bombs: List[List[int]]) -&amp;gt; int: def check(i, j): if i == j: return False x, y = bombs[i][0] - bombs[j][0], bombs[i][1] - bombs[j][1] r = bombs[i][2] return r * r &amp;gt;= x * x + y * y g = defaultdict(list) n = len(bombs) for i in range(n): for j in range(n): if check(i, j): g[i].append(j) res = 0 for k in range(n): q = deque([k]) vis = [False] * n vis[k] = True cnt = 0 while q: i = q.</description></item><item><title>2104. Sum of Subarray Ranges</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2104/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2104/</guid><description>LeetCode problem 2104
class Solution: def subArrayRanges(self, nums: List[int]) -&amp;gt; int: def f(nums): stk = [] n = len(nums) left = [-1] * n right = [n] * n for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;lt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) return sum((i - left[i]) * (right[i] - i) * v for i, v in enumerate(nums)) mx = f(nums) mi = f([-v for v in nums]) return mx + mi</description></item><item><title>2105. Watering Plants II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2105/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2105/</guid><description>LeetCode problem 2105
class Solution: def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -&amp;gt; int: i, j = 0, len(plants) - 1 res = 0 a, b = capacityA, capacityB while i &amp;lt;= j: if i == j: if max(capacityA, capacityB) &amp;lt; plants[i]: res += 1 break if capacityA &amp;lt; plants[i]: capacityA = a - plants[i] res += 1 else: capacityA -= plants[i] if capacityB &amp;lt; plants[j]: capacityB = b - plants[j] res += 1 else: capacityB -= plants[j] i += 1 j -= 1 return res</description></item><item><title>2107. Number of Unique Flavors After Sharing K Candies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2107/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2107/</guid><description>LeetCode problem 2107
class Solution: def shareCandies(self, candies: List[int], k: int) -&amp;gt; int: cnt = Counter(candies[k:]) res = len(cnt) for i in range(k, len(candies)): cnt[candies[i - k]] += 1 cnt[candies[i]] -= 1 if cnt[candies[i]] == 0: cnt.pop(candies[i]) res = max(res, len(cnt)) return res</description></item><item><title>2109. Adding Spaces to a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2109/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2109/</guid><description>LeetCode problem 2109
class Solution: def addSpaces(self, s: str, spaces: List[int]) -&amp;gt; str: res = [] i, j = len(s) - 1, len(spaces) - 1 while i &amp;gt;= 0: res.append(s[i]) if j &amp;gt;= 0 and i == spaces[j]: res.append(&amp;#39; &amp;#39;) j -= 1 i -= 1 return &amp;#39;&amp;#39;.join(res[::-1])</description></item><item><title>2110. Number of Smooth Descent Periods of a Stock</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2110/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2110/</guid><description>LeetCode problem 2110
class Solution: def getDescentPeriods(self, prices: List[int]) -&amp;gt; int: res = 0 i, n = 0, len(prices) while i &amp;lt; n: j = i + 1 while j &amp;lt; n and prices[j - 1] - prices[j] == 1: j += 1 cnt = j - i res += (1 + cnt) * cnt // 2 i = j return res</description></item><item><title>2113. Elements in Array After Removing and Replacing Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2113/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2113/</guid><description>LeetCode problem 2113
class Solution: def elementInNums(self, nums: List[int], queries: List[List[int]]) -&amp;gt; List[int]: n, m = len(nums), len(queries) res = [-1] * m for j, (t, i) in enumerate(queries): t %= 2 * n if t &amp;lt; n and i &amp;lt; n - t: res[j] = nums[i + t] elif t &amp;gt; n and i &amp;lt; t - n: res[j] = nums[i] return res</description></item><item><title>2115. Find All Possible Recipes from Given Supplies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2115/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2115/</guid><description>LeetCode problem 2115
class Solution: def findAllRecipes( self, recipes: List[str], ingredients: List[List[str]], supplies: List[str] ) -&amp;gt; List[str]: g = defaultdict(list) indeg = defaultdict(int) for a, b in zip(recipes, ingredients): for v in b: g[v].append(a) indeg[a] += len(b) q = deque(supplies) res = [] while q: for _ in range(len(q)): i = q.popleft() for j in g[i]: indeg[j] -= 1 if indeg[j] == 0: res.append(j) q.append(j) return res</description></item><item><title>2116. Check if a Parentheses String Can Be Valid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2116/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2116/</guid><description>LeetCode problem 2116
class Solution: def canBeValid(self, s: str, locked: str) -&amp;gt; bool: n = len(s) if n &amp;amp; 1: return False x = 0 for i in range(n): if s[i] == &amp;#39;(&amp;#39; or locked[i] == &amp;#39;0&amp;#39;: x += 1 elif x: x -= 1 else: return False x = 0 for i in range(n - 1, -1, -1): if s[i] == &amp;#39;)&amp;#39; or locked[i] == &amp;#39;0&amp;#39;: x += 1 elif x: x -= 1 else: return False return True</description></item><item><title>2120. Execution of All Suffix Instructions Staying in a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2120/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2120/</guid><description>LeetCode problem 2120
class Solution: def executeInstructions(self, n: int, startPos: List[int], s: str) -&amp;gt; List[int]: res = [] m = len(s) mp = {&amp;#34;L&amp;#34;: [0, -1], &amp;#34;R&amp;#34;: [0, 1], &amp;#34;U&amp;#34;: [-1, 0], &amp;#34;D&amp;#34;: [1, 0]} for i in range(m): x, y = startPos t = 0 for j in range(i, m): a, b = mp[s[j]] if 0 &amp;lt;= x + a &amp;lt; n and 0 &amp;lt;= y + b &amp;lt; n: x, y, t = x + a, y + b, t + 1 else: break res.</description></item><item><title>2121. Intervals Between Identical Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2121/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2121/</guid><description>LeetCode problem 2121
class Solution: def getDistances(self, arr: List[int]) -&amp;gt; List[int]: d = defaultdict(list) n = len(arr) for i, v in enumerate(arr): d[v].append(i) res = [0] * n for v in d.values(): m = len(v) val = sum(v) - v[0] * m for i, p in enumerate(v): delta = v[i] - v[i - 1] if i &amp;gt;= 1 else 0 val += i * delta - (m - i) * delta res[p] = val return res</description></item><item><title>2125. Number of Laser Beams in a Bank</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2125/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2125/</guid><description>LeetCode problem 2125
class Solution: def numberOfBeams(self, bank: List[str]) -&amp;gt; int: last = res = 0 for b in bank: if (t := b.count(&amp;#39;1&amp;#39;)) &amp;gt; 0: res += last * t last = t return res</description></item><item><title>2126. Destroying Asteroids</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2126/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2126/</guid><description>LeetCode problem 2126
class Solution: def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -&amp;gt; bool: asteroids.sort() for v in asteroids: if mass &amp;lt; v: return False mass += v return True</description></item><item><title>2128. Remove All Ones With Row and Column Flips</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2128/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2128/</guid><description>LeetCode problem 2128
class Solution: def removeOnes(self, grid: List[List[int]]) -&amp;gt; bool: s = set() for row in grid: t = tuple(row) if row[0] == grid[0][0] else tuple(x ^ 1 for x in row) s.add(t) return len(s) == 1</description></item><item><title>2130. Maximum Twin Sum of a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2130/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2130/</guid><description>LeetCode задача 2130
Задача Дан односвязный список четной длины. Узлы в этом списке имеют &amp;ldquo;близнецов&amp;rdquo; по определенным правилам. Задача — найти максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.
Т.е. у первой половины узлов списка есть свой близнец из второй половины.
Пример: для списка длиной n = 8 i = 0, twin = n-1-i = 8-1-0 = 7 i = 1, twin = n-1-1 = 6 i = 2, twin = n-1-2 = 5 &amp;hellip;
Подсказки У первой половины узлов списка есть свой близнец из второй половины, т.</description></item><item><title>2131. Longest Palindrome by Concatenating Two Letter Words</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2131/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2131/</guid><description>LeetCode problem 2131
class Solution: def longestPalindrome(self, words: List[str]) -&amp;gt; int: cnt = Counter(words) res = x = 0 for k, v in cnt.items(): if k[0] == k[1]: x += v &amp;amp; 1 res += v // 2 * 2 * 2 else: res += min(v, cnt[k[::-1]]) * 2 res += 2 if x else 0 return res</description></item><item><title>2135. Count Words Obtained After Adding a Letter</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2135/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2135/</guid><description>LeetCode problem 2135
class Solution: def wordCount(self, startWords: List[str], targetWords: List[str]) -&amp;gt; int: s = set() for word in startWords: mask = 0 for c in word: mask |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) s.add(mask) res = 0 for word in targetWords: mask = 0 for c in word: mask |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) for c in word: t = mask ^ (1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;))) if t in s: res += 1 break return res</description></item><item><title>2137. Pour Water Between Buckets to Make Water Levels Equal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2137/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2137/</guid><description>LeetCode problem 2137
class Solution: def equalizeWater(self, buckets: List[int], loss: int) -&amp;gt; float: def check(v): a = b = 0 for x in buckets: if x &amp;gt;= v: a += x - v else: b += (v - x) * 100 / (100 - loss) return a &amp;gt;= b l, r = 0, max(buckets) while r - l &amp;gt; 1e-5: mid = (l + r) / 2 if check(mid): l = mid else: r = mid return l</description></item><item><title>2139. Minimum Moves to Reach Target Score</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2139/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2139/</guid><description>LeetCode problem 2139
class Solution: def minMoves(self, target: int, maxDoubles: int) -&amp;gt; int: res = 0 while maxDoubles and target &amp;gt; 1: res += 1 if target % 2 == 1: target -= 1 else: maxDoubles -= 1 target &amp;gt;&amp;gt;= 1 res += target - 1 return res</description></item><item><title>2140. Solving Questions With Brainpower</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2140/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2140/</guid><description>LeetCode problem 2140
class Solution: def mostPoints(self, questions: List[List[int]]) -&amp;gt; int: n = len(questions) f = [0] * (n + 1) for i in range(n - 1, -1, -1): p, b = questions[i] j = i + b + 1 f[i] = max(f[i + 1], p + (0 if j &amp;gt; n else f[j])) return f[0]</description></item><item><title>2145. Count the Hidden Sequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2145/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2145/</guid><description>LeetCode problem 2145
class Solution: def numberOfArrays(self, differences: List[int], lower: int, upper: int) -&amp;gt; int: num = mi = mx = 0 for d in differences: num += d mi = min(mi, num) mx = max(mx, num) return max(0, upper - lower - (mx - mi) + 1)</description></item><item><title>2146. K Highest Ranked Items Within a Price Range</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2146/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2146/</guid><description>LeetCode problem 2146
class Solution: def highestRankedKItems( self, grid: List[List[int]], pricing: List[int], start: List[int], k: int ) -&amp;gt; List[List[int]]: m, n = len(grid), len(grid[0]) row, col, low, high = start + pricing items = [] if low &amp;lt;= grid[row][col] &amp;lt;= high: items.append([0, grid[row][col], row, col]) q = deque([(row, col, 0)]) grid[row][col] = 0 while q: i, j, d = q.popleft() for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]: x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and grid[x][y]: if low &amp;lt;= grid[x][y] &amp;lt;= high: items.</description></item><item><title>2149. Rearrange Array Elements by Sign</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2149/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2149/</guid><description>LeetCode problem 2149
class Solution: def rearrangeArray(self, nums: List[int]) -&amp;gt; List[int]: res = [0] * len(nums) i, j = 0, 1 for num in nums: if num &amp;gt; 0: res[i] = num i += 2 else: res[j] = num j += 2 return res</description></item><item><title>2150. Find All Lonely Numbers in the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2150/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2150/</guid><description>LeetCode problem 2150
class Solution: def findLonely(self, nums: List[int]) -&amp;gt; List[int]: counter = Counter(nums) res = [] for num, cnt in counter.items(): if cnt == 1 and counter[num - 1] == 0 and counter[num + 1] == 0: res.append(num) return res</description></item><item><title>2152. Minimum Number of Lines to Cover Points</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2152/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2152/</guid><description>LeetCode problem 2152
class Solution: def minimumLines(self, points: List[List[int]]) -&amp;gt; int: def check(i, j, k): x1, y1 = points[i] x2, y2 = points[j] x3, y3 = points[k] return (x2 - x1) * (y3 - y1) == (x3 - x1) * (y2 - y1) @cache def dfs(state): if state == (1 &amp;lt;&amp;lt; n) - 1: return 0 res = inf for i in range(n): if not (state &amp;gt;&amp;gt; i &amp;amp; 1): for j in range(i + 1, n): nxt = state | 1 &amp;lt;&amp;lt; i | 1 &amp;lt;&amp;lt; j for k in range(j + 1, n): if not (nxt &amp;gt;&amp;gt; k &amp;amp; 1) and check(i, j, k): nxt |= 1 &amp;lt;&amp;lt; k res = min(res, dfs(nxt) + 1) if i == n - 1: res = min(res, dfs(state | 1 &amp;lt;&amp;lt; i) + 1) return res n = len(points) return dfs(0)</description></item><item><title>2155. All Divisions With the Highest Score of a Binary Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2155/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2155/</guid><description>LeetCode problem 2155
class Solution: def maxScoreIndices(self, nums: List[int]) -&amp;gt; List[int]: left, right = 0, sum(nums) mx = right res = [0] for i, num in enumerate(nums): if num == 0: left += 1 else: right -= 1 t = left + right if mx == t: res.append(i + 1) elif mx &amp;lt; t: mx = t res = [i + 1] return res</description></item><item><title>2161. Partition Array According to Given Pivot</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2161/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2161/</guid><description>LeetCode problem 2161
class Solution: def pivotArray(self, nums: List[int], pivot: int) -&amp;gt; List[int]: a, b, c = [], [], [] for x in nums: if x &amp;lt; pivot: a.append(x) elif x == pivot: b.append(x) else: c.append(x) return a + b + c</description></item><item><title>2162. Minimum Cost to Set Cooking Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2162/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2162/</guid><description>LeetCode problem 2162
class Solution: def minCostSetTime( self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int ) -&amp;gt; int: def f(m, s): if not 0 &amp;lt;= m &amp;lt; 100 or not 0 &amp;lt;= s &amp;lt; 100: return inf arr = [m // 10, m % 10, s // 10, s % 10] i = 0 while i &amp;lt; 4 and arr[i] == 0: i += 1 t = 0 prev = startAt for v in arr[i:]: if v !</description></item><item><title>2165. Smallest Value of the Rearranged Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2165/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2165/</guid><description>LeetCode problem 2165
class Solution: def smallestNumber(self, num: int) -&amp;gt; int: if num == 0: return 0 cnt = [0] * 10 neg = num &amp;lt; 0 num = abs(num) while num: num, v = divmod(num, 10) cnt[v] += 1 res = &amp;#34;&amp;#34; if neg: for i in range(9, -1, -1): if cnt[i]: res += str(i) * cnt[i] return -int(res) if cnt[0]: for i in range(1, 10): if cnt[i]: res += str(i) cnt[i] -= 1 break for i in range(10): if cnt[i]: res += str(i) * cnt[i] return int(res)</description></item><item><title>2166. Design Bitset</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2166/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2166/</guid><description>LeetCode problem 2166
class Bitset: def __init__(self, size: int): self.a = [&amp;#39;0&amp;#39;] * size self.b = [&amp;#39;1&amp;#39;] * size self.cnt = 0 def fix(self, idx: int) -&amp;gt; None: if self.a[idx] == &amp;#39;0&amp;#39;: self.a[idx] = &amp;#39;1&amp;#39; self.cnt += 1 self.b[idx] = &amp;#39;0&amp;#39; def unfix(self, idx: int) -&amp;gt; None: if self.a[idx] == &amp;#39;1&amp;#39;: self.a[idx] = &amp;#39;0&amp;#39; self.cnt -= 1 self.b[idx] = &amp;#39;1&amp;#39; def flip(self) -&amp;gt; None: self.a, self.b = self.b, self.a self.cnt = len(self.a) - self.cnt def all(self) -&amp;gt; bool: return self.</description></item><item><title>2168. Unique Substrings With Equal Digit Frequency</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2168/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2168/</guid><description>LeetCode problem 2168
class Solution: def equalDigitFrequency(self, s: str) -&amp;gt; int: def check(i, j): v = set() for k in range(10): cnt = presum[j + 1][k] - presum[i][k] if cnt &amp;gt; 0: v.add(cnt) if len(v) &amp;gt; 1: return False return True n = len(s) presum = [[0] * 10 for _ in range(n + 1)] for i, c in enumerate(s): presum[i + 1][int(c)] += 1 for j in range(10): presum[i + 1][j] += presum[i][j] vis = set(s[i : j + 1] for i in range(n) for j in range(i, n) if check(i, j)) return len(vis)</description></item><item><title>2170. Minimum Operations to Make the Array Alternating</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2170/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2170/</guid><description>LeetCode problem 2170
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: def get(i): c = Counter(nums[i::2]).most_common(2) if not c: return [(0, 0), (0, 0)] if len(c) == 1: return [c[0], (0, 0)] return c n = len(nums) return min(n - (n1 + n2) for a, n1 in get(0) for b, n2 in get(1) if a != b)</description></item><item><title>2171. Removing Minimum Number of Magic Beans</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2171/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2171/</guid><description>LeetCode problem 2171
class Solution: def minimumRemoval(self, beans: List[int]) -&amp;gt; int: beans.sort() s, n = sum(beans), len(beans) return min(s - x * (n - i) for i, x in enumerate(beans))</description></item><item><title>2174. Remove All Ones With Row and Column Flips II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2174/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2174/</guid><description>LeetCode problem 2174
class Solution: def removeOnes(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) state = sum(1 &amp;lt;&amp;lt; (i * n + j) for i in range(m) for j in range(n) if grid[i][j]) q = deque([state]) vis = {state} res = 0 while q: for _ in range(len(q)): state = q.popleft() if state == 0: return res for i in range(m): for j in range(n): if grid[i][j] == 0: continue nxt = state for r in range(m): nxt &amp;amp;= ~(1 &amp;lt;&amp;lt; (r * n + j)) for c in range(n): nxt &amp;amp;= ~(1 &amp;lt;&amp;lt; (i * n + c)) if nxt not in vis: vis.</description></item><item><title>2177. Find Three Consecutive Integers That Sum to a Given Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2177/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2177/</guid><description>LeetCode problem 2177
class Solution: def sumOfThree(self, num: int) -&amp;gt; List[int]: x, mod = divmod(num, 3) return [] if mod else [x - 1, x, x + 1]</description></item><item><title>2178. Maximum Split of Positive Even Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2178/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2178/</guid><description>LeetCode problem 2178
class Solution: def maximumEvenSplit(self, finalSum: int) -&amp;gt; List[int]: if finalSum % 2: return [] i = 2 res = [] while i &amp;lt;= finalSum: res.append(i) finalSum -= i i += 2 res[-1] += finalSum return res</description></item><item><title>2181. Merge Nodes in Between Zeros</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2181/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2181/</guid><description>LeetCode problem 2181
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeNodes(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = tail = ListNode() s = 0 cur = head.next while cur: if cur.val != 0: s += cur.val else: tail.next = ListNode(s) tail = tail.next s = 0 cur = cur.next return dummy.next</description></item><item><title>2182. Construct String With Repeat Limit</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2182/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2182/</guid><description>LeetCode problem 2182
class Solution: def repeatLimitedString(self, s: str, repeatLimit: int) -&amp;gt; str: cnt = [0] * 26 for c in s: cnt[ord(c) - ord(&amp;#34;a&amp;#34;)] += 1 res = [] j = 24 for i in range(25, -1, -1): j = min(i - 1, j) while 1: x = min(repeatLimit, cnt[i]) cnt[i] -= x res.append(ascii_lowercase[i] * x) if cnt[i] == 0: break while j &amp;gt;= 0 and cnt[j] == 0: j -= 1 if j &amp;lt; 0: break cnt[j] -= 1 res.</description></item><item><title>2184. Number of Ways to Build Sturdy Brick Wall</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2184/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2184/</guid><description>LeetCode problem 2184
class Solution: def buildWall(self, height: int, width: int, bricks: List[int]) -&amp;gt; int: def dfs(v): if v &amp;gt; width: return if v == width: s.append(t[:]) return for x in bricks: t.append(x) dfs(v + x) t.pop() def check(a, b): s1, s2 = a[0], b[0] i = j = 1 while i &amp;lt; len(a) and j &amp;lt; len(b): if s1 == s2: return False if s1 &amp;lt; s2: s1 += a[i] i += 1 else: s2 += b[j] j += 1 return True mod = 10**9 + 7 s = [] t = [] dfs(0) g = defaultdict(list) n = len(s) for i in range(n): if check(s[i], s[i]): g[i].</description></item><item><title>2186. Minimum Number of Steps to Make Two Strings Anagram II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2186/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2186/</guid><description>LeetCode problem 2186
class Solution: def minSteps(self, s: str, t: str) -&amp;gt; int: cnt = Counter(s) for c in t: cnt[c] -= 1 return sum(abs(v) for v in cnt.values())</description></item><item><title>2187. Minimum Time to Complete Trips</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2187/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2187/</guid><description>LeetCode problem 2187
class Solution: def minimumTime(self, time: List[int], totalTrips: int) -&amp;gt; int: mx = min(time) * totalTrips return bisect_left( range(mx), totalTrips, key=lambda x: sum(x // v for v in time) )</description></item><item><title>2189. Number of Ways to Build House of Cards</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2189/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2189/</guid><description>LeetCode problem 2189
class Solution: def houseOfCards(self, n: int) -&amp;gt; int: @cache def dfs(n: int, k: int) -&amp;gt; int: x = 3 * k + 2 if x &amp;gt; n: return 0 if x == n: return 1 return dfs(n - x, k + 1) + dfs(n, k + 1) return dfs(n, 0)</description></item><item><title>2191. Sort the Jumbled Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2191/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2191/</guid><description>LeetCode problem 2191
class Solution: def sortJumbled(self, mapping: List[int], nums: List[int]) -&amp;gt; List[int]: arr = [] for i, x in enumerate(nums): y = mapping[0] if x == 0 else 0 k = 1 while x: x, v = divmod(x, 10) y = mapping[v] * k + y k *= 10 arr.append((y, i)) arr.sort() return [nums[i] for _, i in arr]</description></item><item><title>2192. All Ancestors of a Node in a Directed Acyclic Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2192/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2192/</guid><description>LeetCode problem 2192
class Solution: def getAncestors(self, n: int, edges: List[List[int]]) -&amp;gt; List[List[int]]: def bfs(s: int): q = deque([s]) vis = {s} while q: i = q.popleft() for j in g[i]: if j not in vis: vis.add(j) q.append(j) res[j].append(s) g = defaultdict(list) for u, v in edges: g[u].append(v) res = [[] for _ in range(n)] for i in range(n): bfs(i) return res</description></item><item><title>2195. Append K Integers With Minimal Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2195/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2195/</guid><description>LeetCode problem 2195
class Solution: def minimalKSum(self, nums: List[int], k: int) -&amp;gt; int: nums.append(0) nums.append(2 * 10**9) nums.sort() res = 0 for a, b in pairwise(nums): n = min(k, b - a - 1) if n &amp;lt;= 0: continue k -= n res += (a + 1 + a + n) * n // 2 if k == 0: break return res</description></item><item><title>2196. Create Binary Tree From Descriptions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2196/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2196/</guid><description>LeetCode problem 2196
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def createBinaryTree(self, descriptions: List[List[int]]) -&amp;gt; Optional[TreeNode]: g = defaultdict(TreeNode) vis = set() for p, c, left in descriptions: if p not in g: g[p] = TreeNode(p) if c not in g: g[c] = TreeNode(c) if left: g[p].left = g[c] else: g[p].right = g[c] vis.add(c) for v, node in g.</description></item><item><title>2198. Number of Single Divisor Triplets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2198/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2198/</guid><description>LeetCode problem 2198
class Solution: def singleDivisorTriplet(self, nums: List[int]) -&amp;gt; int: def check(a, b, c): s = a + b + c return sum(s % x == 0 for x in [a, b, c]) == 1 counter = Counter(nums) res = 0 for a, cnt1 in counter.items(): for b, cnt2 in counter.items(): for c, cnt3 in counter.items(): if check(a, b, c): if a == b: res += cnt1 * (cnt1 - 1) * cnt3 elif a == c: res += cnt1 * (cnt1 - 1) * cnt2 elif b == c: res += cnt1 * cnt2 * (cnt2 - 1) else: res += cnt1 * cnt2 * cnt3 return res</description></item><item><title>2201. Count Artifacts That Can Be Extracted</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2201/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2201/</guid><description>LeetCode problem 2201
class Solution: def digArtifacts( self, n: int, artifacts: List[List[int]], dig: List[List[int]] ) -&amp;gt; int: def check(a: List[int]) -&amp;gt; bool: x1, y1, x2, y2 = a return all( (x, y) in s for x in range(x1, x2 + 1) for y in range(y1, y2 + 1) ) s = {(i, j) for i, j in dig} return sum(check(a) for a in artifacts)</description></item><item><title>2202. Maximize the Topmost Element After K Moves</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2202/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2202/</guid><description>LeetCode problem 2202
class Solution: def maximumTop(self, nums: List[int], k: int) -&amp;gt; int: if k == 0: return nums[0] n = len(nums) if n == 1: if k % 2: return -1 return nums[0] res = max(nums[: k - 1], default=-1) if k &amp;lt; n: res = max(res, nums[k]) return res</description></item><item><title>2207. Maximize Number of Subsequences in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2207/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2207/</guid><description>LeetCode problem 2207
class Solution: def maximumSubsequenceCount(self, text: str, pattern: str) -&amp;gt; int: res = 0 cnt = Counter() for c in text: if c == pattern[1]: res += cnt[pattern[0]] cnt[c] += 1 res += max(cnt[pattern[0]], cnt[pattern[1]]) return res</description></item><item><title>2208. Minimum Operations to Halve Array Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2208/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2208/</guid><description>LeetCode problem 2208
class Solution: def halveArray(self, nums: List[int]) -&amp;gt; int: s = sum(nums) / 2 h = [] for v in nums: heappush(h, -v) res = 0 while s &amp;gt; 0: t = -heappop(h) / 2 s -= t heappush(h, -t) res += 1 return res</description></item><item><title>2211. Count Collisions on a Road</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2211/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2211/</guid><description>LeetCode problem 2211
class Solution: def countCollisions(self, directions: str) -&amp;gt; int: d = directions.lstrip(&amp;#39;L&amp;#39;).rstrip(&amp;#39;R&amp;#39;) return len(d) - d.count(&amp;#39;S&amp;#39;)</description></item><item><title>2212. Maximum Points in an Archery Competition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2212/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2212/</guid><description>LeetCode problem 2212
class Solution: def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -&amp;gt; List[int]: n = len(aliceArrows) state = 0 mx = -1 for mask in range(1 &amp;lt;&amp;lt; n): cnt = points = 0 for i, alice in enumerate(aliceArrows): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: cnt += alice + 1 points += i if cnt &amp;lt;= numArrows and mx &amp;lt; points: state = mask mx = points res = [0] * n for i, alice in enumerate(aliceArrows): if (state &amp;gt;&amp;gt; i) &amp;amp; 1: res[i] = alice + 1 numArrows -= res[i] res[0] = numArrows return res</description></item><item><title>2214. Minimum Health to Beat Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2214/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2214/</guid><description>LeetCode problem 2214
class Solution: def minimumHealth(self, damage: List[int], armor: int) -&amp;gt; int: return sum(damage) - min(max(damage), armor) + 1</description></item><item><title>2216. Minimum Deletions to Make Array Beautiful</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2216/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2216/</guid><description>LeetCode problem 2216
class Solution: def minDeletion(self, nums: List[int]) -&amp;gt; int: n = len(nums) res = i = 0 while i &amp;lt; n: j = i + 1 while j &amp;lt; n and nums[j] == nums[i]: j += 1 res += 1 i = j + 1 res += (n - res) % 2 return res</description></item><item><title>2217. Find Palindrome With Fixed Length</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2217/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2217/</guid><description>LeetCode problem 2217
class Solution: def kthPalindrome(self, queries: List[int], intLength: int) -&amp;gt; List[int]: l = (intLength + 1) &amp;gt;&amp;gt; 1 start, end = 10 ** (l - 1), 10**l - 1 res = [] for q in queries: v = start + q - 1 if v &amp;gt; end: res.append(-1) continue s = str(v) s += s[::-1][intLength % 2 :] res.append(int(s)) return res</description></item><item><title>2219. Maximum Sum Score of Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2219/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2219/</guid><description>LeetCode problem 2219
class Solution: def maximumSumScore(self, nums: List[int]) -&amp;gt; int: s = [0] + list(accumulate(nums)) return max(max(s[i + 1], s[-1] - s[i]) for i in range(len(nums)))</description></item><item><title>2221. Find Triangular Sum of an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2221/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2221/</guid><description>LeetCode problem 2221
class Solution: def triangularSum(self, nums: List[int]) -&amp;gt; int: n = len(nums) for i in range(n, 0, -1): for j in range(i - 1): nums[j] = (nums[j] + nums[j + 1]) % 10 return nums[0]</description></item><item><title>2222. Number of Ways to Select Buildings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2222/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2222/</guid><description>LeetCode problem 2222
class Solution: def numberOfWays(self, s: str) -&amp;gt; int: n = len(s) cnt0 = s.count(&amp;#34;0&amp;#34;) cnt1 = n - cnt0 c0 = c1 = 0 res = 0 for c in s: if c == &amp;#34;0&amp;#34;: res += c1 * (cnt1 - c1) c0 += 1 else: res += c0 * (cnt0 - c0) c1 += 1 return res</description></item><item><title>2225. Find Players With Zero or One Losses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2225/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2225/</guid><description>LeetCode problem 2225
class Solution: def findWinners(self, matches: List[List[int]]) -&amp;gt; List[List[int]]: cnt = Counter() for a, b in matches: if a not in cnt: cnt[a] = 0 cnt[b] += 1 res = [[], []] for u, v in cnt.items(): if v &amp;lt; 2: res[v].append(u) res[0].sort() res[1].sort() return res</description></item><item><title>2226. Maximum Candies Allocated to K Children</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2226/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2226/</guid><description>LeetCode problem 2226
class Solution: def maximumCandies(self, candies: List[int], k: int) -&amp;gt; int: left, right = 0, max(candies) while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 cnt = sum(v // mid for v in candies) if cnt &amp;gt;= k: left = mid else: right = mid - 1 return left</description></item><item><title>2232. Minimize Result by Adding Parentheses to Expression</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2232/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2232/</guid><description>LeetCode problem 2232
class Solution: def minimizeResult(self, expression: str) -&amp;gt; str: l, r = expression.split(&amp;#34;+&amp;#34;) m, n = len(l), len(r) mi = inf res = None for i in range(m): for j in range(n): c = int(l[i:]) + int(r[: j + 1]) a = 1 if i == 0 else int(l[:i]) b = 1 if j == n - 1 else int(r[j + 1 :]) if (t := a * b * c) &amp;lt; mi: mi = t res = f&amp;#34;{l[:i]}({l[i:]}+{r[: j + 1]}){r[j + 1:]}&amp;#34; return res</description></item><item><title>2233. Maximum Product After K Increments</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2233/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2233/</guid><description>LeetCode problem 2233
class Solution: def maximumProduct(self, nums: List[int], k: int) -&amp;gt; int: heapify(nums) for _ in range(k): heappush(nums, heappop(nums) + 1) res = 1 mod = 10**9 + 7 for v in nums: res = (res * v) % mod return res</description></item><item><title>2237. Count Positions on Street With Required Brightness</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2237/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2237/</guid><description>LeetCode problem 2237
class Solution: def meetRequirement( self, n: int, lights: List[List[int]], requirement: List[int] ) -&amp;gt; int: d = [0] * 100010 for p, r in lights: i, j = max(0, p - r), min(n - 1, p + r) d[i] += 1 d[j + 1] -= 1 return sum(s &amp;gt;= r for s, r in zip(accumulate(d), requirement))</description></item><item><title>2240. Number of Ways to Buy Pens and Pencils</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2240/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2240/</guid><description>LeetCode problem 2240
class Solution: def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -&amp;gt; int: res = 0 for x in range(total // cost1 + 1): y = (total - (x * cost1)) // cost2 + 1 res += y return res</description></item><item><title>2241. Design an ATM Machine</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2241/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2241/</guid><description>LeetCode problem 2241
class ATM: def __init__(self): self.cnt = [0] * 5 self.d = [20, 50, 100, 200, 500] def deposit(self, banknotesCount: List[int]) -&amp;gt; None: for i, v in enumerate(banknotesCount): self.cnt[i] += v def withdraw(self, amount: int) -&amp;gt; List[int]: res = [0] * 5 for i in range(4, -1, -1): res[i] = min(amount // self.d[i], self.cnt[i]) amount -= res[i] * self.d[i] if amount &amp;gt; 0: return [-1] for i, v in enumerate(res): self.cnt[i] -= v return res # Your ATM object will be instantiated and called as such: # obj = ATM() # obj.</description></item><item><title>2244. Minimum Rounds to Complete All Tasks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2244/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2244/</guid><description>LeetCode problem 2244
class Solution: def minimumRounds(self, tasks: List[int]) -&amp;gt; int: cnt = Counter(tasks) res = 0 for v in cnt.values(): if v == 1: return -1 res += v // 3 + (v % 3 != 0) return res</description></item><item><title>2245. Maximum Trailing Zeros in a Cornered Path</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2245/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2245/</guid><description>LeetCode problem 2245
class Solution: def maxTrailingZeros(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) r2 = [[0] * (n + 1) for _ in range(m + 1)] c2 = [[0] * (n + 1) for _ in range(m + 1)] r5 = [[0] * (n + 1) for _ in range(m + 1)] c5 = [[0] * (n + 1) for _ in range(m + 1)] for i, row in enumerate(grid, 1): for j, x in enumerate(row, 1): s2 = s5 = 0 while x % 2 == 0: x //= 2 s2 += 1 while x % 5 == 0: x //= 5 s5 += 1 r2[i][j] = r2[i][j - 1] + s2 c2[i][j] = c2[i - 1][j] + s2 r5[i][j] = r5[i][j - 1] + s5 c5[i][j] = c5[i - 1][j] + s5 res = 0 for i in range(1, m + 1): for j in range(1, n + 1): a = min(r2[i][j] + c2[i - 1][j], r5[i][j] + c5[i - 1][j]) b = min(r2[i][j] + c2[m][j] - c2[i][j], r5[i][j] + c5[m][j] - c5[i][j]) c = min(r2[i][n] - r2[i][j] + c2[i][j], r5[i][n] - r5[i][j] + c5[i][j]) d = min( r2[i][n] - r2[i][j - 1] + c2[m][j] - c2[i][j], r5[i][n] - r5[i][j - 1] + c5[m][j] - c5[i][j], ) res = max(res, a, b, c, d) return res</description></item><item><title>2249. Count Lattice Points Inside a Circle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2249/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2249/</guid><description>LeetCode problem 2249
class Solution: def countLatticePoints(self, circles: List[List[int]]) -&amp;gt; int: res = 0 mx = max(x + r for x, _, r in circles) my = max(y + r for _, y, r in circles) for i in range(mx + 1): for j in range(my + 1): for x, y, r in circles: dx, dy = i - x, j - y if dx * dx + dy * dy &amp;lt;= r * r: res += 1 break return res</description></item><item><title>2250. Count Number of Rectangles Containing Each Point</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2250/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2250/</guid><description>LeetCode problem 2250
class Solution: def countRectangles( self, rectangles: List[List[int]], points: List[List[int]] ) -&amp;gt; List[int]: d = defaultdict(list) for x, y in rectangles: d[y].append(x) for y in d.keys(): d[y].sort() res = [] for x, y in points: cnt = 0 for h in range(y, 101): xs = d[h] cnt += len(xs) - bisect_left(xs, x) res.append(cnt) return res</description></item><item><title>2256. Minimum Average Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2256/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2256/</guid><description>LeetCode problem 2256
class Solution: def minimumAverageDifference(self, nums: List[int]) -&amp;gt; int: pre, suf = 0, sum(nums) n = len(nums) res, mi = 0, inf for i, x in enumerate(nums): pre += x suf -= x a = pre // (i + 1) b = 0 if n - i - 1 == 0 else suf // (n - i - 1) if (t := abs(a - b)) &amp;lt; mi: res = i mi = t return res</description></item><item><title>2257. Count Unguarded Cells in the Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2257/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2257/</guid><description>LeetCode problem 2257
class Solution: def countUnguarded( self, m: int, n: int, guards: List[List[int]], walls: List[List[int]] ) -&amp;gt; int: g = [[0] * n for _ in range(m)] for i, j in guards: g[i][j] = 2 for i, j in walls: g[i][j] = 2 dirs = (-1, 0, 1, 0, -1) for i, j in guards: for a, b in pairwise(dirs): x, y = i, j while 0 &amp;lt;= x + a &amp;lt; m and 0 &amp;lt;= y + b &amp;lt; n and g[x + a][y + b] &amp;lt; 2: x, y = x + a, y + b g[x][y] = 1 return sum(v == 0 for row in g for v in row)</description></item><item><title>2260. Minimum Consecutive Cards to Pick Up</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2260/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2260/</guid><description>LeetCode problem 2260
class Solution: def minimumCardPickup(self, cards: List[int]) -&amp;gt; int: last = {} res = inf for i, x in enumerate(cards): if x in last: res = min(res, i - last[x] + 1) last[x] = i return -1 if res == inf else res</description></item><item><title>2261. K Divisible Elements Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2261/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2261/</guid><description>LeetCode problem 2261
class Solution: def countDistinct(self, nums: List[int], k: int, p: int) -&amp;gt; int: n = len(nums) s = set() for i in range(n): cnt = 0 t = &amp;#34;&amp;#34; for x in nums[i:]: cnt += x % p == 0 if cnt &amp;gt; k: break t += str(x) + &amp;#34;,&amp;#34; s.add(t) return len(s)</description></item><item><title>2265. Count Nodes Equal to Average of Subtree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2265/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2265/</guid><description>LeetCode problem 2265
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def averageOfSubtree(self, root: Optional[TreeNode]) -&amp;gt; int: def dfs(root): if root is None: return 0, 0 ls, ln = dfs(root.left) rs, rn = dfs(root.right) s = ls + rs + root.val n = ln + rn + 1 if s // n == root.val: nonlocal res res += 1 return s, n res = 0 dfs(root) return res</description></item><item><title>2266. Count Number of Texts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2266/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2266/</guid><description>LeetCode problem 2266
mod = 10**9 + 7 f = [1, 1, 2, 4] g = [1, 1, 2, 4] for _ in range(100000): f.append((f[-1] + f[-2] + f[-3]) % mod) g.append((g[-1] + g[-2] + g[-3] + g[-4]) % mod) class Solution: def countTexts(self, pressedKeys: str) -&amp;gt; int: res = 1 for ch, s in groupby(pressedKeys): m = len(list(s)) res = res * (g[m] if ch in &amp;#34;79&amp;#34; else f[m]) % mod return res</description></item><item><title>2268. Minimum Number of Keypresses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2268/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2268/</guid><description>LeetCode problem 2268
class Solution: def minimumKeypresses(self, s: str) -&amp;gt; int: cnt = Counter(s) res = 0 i, j = 0, 1 for v in sorted(cnt.values(), reverse=True): i += 1 res += j * v if i % 9 == 0: j += 1 return res</description></item><item><title>2270. Number of Ways to Split Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2270/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2270/</guid><description>LeetCode problem 2270
class Solution: def waysToSplitArray(self, nums: List[int]) -&amp;gt; int: s = sum(nums) res = t = 0 for v in nums[:-1]: t += v if t &amp;gt;= s - t: res += 1 return res</description></item><item><title>2271. Maximum White Tiles Covered by a Carpet</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2271/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2271/</guid><description>LeetCode problem 2271
class Solution: def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -&amp;gt; int: tiles.sort() n = len(tiles) s = res = j = 0 for i, (li, ri) in enumerate(tiles): while j &amp;lt; n and tiles[j][1] - li + 1 &amp;lt;= carpetLen: s += tiles[j][1] - tiles[j][0] + 1 j += 1 if j &amp;lt; n and li + carpetLen &amp;gt; tiles[j][0]: res = max(res, s + li + carpetLen - tiles[j][0]) else: res = max(res, s) s -= ri - li + 1 return res</description></item><item><title>2274. Maximum Consecutive Floors Without Special Floors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2274/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2274/</guid><description>LeetCode problem 2274
class Solution: def maxConsecutive(self, bottom: int, top: int, special: List[int]) -&amp;gt; int: special.sort() res = max(special[0] - bottom, top - special[-1]) for i in range(1, len(special)): res = max(res, special[i] - special[i - 1] - 1) return res</description></item><item><title>2275. Largest Combination With Bitwise AND Greater Than Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2275/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2275/</guid><description>LeetCode problem 2275
class Solution: def largestCombination(self, candidates: List[int]) -&amp;gt; int: res = 0 for i in range(32): t = 0 for x in candidates: t += (x &amp;gt;&amp;gt; i) &amp;amp; 1 res = max(res, t) return res</description></item><item><title>2279. Maximum Bags With Full Capacity of Rocks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2279/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2279/</guid><description>LeetCode problem 2279
class Solution: def maximumBags( self, capacity: List[int], rocks: List[int], additionalRocks: int ) -&amp;gt; int: d = [a - b for a, b in zip(capacity, rocks)] d.sort() res = 0 for v in d: if v &amp;lt;= additionalRocks: res += 1 additionalRocks -= v return res</description></item><item><title>2280. Minimum Lines to Represent a Line Chart</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2280/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2280/</guid><description>LeetCode problem 2280
class Solution: def minimumLines(self, stockPrices: List[List[int]]) -&amp;gt; int: stockPrices.sort() dx, dy = 0, 1 res = 0 for (x, y), (x1, y1) in pairwise(stockPrices): dx1, dy1 = x1 - x, y1 - y if dy * dx1 != dx * dy1: res += 1 dx, dy = dx1, dy1 return res</description></item><item><title>2282. Number of People That Can Be Seen in a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2282/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2282/</guid><description>LeetCode problem 2282
class Solution: def seePeople(self, heights: List[List[int]]) -&amp;gt; List[List[int]]: def f(nums: List[int]) -&amp;gt; List[int]: n = len(nums) stk = [] res = [0] * n for i in range(n - 1, -1, -1): while stk and stk[-1] &amp;lt; nums[i]: res[i] += 1 stk.pop() if stk: res[i] += 1 while stk and stk[-1] == nums[i]: stk.pop() stk.append(nums[i]) return res res = [f(row) for row in heights] m, n = len(heights), len(heights[0]) for j in range(n): add = f([heights[i][j] for i in range(m)]) for i in range(m): res[i][j] += add[i] return res</description></item><item><title>2284. Sender With Largest Word Count</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2284/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2284/</guid><description>LeetCode problem 2284
class Solution: def largestWordCount(self, messages: List[str], senders: List[str]) -&amp;gt; str: cnt = Counter() for msg, sender in zip(messages, senders): cnt[sender] += msg.count(&amp;#39; &amp;#39;) + 1 res = &amp;#39;&amp;#39; for sender, v in cnt.items(): if cnt[res] &amp;lt; v or (cnt[res] == v and res &amp;lt; sender): res = sender return res</description></item><item><title>2285. Maximum Total Importance of Roads</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2285/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2285/</guid><description>LeetCode problem 2285
class Solution: def maximumImportance(self, n: int, roads: List[List[int]]) -&amp;gt; int: deg = [0] * n for a, b in roads: deg[a] += 1 deg[b] += 1 deg.sort() return sum(i * v for i, v in enumerate(deg, 1))</description></item><item><title>2288. Apply Discount to Prices</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2288/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2288/</guid><description>LeetCode problem 2288
class Solution: def discountPrices(self, sentence: str, discount: int) -&amp;gt; str: res = [] for w in sentence.split(): if w[0] == &amp;#39;$&amp;#39; and w[1:].isdigit(): w = f&amp;#39;${int(w[1:]) * (1 - discount / 100):.2f}&amp;#39; res.append(w) return &amp;#39; &amp;#39;.join(res)</description></item><item><title>2289. Steps to Make Array Non-decreasing</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2289/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2289/</guid><description>LeetCode problem 2289
class Solution: def totalSteps(self, nums: List[int]) -&amp;gt; int: stk = [] res, n = 0, len(nums) dp = [0] * n for i in range(n - 1, -1, -1): while stk and nums[i] &amp;gt; nums[stk[-1]]: dp[i] = max(dp[i] + 1, dp[stk.pop()]) stk.append(i) return max(dp)</description></item><item><title>2291. Maximum Profit From Trading Stocks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2291/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2291/</guid><description>LeetCode problem 2291
class Solution: def maximumProfit(self, present: List[int], future: List[int], budget: int) -&amp;gt; int: f = [0] * (budget + 1) for a, b in zip(present, future): for j in range(budget, a - 1, -1): f[j] = max(f[j], f[j - a] + b - a) return f[-1]</description></item><item><title>2294. Partition Array Such That Maximum Difference Is K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2294/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2294/</guid><description>LeetCode problem 2294
class Solution: def partitionArray(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() res, a = 1, nums[0] for b in nums: if b - a &amp;gt; k: a = b res += 1 return res</description></item><item><title>2295. Replace Elements in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2295/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2295/</guid><description>LeetCode problem 2295
class Solution: def arrayChange(self, nums: List[int], operations: List[List[int]]) -&amp;gt; List[int]: d = {v: i for i, v in enumerate(nums)} for a, b in operations: nums[d[a]] = b d[b] = d[a] return nums</description></item><item><title>2297. Jump Game VIII</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2297/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2297/</guid><description>LeetCode problem 2297
class Solution: def minCost(self, nums: List[int], costs: List[int]) -&amp;gt; int: n = len(nums) g = defaultdict(list) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: g[i].append(stk[-1]) stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt;= nums[i]: stk.pop() if stk: g[i].append(stk[-1]) stk.append(i) f = [inf] * n f[0] = 0 for i in range(n): for j in g[i]: f[j] = min(f[j], f[i] + costs[j]) return f[n - 1]</description></item><item><title>2300. Successful Pairs of Spells and Potions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2300/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2300/</guid><description>LeetCode problem 2300
class Solution: def successfulPairs( self, spells: List[int], potions: List[int], success: int ) -&amp;gt; List[int]: potions.sort() m = len(potions) return [m - bisect_left(potions, success / v) for v in spells]</description></item><item><title>2304. Minimum Path Cost in a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2304/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2304/</guid><description>LeetCode problem 2304
class Solution: def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) f = grid[0] for i in range(1, m): g = [inf] * n for j in range(n): for k in range(n): g[j] = min(g[j], f[k] + moveCost[grid[i - 1][k]][j] + grid[i][j]) f = g return min(f)</description></item><item><title>2305. Fair Distribution of Cookies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2305/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2305/</guid><description>LeetCode problem 2305
class Solution: def distributeCookies(self, cookies: List[int], k: int) -&amp;gt; int: def dfs(i): if i &amp;gt;= len(cookies): nonlocal res res = max(cnt) return for j in range(k): if cnt[j] + cookies[i] &amp;gt;= res or (j and cnt[j] == cnt[j - 1]): continue cnt[j] += cookies[i] dfs(i + 1) cnt[j] -= cookies[i] res = inf cnt = [0] * k cookies.sort(reverse=True) dfs(0) return res</description></item><item><title>2310. Sum of Numbers With Units Digit K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2310/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2310/</guid><description>LeetCode problem 2310
class Solution: def minimumNumbers(self, num: int, k: int) -&amp;gt; int: @cache def dfs(v): if v == 0: return 0 if v &amp;lt; 10 and v % k: return inf i = 0 t = inf while (x := i * 10 + k) &amp;lt;= v: t = min(t, dfs(v - x)) i += 1 return t + 1 if num == 0: return 0 if k == 0: return -1 if num % 10 else 1 res = dfs(num) return -1 if res &amp;gt;= inf else res</description></item><item><title>2311. Longest Binary Subsequence Less Than or Equal to K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2311/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2311/</guid><description>LeetCode problem 2311
class Solution: def longestSubsequence(self, s: str, k: int) -&amp;gt; int: res = v = 0 for c in s[::-1]: if c == &amp;#34;0&amp;#34;: res += 1 elif res &amp;lt; 30 and (v | 1 &amp;lt;&amp;lt; res) &amp;lt;= k: v |= 1 &amp;lt;&amp;lt; res res += 1 return res</description></item><item><title>2316. Count Unreachable Pairs of Nodes in an Undirected Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2316/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2316/</guid><description>LeetCode problem 2316
class Solution: def countPairs(self, n: int, edges: List[List[int]]) -&amp;gt; int: def dfs(i: int) -&amp;gt; int: if vis[i]: return 0 vis[i] = True return 1 + sum(dfs(j) for j in g[i]) g = [[] for _ in range(n)] for a, b in edges: g[a].append(b) g[b].append(a) vis = [False] * n res = s = 0 for i in range(n): t = dfs(i) res += s * t s += t return res</description></item><item><title>2317. Maximum XOR After Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2317/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2317/</guid><description>LeetCode problem 2317
class Solution: def maximumXOR(self, nums: List[int]) -&amp;gt; int: return reduce(or_, nums)</description></item><item><title>2320. Count Number of Ways to Place Houses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2320/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2320/</guid><description>LeetCode problem 2320
class Solution: def countHousePlacements(self, n: int) -&amp;gt; int: mod = 10**9 + 7 f = [1] * n g = [1] * n for i in range(1, n): f[i] = g[i - 1] g[i] = (f[i - 1] + g[i - 1]) % mod v = f[-1] + g[-1] return v * v % mod</description></item><item><title>2323. Find Minimum Time to Finish All Jobs II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2323/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2323/</guid><description>LeetCode problem 2323
class Solution: def minimumTime(self, jobs: List[int], workers: List[int]) -&amp;gt; int: jobs.sort() workers.sort() return max((a + b - 1) // b for a, b in zip(jobs, workers))</description></item><item><title>2326. Spiral Matrix IV</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2326/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2326/</guid><description>LeetCode problem 2326
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&amp;gt; List[List[int]]: res = [[-1] * n for _ in range(m)] i = j = p = 0 dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]] while 1: res[i][j] = head.val head = head.next if not head: break while 1: x, y = i + dirs[p][0], j + dirs[p][1] if x &amp;lt; 0 or y &amp;lt; 0 or x &amp;gt;= m or y &amp;gt;= n or ~res[x][y]: p = (p + 1) % 4 else: i, j = x, y break return res</description></item><item><title>2327. Number of People Aware of a Secret</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2327/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2327/</guid><description>LeetCode problem 2327
class Solution: def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -&amp;gt; int: m = (n &amp;lt;&amp;lt; 1) + 10 d = [0] * m cnt = [0] * m cnt[1] = 1 for i in range(1, n + 1): if cnt[i]: d[i] += cnt[i] d[i + forget] -= cnt[i] nxt = i + delay while nxt &amp;lt; i + forget: cnt[nxt] += cnt[i] nxt += 1 mod = 10**9 + 7 return sum(d[: n + 1]) % mod</description></item><item><title>2330. Valid Palindrome IV</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2330/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2330/</guid><description>LeetCode problem 2330
class Solution: def makePalindrome(self, s: str) -&amp;gt; bool: i, j = 0, len(s) - 1 cnt = 0 while i &amp;lt; j: cnt += s[i] != s[j] i, j = i + 1, j - 1 return cnt &amp;lt;= 2</description></item><item><title>2332. The Latest Time to Catch a Bus</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2332/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2332/</guid><description>LeetCode problem 2332
class Solution: def latestTimeCatchTheBus( self, buses: List[int], passengers: List[int], capacity: int ) -&amp;gt; int: buses.sort() passengers.sort() j = 0 for t in buses: c = capacity while c and j &amp;lt; len(passengers) and passengers[j] &amp;lt;= t: c, j = c - 1, j + 1 j -= 1 res = buses[-1] if c else passengers[j] while ~j and passengers[j] == res: res, j = res - 1, j - 1 return res</description></item><item><title>2333. Minimum Sum of Squared Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2333/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2333/</guid><description>LeetCode problem 2333
class Solution: def minSumSquareDiff( self, nums1: List[int], nums2: List[int], k1: int, k2: int ) -&amp;gt; int: d = [abs(a - b) for a, b in zip(nums1, nums2)] k = k1 + k2 if sum(d) &amp;lt;= k: return 0 left, right = 0, max(d) while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if sum(max(v - mid, 0) for v in d) &amp;lt;= k: right = mid else: left = mid + 1 for i, v in enumerate(d): d[i] = min(left, v) k -= max(0, v - left) for i, v in enumerate(d): if k == 0: break if v == left: k -= 1 d[i] -= 1 return sum(v * v for v in d)</description></item><item><title>2336. Smallest Number in Infinite Set</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2336/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2336/</guid><description>LeetCode problem 2336
from sortedcontainers import SortedSet class SmallestInfiniteSet: def __init__(self): self.s = SortedSet(range(1, 1001)) def popSmallest(self) -&amp;gt; int: x = self.s[0] self.s.remove(x) return x def addBack(self, num: int) -&amp;gt; None: self.s.add(num) # Your SmallestInfiniteSet object will be instantiated and called as such: # obj = SmallestInfiniteSet() # param_1 = obj.popSmallest() # obj.addBack(num)</description></item><item><title>2337. Move Pieces to Obtain a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2337/</guid><description>LeetCode problem 2337
class Solution: def canChange(self, start: str, target: str) -&amp;gt; bool: n = len(start) i = j = 0 while 1: while i &amp;lt; n and start[i] == &amp;#39;_&amp;#39;: i += 1 while j &amp;lt; n and target[j] == &amp;#39;_&amp;#39;: j += 1 if i &amp;gt;= n and j &amp;gt;= n: return True if i &amp;gt;= n or j &amp;gt;= n or start[i] != target[j]: return False if start[i] == &amp;#39;L&amp;#39; and i &amp;lt; j: return False if start[i] == &amp;#39;R&amp;#39; and i &amp;gt; j: return False i, j = i + 1, j + 1</description></item><item><title>2340. Minimum Adjacent Swaps to Make a Valid Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2340/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2340/</guid><description>LeetCode problem 2340
class Solution: def minimumSwaps(self, nums: List[int]) -&amp;gt; int: i = j = 0 for k, v in enumerate(nums): if v &amp;lt; nums[i] or (v == nums[i] and k &amp;lt; i): i = k if v &amp;gt;= nums[j] or (v == nums[j] and k &amp;gt; j): j = k return 0 if i == j else i + len(nums) - 1 - j - (i &amp;gt; j)</description></item><item><title>2342. Max Sum of a Pair With Equal Sum of Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2342/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2342/</guid><description>LeetCode problem 2342
class Solution: def maximumSum(self, nums: List[int]) -&amp;gt; int: d = defaultdict(int) res = -1 for v in nums: x, y = 0, v while y: x += y % 10 y //= 10 if x in d: res = max(res, d[x] + v) d[x] = max(d[x], v) return res</description></item><item><title>2343. Query Kth Smallest Trimmed Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2343/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2343/</guid><description>LeetCode problem 2343
class Solution: def smallestTrimmedNumbers( self, nums: List[str], queries: List[List[int]] ) -&amp;gt; List[int]: res = [] for k, trim in queries: t = sorted((v[-trim:], i) for i, v in enumerate(nums)) res.append(t[k - 1][1]) return res</description></item><item><title>2345. Finding the Number of Visible Mountains</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2345/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2345/</guid><description>LeetCode problem 2345
class Solution: def visibleMountains(self, peaks: List[List[int]]) -&amp;gt; int: arr = [(x - y, x + y) for x, y in peaks] cnt = Counter(arr) arr.sort(key=lambda x: (x[0], -x[1])) res, cur = 0, -inf for l, r in arr: if r &amp;lt;= cur: continue cur = r if cnt[(l, r)] == 1: res += 1 return res</description></item><item><title>2348. Number of Zero-Filled Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2348/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2348/</guid><description>LeetCode problem 2348
class Solution: def zeroFilledSubarray(self, nums: List[int]) -&amp;gt; int: res = cnt = 0 for v in nums: cnt = 0 if v else cnt + 1 res += cnt return res</description></item><item><title>2349. Design a Number Container System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2349/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2349/</guid><description>LeetCode problem 2349
from sortedcontainers import SortedSet class NumberContainers: def __init__(self): self.mp = {} self.t = defaultdict(SortedSet) def change(self, index: int, number: int) -&amp;gt; None: if index in self.mp: v = self.mp[index] self.t[v].remove(index) self.mp[index] = number self.t[number].add(index) def find(self, number: int) -&amp;gt; int: s = self.t[number] return s[0] if s else -1 # Your NumberContainers object will be instantiated and called as such: # obj = NumberContainers() # obj.change(index,number) # param_2 = obj.find(number)</description></item><item><title>2352. Equal Row and Column Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2352/</guid><description>LeetCode problem 2352
Problem Statement You are given a square grid of integers, specifically a 0-indexed n×n matrix named grid. The objective is to determine how many pairs of rows and columns in the grid are identical in terms of their content and order.
To elucidate, if row $r_i$ and column $c_j$ have the same integers in the exact same sequence, they are considered an &amp;ldquo;equal&amp;rdquo; pair. The challenge is to count all such pairs in the given matrix.</description></item><item><title>2353. Design a Food Rating System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2353/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2353/</guid><description>LeetCode problem 2353
from sortedcontainers import SortedSet class FoodRatings: def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]): self.mp = {} self.t = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1]))) for a, b, c in zip(foods, cuisines, ratings): self.mp[a] = (b, c) self.t[b].add((c, a)) def changeRating(self, food: str, newRating: int) -&amp;gt; None: b, c = self.mp[food] self.mp[food] = (b, newRating) self.t[b].remove((c, food)) self.t[b].add((newRating, food)) def highestRated(self, cuisine: str) -&amp;gt; str: return self.t[cuisine][0][1] # Your FoodRatings object will be instantiated and called as such: # obj = FoodRatings(foods, cuisines, ratings) # obj.</description></item><item><title>2358. Maximum Number of Groups Entering a Competition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2358/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2358/</guid><description>LeetCode problem 2358
class Solution: def maximumGroups(self, grades: List[int]) -&amp;gt; int: n = len(grades) return bisect_right(range(n + 1), n * 2, key=lambda x: x * x + x) - 1</description></item><item><title>2359. Find Closest Node to Given Two Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2359/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2359/</guid><description>LeetCode problem 2359
class Solution: def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -&amp;gt; int: def f(i): dist = [inf] * n dist[i] = 0 q = deque([i]) while q: i = q.popleft() for j in g[i]: if dist[j] == inf: dist[j] = dist[i] + 1 q.append(j) return dist g = defaultdict(list) for i, j in enumerate(edges): if j != -1: g[i].append(j) n = len(edges) d1 = f(node1) d2 = f(node2) res, d = -1, inf for i, (a, b) in enumerate(zip(d1, d2)): if (t := max(a, b)) &amp;lt; d: d = t res = i return res</description></item><item><title>2364. Count Number of Bad Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2364/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2364/</guid><description>LeetCode problem 2364
class Solution: def countBadPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter() res = 0 for i, x in enumerate(nums): res += i - cnt[i - x] cnt[i - x] += 1 return res</description></item><item><title>2365. Task Scheduler II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2365/</guid><description>LeetCode problem 2365
class Solution: def taskSchedulerII(self, tasks: List[int], space: int) -&amp;gt; int: day = defaultdict(int) res = 0 for task in tasks: res += 1 res = max(res, day[task]) day[task] = res + space + 1 return res</description></item><item><title>2368. Reachable Nodes With Restrictions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2368/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2368/</guid><description>LeetCode problem 2368
class Solution: def reachableNodes( self, n: int, edges: List[List[int]], restricted: List[int] ) -&amp;gt; int: s = set(restricted) g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) q = deque([0]) vis = [False] * n for v in restricted: vis[v] = True res = 0 while q: i = q.popleft() res += 1 vis[i] = True for j in g[i]: if not vis[j]: q.append(j) return res</description></item><item><title>2369. Check if There is a Valid Partition For The Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2369/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2369/</guid><description>LeetCode problem 2369
class Solution: def validPartition(self, nums: List[int]) -&amp;gt; bool: n = len(nums) dp = [False] * (n + 1) dp[0] = True for i in range(2, n + 1): if nums[i - 1] == nums[i - 2]: dp[i] = dp[i] or dp[i - 2] if i &amp;gt; 2 and nums[i - 1] == nums[i - 2] == nums[i - 3]: dp[i] = dp[i] or dp[i - 3] if ( i &amp;gt; 2 and nums[i - 1] - nums[i - 2] == 1 and nums[i - 2] - nums[i - 3] == 1 ): dp[i] = dp[i] or dp[i - 3] return dp[-1]</description></item><item><title>2370. Longest Ideal Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2370/</guid><description>LeetCode problem 2370
class Solution: def longestIdealString(self, s: str, k: int) -&amp;gt; int: n = len(s) res = 1 dp = [1] * n d = {s[0]: 0} for i in range(1, n): a = ord(s[i]) for b in ascii_lowercase: if abs(a - ord(b)) &amp;gt; k: continue if b in d: dp[i] = max(dp[i], dp[d[b]] + 1) d[s[i]] = i return max(dp)</description></item><item><title>2374. Node With Highest Edge Score</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2374/</guid><description>LeetCode problem 2374
class Solution: def edgeScore(self, edges: List[int]) -&amp;gt; int: cnt = Counter() for i, v in enumerate(edges): cnt[v] += i res = 0 for i in range(len(edges)): if cnt[res] &amp;lt; cnt[i]: res = i return res</description></item><item><title>2375. Construct Smallest Number From DI String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2375/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2375/</guid><description>LeetCode problem 2375
class Solution: def smallestNumber(self, pattern: str) -&amp;gt; str: def dfs(u): nonlocal res if res: return if u == len(pattern) + 1: res = &amp;#39;&amp;#39;.join(t) return for i in range(1, 10): if not vis[i]: if u and pattern[u - 1] == &amp;#39;I&amp;#39; and int(t[-1]) &amp;gt;= i: continue if u and pattern[u - 1] == &amp;#39;D&amp;#39; and int(t[-1]) &amp;lt;= i: continue vis[i] = True t.append(str(i)) dfs(u + 1) vis[i] = False t.pop() vis = [False] * 10 t = [] res = None dfs(0) return res</description></item><item><title>2378. Choose Edges to Maximize Score in a Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2378/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2378/</guid><description>LeetCode problem 2378
class Solution: def maxScore(self, edges: List[List[int]]) -&amp;gt; int: def dfs(i): a = b = t = 0 for j, w in g[i]: x, y = dfs(j) a += y b += y t = max(t, x - y + w) b += t return a, b g = defaultdict(list) for i, (p, w) in enumerate(edges[1:], 1): g[p].append((i, w)) return dfs(0)[1]</description></item><item><title>2380. Time Needed to Rearrange a Binary String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2380/</guid><description>LeetCode problem 2380
class Solution: def secondsToRemoveOccurrences(self, s: str) -&amp;gt; int: res = cnt = 0 for c in s: if c == &amp;#39;0&amp;#39;: cnt += 1 elif cnt: res = max(res + 1, cnt) return res</description></item><item><title>2381. Shifting Letters II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2381/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2381/</guid><description>LeetCode problem 2381
class Solution: def shiftingLetters(self, s: str, shifts: List[List[int]]) -&amp;gt; str: n = len(s) d = [0] * (n + 1) for i, j, v in shifts: if v == 0: v = -1 d[i] += v d[j + 1] -= v for i in range(1, n + 1): d[i] += d[i - 1] return &amp;#39;&amp;#39;.join( chr(ord(&amp;#39;a&amp;#39;) + (ord(s[i]) - ord(&amp;#39;a&amp;#39;) + d[i] + 26) % 26) for i in range(n) )</description></item><item><title>2384. Largest Palindromic Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2384/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2384/</guid><description>LeetCode problem 2384
class Solution: def largestPalindromic(self, num: str) -&amp;gt; str: cnt = Counter(num) res = &amp;#39;&amp;#39; for i in range(9, -1, -1): v = str(i) if cnt[v] % 2: res = v cnt[v] -= 1 break for i in range(10): v = str(i) if cnt[v]: cnt[v] //= 2 s = cnt[v] * v res = s + res + s return res.strip(&amp;#39;0&amp;#39;) or &amp;#39;0&amp;#39;</description></item><item><title>2385. Amount of Time for Binary Tree to Be Infected</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2385/</guid><description>LeetCode problem 2385
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def amountOfTime(self, root: Optional[TreeNode], start: int) -&amp;gt; int: def dfs(root): if root is None: return if root.left: g[root.val].append(root.left.val) g[root.left.val].append(root.val) if root.right: g[root.val].append(root.right.val) g[root.right.val].append(root.val) dfs(root.left) dfs(root.right) def dfs2(i, fa): res = 0 for j in g[i]: if j != fa: res = max(res, 1 + dfs2(j, i)) return res g = defaultdict(list) dfs(root) return dfs2(start, -1)</description></item><item><title>2387. Median of a Row Wise Sorted Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2387/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2387/</guid><description>LeetCode problem 2387
class Solution: def matrixMedian(self, grid: List[List[int]]) -&amp;gt; int: def count(x): return sum(bisect_right(row, x) for row in grid) m, n = len(grid), len(grid[0]) target = (m * n + 1) &amp;gt;&amp;gt; 1 return bisect_left(range(10**6 + 1), target, key=count)</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2391. Minimum Amount of Time to Collect Garbage</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2391/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2391/</guid><description>LeetCode problem 2391
class Solution: def garbageCollection(self, garbage: List[str], travel: List[int]) -&amp;gt; int: def f(x: str) -&amp;gt; int: res = 0 st = 0 for i, s in enumerate(garbage): if t := s.count(x): res += t + st st = 0 if i &amp;lt; len(travel): st += travel[i] return res return f(&amp;#39;M&amp;#39;) + f(&amp;#39;P&amp;#39;) + f(&amp;#39;G&amp;#39;)</description></item><item><title>2393. Count Strictly Increasing Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2393/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2393/</guid><description>LeetCode problem 2393
class Solution: def countSubarrays(self, nums: List[int]) -&amp;gt; int: res = pre = cnt = 0 for x in nums: if pre &amp;lt; x: cnt += 1 else: cnt = 1 pre = x res += cnt return res</description></item><item><title>2396. Strictly Palindromic Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2396/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2396/</guid><description>LeetCode problem 2396
class Solution: def isStrictlyPalindromic(self, n: int) -&amp;gt; bool: return False</description></item><item><title>2397. Maximum Rows Covered by Columns</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2397/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2397/</guid><description>LeetCode problem 2397
class Solution: def maximumRows(self, matrix: List[List[int]], numSelect: int) -&amp;gt; int: rows = [] for row in matrix: mask = reduce(or_, (1 &amp;lt;&amp;lt; j for j, x in enumerate(row) if x), 0) rows.append(mask) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(matrix[0])): if mask.bit_count() != numSelect: continue t = sum((x &amp;amp; mask) == x for x in rows) res = max(res, t) return res</description></item><item><title>2400. Number of Ways to Reach a Position After Exactly k Steps</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2400/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2400/</guid><description>LeetCode problem 2400
class Solution: def numberOfWays(self, startPos: int, endPos: int, k: int) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if i &amp;gt; j or j &amp;lt; 0: return 0 if j == 0: return 1 if i == 0 else 0 return (dfs(i + 1, j - 1) + dfs(abs(i - 1), j - 1)) % mod mod = 10**9 + 7 return dfs(abs(startPos - endPos), k)</description></item><item><title>2401. Longest Nice Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2401/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2401/</guid><description>LeetCode problem 2401
class Solution: def longestNiceSubarray(self, nums: List[int]) -&amp;gt; int: res = j = mask = 0 for i, x in enumerate(nums): while mask &amp;amp; x: mask ^= nums[j] j += 1 res = max(res, i - j + 1) mask |= x return res</description></item><item><title>2405. Optimal Partition of String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2405/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2405/</guid><description>LeetCode problem 2405
class Solution: def partitionString(self, s: str) -&amp;gt; int: res, v = 1, 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if (v &amp;gt;&amp;gt; i) &amp;amp; 1: v = 0 res += 1 v |= 1 &amp;lt;&amp;lt; i return res</description></item><item><title>2406. Divide Intervals Into Minimum Number of Groups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2406/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2406/</guid><description>LeetCode problem 2406
class Solution: def minGroups(self, intervals: List[List[int]]) -&amp;gt; int: h = [] for a, b in sorted(intervals): if h and h[0] &amp;lt; a: heappop(h) heappush(h, b) return len(h)</description></item><item><title>2408. Design SQL</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2408/</guid><description>LeetCode problem 2408
class SQL: def __init__(self, names: List[str], columns: List[int]): self.tables = defaultdict(list) def insertRow(self, name: str, row: List[str]) -&amp;gt; None: self.tables[name].append(row) def deleteRow(self, name: str, rowId: int) -&amp;gt; None: pass def selectCell(self, name: str, rowId: int, columnId: int) -&amp;gt; str: return self.tables[name][rowId - 1][columnId - 1] # Your SQL object will be instantiated and called as such: # obj = SQL(names, columns) # obj.insertRow(name,row) # obj.deleteRow(name,rowId) # param_3 = obj.selectCell(name,rowId,columnId)</description></item><item><title>2410. Maximum Matching of Players With Trainers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2410/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2410/</guid><description>LeetCode problem 2410
class Solution: def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -&amp;gt; int: players.sort() trainers.sort() res = j = 0 for p in players: while j &amp;lt; len(trainers) and trainers[j] &amp;lt; p: j += 1 if j &amp;lt; len(trainers): res += 1 j += 1 return res</description></item><item><title>2411. Smallest Subarrays With Maximum Bitwise OR</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2411/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2411/</guid><description>LeetCode problem 2411
class Solution: def smallestSubarrays(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n f = [-1] * 32 for i in range(n - 1, -1, -1): t = 1 for j in range(32): if (nums[i] &amp;gt;&amp;gt; j) &amp;amp; 1: f[j] = i elif f[j] != -1: t = max(t, f[j] - i + 1) res[i] = t return res</description></item><item><title>2414. Length of the Longest Alphabetical Continuous Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2414/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2414/</guid><description>LeetCode problem 2414
class Solution: def longestContinuousSubstring(self, s: str) -&amp;gt; int: res = 0 i, j = 0, 1 while j &amp;lt; len(s): res = max(res, j - i) if ord(s[j]) - ord(s[j - 1]) != 1: i = j j += 1 res = max(res, j - i) return res</description></item><item><title>2415. Reverse Odd Levels of Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2415/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2415/</guid><description>LeetCode problem 2415
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def reverseOddLevels(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: q = deque([root]) i = 0 while q: if i &amp;amp; 1: l, r = 0, len(q) - 1 while l &amp;lt; r: q[l].val, q[r].val = q[r].val, q[l].val l, r = l + 1, r - 1 for _ in range(len(q)): node = q.</description></item><item><title>2417. Closest Fair Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2417/</guid><description>LeetCode problem 2417
class Solution: def closestFair(self, n: int) -&amp;gt; int: a = b = k = 0 t = n while t: if (t % 10) &amp;amp; 1: a += 1 else: b += 1 t //= 10 k += 1 if k &amp;amp; 1: x = 10**k y = int(&amp;#39;1&amp;#39; * (k &amp;gt;&amp;gt; 1) or &amp;#39;0&amp;#39;) return x + y if a == b: return n return self.closestFair(n + 1)</description></item><item><title>2419. Longest Subarray With Maximum Bitwise AND</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2419/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2419/</guid><description>LeetCode problem 2419
class Solution: def longestSubarray(self, nums: List[int]) -&amp;gt; int: mx = max(nums) res = cnt = 0 for v in nums: if v == mx: cnt += 1 res = max(res, cnt) else: cnt = 0 return res</description></item><item><title>2420. Find All Good Indices</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2420/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2420/</guid><description>LeetCode problem 2420
class Solution: def goodIndices(self, nums: List[int], k: int) -&amp;gt; List[int]: n = len(nums) decr = [1] * (n + 1) incr = [1] * (n + 1) for i in range(2, n - 1): if nums[i - 1] &amp;lt;= nums[i - 2]: decr[i] = decr[i - 1] + 1 for i in range(n - 3, -1, -1): if nums[i + 1] &amp;lt;= nums[i + 2]: incr[i] = incr[i + 1] + 1 return [i for i in range(k, n - k) if decr[i] &amp;gt;= k and incr[i] &amp;gt;= k]</description></item><item><title>2422. Merge Operations to Turn Array Into a Palindrome</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2422/</guid><description>LeetCode problem 2422
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: i, j = 0, len(nums) - 1 a, b = nums[i], nums[j] res = 0 while i &amp;lt; j: if a &amp;lt; b: i += 1 a += nums[i] res += 1 elif b &amp;lt; a: j -= 1 b += nums[j] res += 1 else: i, j = i + 1, j - 1 a, b = nums[i], nums[j] return res</description></item><item><title>2424. Longest Uploaded Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2424/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2424/</guid><description>LeetCode problem 2424
class LUPrefix: def __init__(self, n: int): self.r = 0 self.s = set() def upload(self, video: int) -&amp;gt; None: self.s.add(video) while self.r + 1 in self.s: self.r += 1 def longest(self) -&amp;gt; int: return self.r # Your LUPrefix object will be instantiated and called as such: # obj = LUPrefix(n) # obj.upload(video) # param_2 = obj.longest()</description></item><item><title>2425. Bitwise XOR of All Pairings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2425/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2425/</guid><description>LeetCode problem 2425
class Solution: def xorAllNums(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: res = 0 if len(nums2) &amp;amp; 1: for v in nums1: res ^= v if len(nums1) &amp;amp; 1: for v in nums2: res ^= v return res</description></item><item><title>2428. Maximum Sum of an Hourglass</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2428/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2428/</guid><description>LeetCode problem 2428
class Solution: def maxSum(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) res = 0 for i in range(1, m - 1): for j in range(1, n - 1): s = -grid[i][j - 1] - grid[i][j + 1] s += sum( grid[x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) ) res = max(res, s) return res</description></item><item><title>2429. Minimize XOR</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2429/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2429/</guid><description>LeetCode problem 2429
class Solution: def minimizeXor(self, num1: int, num2: int) -&amp;gt; int: cnt1 = num1.bit_count() cnt2 = num2.bit_count() while cnt1 &amp;gt; cnt2: num1 &amp;amp;= num1 - 1 cnt1 -= 1 while cnt1 &amp;lt; cnt2: num1 |= num1 + 1 cnt1 += 1 return num1</description></item><item><title>2431. Maximize Total Tastiness of Purchased Fruits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2431/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2431/</guid><description>LeetCode problem 2431
class Solution: def maxTastiness( self, price: List[int], tastiness: List[int], maxAmount: int, maxCoupons: int ) -&amp;gt; int: @cache def dfs(i, j, k): if i == len(price): return 0 res = dfs(i + 1, j, k) if j &amp;gt;= price[i]: res = max(res, dfs(i + 1, j - price[i], k) + tastiness[i]) if j &amp;gt;= price[i] // 2 and k: res = max(res, dfs(i + 1, j - price[i] // 2, k - 1) + tastiness[i]) return res return dfs(0, maxAmount, maxCoupons)</description></item><item><title>2840. Check if Strings Can be Made Equal With Operations II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2840/</guid><description>LeetCode Problem 2840
Problem Statement You are given two strings s1 and s2, both of length n, consisting of lowercase English letters. You can apply certain operations to make them equal. The question is, is it possible?
Naive Solution A naive approach would be to try all possible swap operations and compare the two strings at each step, which would be highly inefficient.
Hints &amp;amp; Tips Observe that swapping can only occur at indices i and j where j - i is even.</description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2841/</guid><description>LeetCode Problem 2841
Problem Statement You are given an integer array nums and two positive integers m and k.
The task is to return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray is almost unique if it contains at least m pairwise distinct elements.
Naive Solution A naive solution would be to generate all the possible subarrays of length k and check each one to see if it is almost unique and what its sum is.</description></item><item><title>2844. Minimum Operations to Make a Special Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2844/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2844/</guid><description>LeetCode problem 2844
Problem Statement You are given a 0-indexed string num representing a non-negative integer. In one operation, you can pick any digit of num and delete it. Note that if you delete all the digits of num, num becomes 0.
Return the minimum number of operations required to make num special. An integer x is considered special if it is divisible by 25.
Naive Solution A naive approach to solving this problem might involve recursively generating all possible substrings of the input string, checking each one for divisibility by 25.</description></item><item><title>2849. Determine if a Cell Is Reachable at a Given Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2849/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2849/</guid><description>LeetCode problem 2849
Problem Statement You are given starting coordinates (sx, sy) and final coordinates (fx, fy) on a 2D infinite grid. Starting from the initial position, you can move to any of the 8 adjacent cells in one second. The challenge is to determine if you can reach the final cell (fx, fy) in exactly t seconds.
Naive Solution A naive approach would be to use a recursive function to navigate the grid from the starting point (sx, sy) and attempt to reach the target (fx, fy) in t seconds.</description></item><item><title>2856. Minimum Array Length After Pair Removals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2856/</link><pubDate>Sat, 16 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2856/</guid><description>LeetCode problem 2856
Problem Statement Given a 0-indexed sorted array of integers nums, you can perform a specific operation an unlimited number of times:
Choose two indices, i and j, where i &amp;lt; j and nums[i] &amp;lt; nums[j]. Remove the elements at indices i and j from nums. The remaining elements retain their original order and the array is re-indexed. The task is to determine and return the smallest possible length of nums after executing the operation as many times as you wish.</description></item><item><title>2971. Find Polygon With the Largest Perimeter</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2971/</guid><description>LeetCode problem 2971
class Solution: def largestPerimeter(self, nums: List[int]) -&amp;gt; int: nums.sort() s = list(accumulate(nums, initial=0)) res = -1 for k in range(3, len(nums) + 1): if s[k - 1] &amp;gt; nums[k - 1]: res = max(res, s[k]) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2961/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2961/</guid><description>class Solution: def getGoodIndices(self, variables: List[List[int]], target: int) -&amp;gt; List[int]: return [ i for i, (a, b, c, m) in enumerate(variables) if pow(pow(a, b, 10), c, m) == target ]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2962/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2962/</guid><description>class Solution: def countSubarrays(self, nums: List[int], k: int) -&amp;gt; int: mx = max(nums) n = len(nums) res = cnt = j = 0 for x in nums: while j &amp;lt; n and cnt &amp;lt; k: cnt += nums[j] == mx j += 1 if cnt &amp;lt; k: break res += n - j + 1 cnt -= x == mx return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2964/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2964/</guid><description>class Solution: def divisibleTripletCount(self, nums: List[int], d: int) -&amp;gt; int: cnt = defaultdict(int) res, n = 0, len(nums) for j in range(n): for k in range(j + 1, n): x = (d - (nums[j] + nums[k]) % d) % d res += cnt[x] cnt[nums[j] % d] += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2966/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2966/</guid><description>class Solution: def divideArray(self, nums: List[int], k: int) -&amp;gt; List[List[int]]: nums.sort() res = [] n = len(nums) for i in range(0, n, 3): t = nums[i : i + 3] if t[2] - t[0] &amp;gt; k: return [] res.append(t) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2967/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2967/</guid><description>ps = [] for i in range(1, 10**5 + 1): s = str(i) t1 = s[::-1] t2 = s[:-1][::-1] ps.append(int(s + t1)) ps.append(int(s + t2)) ps.sort() class Solution: def minimumCost(self, nums: List[int]) -&amp;gt; int: def f(x: int) -&amp;gt; int: return sum(abs(v - x) for v in nums) nums.sort() i = bisect_left(ps, nums[len(nums) // 2]) return min(f(ps[j]) for j in range(i - 1, i + 2) if 0 &amp;lt;= j &amp;lt; len(ps))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2975/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2975/</guid><description>class Solution: def maximizeSquareArea( self, m: int, n: int, hFences: List[int], vFences: List[int] ) -&amp;gt; int: def f(nums: List[int], k: int) -&amp;gt; Set[int]: nums.extend([1, k]) nums.sort() return {b - a for a, b in combinations(nums, 2)} mod = 10**9 + 7 hs = f(hFences, m) vs = f(vFences, n) res = max(hs &amp;amp; vs, default=0) return res**2 % mod if res else -1</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2976/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2976/</guid><description>class Solution: def minimumCost( self, source: str, target: str, original: List[str], changed: List[str], cost: List[int], ) -&amp;gt; int: g = [[inf] * 26 for _ in range(26)] for i in range(26): g[i][i] = 0 for x, y, z in zip(original, changed, cost): x = ord(x) - ord(&amp;#39;a&amp;#39;) y = ord(y) - ord(&amp;#39;a&amp;#39;) g[x][y] = min(g[x][y], z) for k in range(26): for i in range(26): for j in range(26): g[i][j] = min(g[i][j], g[i][k] + g[k][j]) res = 0 for a, b in zip(source, target): if a !</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2979/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2979/</guid><description>class Solution: def mostExpensiveItem(self, primeOne: int, primeTwo: int) -&amp;gt; int: return primeOne * primeTwo - primeOne - primeTwo</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2981/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2981/</guid><description>class Solution: def maximumLength(self, s: str) -&amp;gt; int: def check(x: int) -&amp;gt; bool: cnt = defaultdict(int) i = 0 while i &amp;lt; n: j = i + 1 while j &amp;lt; n and s[j] == s[i]: j += 1 cnt[s[i]] += max(0, j - i - x + 1) i = j return max(cnt.values()) &amp;gt;= 3 n = len(s) l, r = 0, n while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 if check(mid): l = mid else: r = mid - 1 return -1 if l == 0 else l</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2982/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2982/</guid><description>class Solution: def maximumLength(self, s: str) -&amp;gt; int: def check(x: int) -&amp;gt; bool: cnt = defaultdict(int) i = 0 while i &amp;lt; n: j = i + 1 while j &amp;lt; n and s[j] == s[i]: j += 1 cnt[s[i]] += max(0, j - i - x + 1) i = j return max(cnt.values()) &amp;gt;= 3 n = len(s) l, r = 0, n while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 if check(mid): l = mid else: r = mid - 1 return -1 if l == 0 else l</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2992/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2992/</guid><description>class Solution: def selfDivisiblePermutationCount(self, n: int) -&amp;gt; int: f = [0] * (1 &amp;lt;&amp;lt; n) f[0] = 1 for mask in range(1 &amp;lt;&amp;lt; n): i = mask.bit_count() for j in range(1, n + 1): if (mask &amp;gt;&amp;gt; (j - 1) &amp;amp; 1) == 1 and (i % j == 0 or j % i == 0): f[mask] += f[mask ^ (1 &amp;lt;&amp;lt; (j - 1))] return f[-1]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2997/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2997/</guid><description>class Solution: def minOperations(self, nums: List[int], k: int) -&amp;gt; int: return reduce(xor, nums, k).bit_count()</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2998/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/2998/</guid><description>class Solution: def minimumOperationsToMakeEqual(self, x: int, y: int) -&amp;gt; int: @cache def dfs(x: int) -&amp;gt; int: if y &amp;gt;= x: return y - x res = x - y res = min(res, x % 5 + 1 + dfs(x // 5)) res = min(res, 5 - x % 5 + 1 + dfs(x // 5 + 1)) res = min(res, x % 11 + 1 + dfs(x // 11)) res = min(res, 11 - x % 11 + 1 + dfs(x // 11 + 1)) return res return dfs(x)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3001/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3001/</guid><description>class Solution: def minMovesToCaptureTheQueen( self, a: int, b: int, c: int, d: int, e: int, f: int ) -&amp;gt; int: def check(dirs, sx, sy, bx, by) -&amp;gt; bool: for dx, dy in pairwise(dirs): for k in range(1, 8): x = sx + dx * k y = sy + dy * k if not (1 &amp;lt;= x &amp;lt;= 8 and 1 &amp;lt;= y &amp;lt;= 8) or (x, y) == (bx, by): break if (x, y) == (e, f): return True return False dirs1 = (-1, 0, 1, 0, -1) dirs2 = (-1, 1, 1, -1, -1) return 1 if check(dirs1, a, b, c, d) or check(dirs2, c, d, a, b) else 2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3002/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3002/</guid><description>class Solution: def maximumSetSize(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: s1 = set(nums1) s2 = set(nums2) n = len(nums1) a = min(len(s1 - s2), n // 2) b = min(len(s2 - s1), n // 2) return min(a + b + len(s1 &amp;amp; s2), n)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3004/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3004/</guid><description>class Solution: def maximumSubtreeSize(self, edges: List[List[int]], colors: List[int]) -&amp;gt; int: def dfs(a: int, fa: int) -&amp;gt; bool: ok = True for b in g[a]: if b != fa: t = dfs(b, a) ok = ok and colors[a] == colors[b] and t size[a] += size[b] if ok: nonlocal res res = max(res, size[a]) return ok n = len(edges) + 1 g = [[] for _ in range(n)] size = [1] * n for a, b in edges: g[a].append(b) g[b].append(a) res = 0 dfs(0, -1) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3006/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3006/</guid><description>class Solution: def beautifulIndices(self, s: str, a: str, b: str, k: int) -&amp;gt; List[int]: def build_prefix_function(pattern): prefix_function = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while j &amp;gt; 0 and pattern[i] != pattern[j]: j = prefix_function[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_function[i] = j return prefix_function def kmp_search(pattern, text, prefix_function): occurrences = [] j = 0 for i in range(len(text)): while j &amp;gt; 0 and text[i] != pattern[j]: j = prefix_function[j - 1] if text[i] == pattern[j]: j += 1 if j == len(pattern): occurrences.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3007/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3007/</guid><description>class Solution: def findMaximumNumber(self, k: int, x: int) -&amp;gt; int: @cache def dfs(pos, limit, cnt): if pos == 0: return cnt res = 0 up = (self.num &amp;gt;&amp;gt; (pos - 1) &amp;amp; 1) if limit else 1 for i in range(up + 1): res += dfs(pos - 1, limit and i == up, cnt + (i == 1 and pos % x == 0)) return res l, r = 1, 10**18 while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 self.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3011/</guid><description>class Solution: def canSortArray(self, nums: List[int]) -&amp;gt; bool: pre_mx = -inf i, n = 0, len(nums) while i &amp;lt; n: j = i + 1 cnt = nums[i].bit_count() mi = mx = nums[i] while j &amp;lt; n and nums[j].bit_count() == cnt: mi = min(mi, nums[j]) mx = max(mx, nums[j]) j += 1 if pre_mx &amp;gt; mi: return False pre_mx = mx i = j return True</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3012/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3012/</guid><description>class Solution: def minimumArrayLength(self, nums: List[int]) -&amp;gt; int: mi = min(nums) if any(x % mi for x in nums): return 1 return (nums.count(mi) + 1) // 2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3015/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3015/</guid><description>class Solution: def countOfPairs(self, n: int, x: int, y: int) -&amp;gt; List[int]: x, y = x - 1, y - 1 res = [0] * n for i in range(n): for j in range(i + 1, n): a = j - i b = abs(i - x) + 1 + abs(j - y) c = abs(i - y) + 1 + abs(j - x) res[min(a, b, c) - 1] += 2 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3016/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3016/</guid><description>class Solution: def minimumPushes(self, word: str) -&amp;gt; int: cnt = Counter(word) res = 0 for i, x in enumerate(sorted(cnt.values(), reverse=True)): res += (i // 8 + 1) * x return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3020/</guid><description>class Solution: def maximumLength(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) res = cnt[1] - (cnt[1] % 2 ^ 1) del cnt[1] for x in cnt: t = 0 while cnt[x] &amp;gt; 1: x = x * x t += 2 t += 1 if cnt[x] else -1 res = max(res, t) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3021/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3021/</guid><description>class Solution: def flowerGame(self, n: int, m: int) -&amp;gt; int: return (n * m) // 2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3023/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3023/</guid><description># Definition for an infinite stream. # class InfiniteStream: # def next(self) -&amp;gt; int: # pass class Solution: def findPattern( self, stream: Optional[&amp;#34;InfiniteStream&amp;#34;], pattern: List[int] ) -&amp;gt; int: a = b = 0 m = len(pattern) half = m &amp;gt;&amp;gt; 1 mask1 = (1 &amp;lt;&amp;lt; half) - 1 mask2 = (1 &amp;lt;&amp;lt; (m - half)) - 1 for i in range(half): a |= pattern[i] &amp;lt;&amp;lt; (half - 1 - i) for i in range(half, m): b |= pattern[i] &amp;lt;&amp;lt; (m - 1 - i) x = y = 0 for i in count(1): v = stream.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3025/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3025/</guid><description>class Solution: def numberOfPairs(self, points: List[List[int]]) -&amp;gt; int: points.sort(key=lambda x: (x[0], -x[1])) res = 0 for i, (_, y1) in enumerate(points): max_y = -inf for _, y2 in points[i + 1 :]: if max_y &amp;lt; y2 &amp;lt;= y1: max_y = y2 res += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3026/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3026/</guid><description>class Solution: def maximumSubarraySum(self, nums: List[int], k: int) -&amp;gt; int: res = -inf p = {nums[0]: 0} s, n = 0, len(nums) for i, x in enumerate(nums): s += x if x - k in p: res = max(res, s - p[x - k]) if x + k in p: res = max(res, s - p[x + k]) if i + 1 &amp;lt; n and (nums[i + 1] not in p or p[nums[i + 1]] &amp;gt; s): p[nums[i + 1]] = s return 0 if res == -inf else res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3029/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3029/</guid><description>class Hashing: __slots__ = [&amp;#34;mod&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;p&amp;#34;] def __init__(self, s: str, base: int, mod: int): self.mod = mod self.h = [0] * (len(s) + 1) self.p = [1] * (len(s) + 1) for i in range(1, len(s) + 1): self.h[i] = (self.h[i - 1] * base + ord(s[i - 1])) % mod self.p[i] = (self.p[i - 1] * base) % mod def query(self, l: int, r: int) -&amp;gt; int: return (self.h[r] - self.h[l - 1] * self.p[r - l + 1]) % self.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3030/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3030/</guid><description>class Solution: def resultGrid(self, image: List[List[int]], threshold: int) -&amp;gt; List[List[int]]: n, m = len(image), len(image[0]) res = [[0] * m for _ in range(n)] ct = [[0] * m for _ in range(n)] for i in range(n - 2): for j in range(m - 2): region = True for k in range(3): for l in range(2): region &amp;amp;= ( abs(image[i + k][j + l] - image[i + k][j + l + 1]) &amp;lt;= threshold ) for k in range(2): for l in range(3): region &amp;amp;= ( abs(image[i + k][j + l] - image[i + k + 1][j + l]) &amp;lt;= threshold ) if region: tot = 0 for k in range(3): for l in range(3): tot += image[i + k][j + l] for k in range(3): for l in range(3): ct[i + k][j + l] += 1 res[i + k][j + l] += tot // 9 for i in range(n): for j in range(m): if ct[i][j] == 0: res[i][j] = image[i][j] else: res[i][j] //= ct[i][j] return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3034/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3034/</guid><description>class Solution: def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -&amp;gt; int: def f(a: int, b: int) -&amp;gt; int: return 0 if a == b else (1 if a &amp;lt; b else -1) res = 0 for i in range(len(nums) - len(pattern)): res += all( f(nums[i + k], nums[i + k + 1]) == p for k, p in enumerate(pattern) ) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3035/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/3035/</guid><description>class Solution: def maxPalindromesAfterOperations(self, words: List[str]) -&amp;gt; int: s = mask = 0 for w in words: s += len(w) for c in w: mask ^= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) s -= mask.bit_count() words.sort(key=len) res = 0 for w in words: s -= len(w) // 2 * 2 if s &amp;lt; 0: break res += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/494/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/494/</guid><description>class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: @cache def dfs(i, t): if i == n: if t == target: return 1 return 0 return dfs(i + 1, t + nums[i]) + dfs(i + 1, t - nums[i]) res, n = 0, len(nums) return dfs(0, 0)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/497/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/497/</guid><description>class Solution: def __init__(self, rects: List[List[int]]): self.rects = rects self.s = [0] * len(rects) for i, (x1, y1, x2, y2) in enumerate(rects): self.s[i] = self.s[i - 1] + (x2 - x1 + 1) * (y2 - y1 + 1) def pick(self) -&amp;gt; List[int]: v = random.randint(1, self.s[-1]) idx = bisect_left(self.s, v) x1, y1, x2, y2 = self.rects[idx] return [random.randint(x1, x2), random.randint(y1, y2)] # Your Solution object will be instantiated and called as such: # obj = Solution(rects) # param_1 = obj.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/498/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/498/</guid><description>class Solution: def findDiagonalOrder(self, mat: List[List[int]]) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [] for k in range(m + n - 1): t = [] i = 0 if k &amp;lt; n else k - n + 1 j = k if k &amp;lt; n else n - 1 while i &amp;lt; m and j &amp;gt;= 0: t.append(mat[i][j]) i += 1 j -= 1 if k % 2 == 0: t = t[::-1] res.extend(t) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/503/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/503/</guid><description>class Solution: def nextGreaterElements(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [-1] * n stk = [] for i in range(n * 2 - 1, -1, -1): i %= n while stk and stk[-1] &amp;lt;= nums[i]: stk.pop() if stk: res[i] = stk[-1] stk.append(nums[i]) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/505/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/505/</guid><description>class Solution: def shortestDistance( self, maze: List[List[int]], start: List[int], destination: List[int] ) -&amp;gt; int: m, n = len(maze), len(maze[0]) dirs = (-1, 0, 1, 0, -1) si, sj = start di, dj = destination q = deque([(si, sj)]) dist = [[inf] * n for _ in range(m)] dist[si][sj] = 0 while q: i, j = q.popleft() for a, b in pairwise(dirs): x, y, k = i, j, dist[i][j] while 0 &amp;lt;= x + a &amp;lt; m and 0 &amp;lt;= y + b &amp;lt; n and maze[x + a][y + b] == 0: x, y, k = x + a, y + b, k + 1 if k &amp;lt; dist[x][y]: dist[x][y] = k q.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/508/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/508/</guid><description># Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findFrequentTreeSum(self, root: TreeNode) -&amp;gt; List[int]: def dfs(root): if root is None: return 0 left, right = dfs(root.left), dfs(root.right) s = root.val + left + right counter[s] += 1 return s counter = Counter() dfs(root) mx = max(counter.values()) return [k for k, v in counter.items() if v == mx]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/510/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/510/</guid><description>&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val): self.val = val self.left = None self.right = None self.parent = None &amp;#34;&amp;#34;&amp;#34; class Solution: def inorderSuccessor(self, node: &amp;#39;Node&amp;#39;) -&amp;gt; &amp;#39;Optional[Node]&amp;#39;: if node.right: node = node.right while node.left: node = node.left return node while node.parent and node == node.parent.right: node = node.parent return node.parent</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/513/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/513/</guid><description># Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findBottomLeftValue(self, root: Optional[TreeNode]) -&amp;gt; int: def dfs(root, curr): nonlocal res, mx if root is None: return dfs(root.left, curr + 1) dfs(root.right, curr + 1) if mx &amp;lt; curr: mx = curr res = root.val res = mx = 0 dfs(root, 1) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/515/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/515/</guid><description># Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def largestValues(self, root: Optional[TreeNode]) -&amp;gt; List[int]: def dfs(root, curr): if root is None: return if curr == len(res): res.append(root.val) else: res[curr] = max(res[curr], root.val) dfs(root.left, curr + 1) dfs(root.right, curr + 1) res = [] dfs(root, 0) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/516/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/516/</guid><description>class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for j in range(1, n): for i in range(j - 1, -1, -1): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][-1]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/518/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/518/</guid><description>class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for j in range(coin, amount + 1): dp[j] += dp[j - coin] return dp[-1]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/519/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/519/</guid><description>class Solution: def __init__(self, m: int, n: int): self.m = m self.n = n self.total = m * n self.mp = {} def flip(self) -&amp;gt; List[int]: self.total -= 1 x = random.randint(0, self.total) idx = self.mp.get(x, x) self.mp[x] = self.mp.get(self.total, self.total) return [idx // self.n, idx % self.n] def reset(self) -&amp;gt; None: self.total = self.m * self.n self.mp.clear() # Your Solution object will be instantiated and called as such: # obj = Solution(m, n) # param_1 = obj.flip() # obj.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/522/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/522/</guid><description>class Solution: def findLUSlength(self, strs: List[str]) -&amp;gt; int: def check(a, b): i = j = 0 while i &amp;lt; len(a) and j &amp;lt; len(b): if a[i] == b[j]: j += 1 i += 1 return j == len(b) n = len(strs) res = -1 for i in range(n): j = 0 while j &amp;lt; n: if i == j or not check(strs[j], strs[i]): j += 1 else: break if j == n: res = max(res, len(strs[i])) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/523/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/523/</guid><description>class Solution: def checkSubarraySum(self, nums: List[int], k: int) -&amp;gt; bool: s = 0 mp = {0: -1} for i, v in enumerate(nums): s += v r = s % k if r in mp and i - mp[r] &amp;gt;= 2: return True if r not in mp: mp[r] = i return False</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/524/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/524/</guid><description>class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&amp;gt; str: def check(a, b): m, n = len(a), len(b) i = j = 0 while i &amp;lt; m and j &amp;lt; n: if a[i] == b[j]: j += 1 i += 1 return j == n res = &amp;#39;&amp;#39; for a in dictionary: if check(s, a) and (len(res) &amp;lt; len(a) or (len(res) == len(a) and res &amp;gt; a)): res = a return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/525/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/525/</guid><description>class Solution: def findMaxLength(self, nums: List[int]) -&amp;gt; int: s = res = 0 mp = {0: -1} for i, v in enumerate(nums): s += 1 if v == 1 else -1 if s in mp: res = max(res, i - mp[s]) else: mp[s] = i return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/526/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/526/</guid><description>class Solution: def countArrangement(self, n: int) -&amp;gt; int: def dfs(i): nonlocal res, n if i == n + 1: res += 1 return for j in match[i]: if not vis[j]: vis[j] = True dfs(i + 1) vis[j] = False res = 0 vis = [False] * (n + 1) match = defaultdict(list) for i in range(1, n + 1): for j in range(1, n + 1): if j % i == 0 or i % j == 0: match[i].</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/528/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/528/</guid><description>class Solution: def __init__(self, w: List[int]): self.s = [0] for c in w: self.s.append(self.s[-1] + c) def pickIndex(self) -&amp;gt; int: x = random.randint(1, self.s[-1]) left, right = 1, len(self.s) - 1 while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if self.s[mid] &amp;gt;= x: right = mid else: left = mid + 1 return left - 1 # Your Solution object will be instantiated and called as such: # obj = Solution(w) # param_1 = obj.pickIndex()</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/529/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/529/</guid><description>class Solution: def updateBoard(self, board: List[List[str]], click: List[int]) -&amp;gt; List[List[str]]: def dfs(i: int, j: int): cnt = 0 for x in range(i - 1, i + 2): for y in range(j - 1, j + 2): if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and board[x][y] == &amp;#34;M&amp;#34;: cnt += 1 if cnt: board[i][j] = str(cnt) else: board[i][j] = &amp;#34;B&amp;#34; for x in range(i - 1, i + 2): for y in range(j - 1, j + 2): if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and board[x][y] == &amp;#34;E&amp;#34;: dfs(x, y) m, n = len(board), len(board[0]) i, j = click if board[i][j] == &amp;#34;M&amp;#34;: board[i][j] = &amp;#34;X&amp;#34; else: dfs(i, j) return board</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/531/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/531/</guid><description>class Solution: def findLonelyPixel(self, picture: List[List[str]]) -&amp;gt; int: m, n = len(picture), len(picture[0]) rows, cols = [0] * m, [0] * n for i in range(m): for j in range(n): if picture[i][j] == &amp;#39;B&amp;#39;: rows[i] += 1 cols[j] += 1 res = 0 for i in range(m): if rows[i] == 1: for j in range(n): if picture[i][j] == &amp;#39;B&amp;#39; and cols[j] == 1: res += 1 break return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/532/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/532/</guid><description>class Solution: def findPairs(self, nums: List[int], k: int) -&amp;gt; int: vis, res = set(), set() for v in nums: if v - k in vis: res.add(v - k) if v + k in vis: res.add(v) vis.add(v) return len(res)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/533/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/533/</guid><description>class Solution: def findBlackPixel(self, picture: List[List[str]], target: int) -&amp;gt; int: m, n = len(picture), len(picture[0]) rows = [0] * m cols = defaultdict(list) for i in range(m): for j in range(n): if picture[i][j] == &amp;#39;B&amp;#39;: rows[i] += 1 cols[j].append(i) t = [[False] * m for _ in range(m)] for i in range(m): for k in range(i, m): if i == k: t[i][k] = True else: t[i][k] = all([picture[i][j] == picture[k][j] for j in range(n)]) t[k][i] = t[i][k] res = 0 for i in range(m): if rows[i] == target: for j in range(n): if len(cols[j]) == target and all([t[i][k] for k in cols[j]]): res += 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/535/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/535/</guid><description>class Codec: def __init__(self): self.m = defaultdict() self.idx = 0 self.domain = &amp;#39;https://tinyurl.com/&amp;#39; def encode(self, longUrl: str) -&amp;gt; str: &amp;#34;&amp;#34;&amp;#34;Encodes a URL to a shortened URL.&amp;#34;&amp;#34;&amp;#34; self.idx += 1 self.m[str(self.idx)] = longUrl return f&amp;#39;{self.domain}{self.idx}&amp;#39; def decode(self, shortUrl: str) -&amp;gt; str: &amp;#34;&amp;#34;&amp;#34;Decodes a shortened URL to its original URL.&amp;#34;&amp;#34;&amp;#34; idx = shortUrl.split(&amp;#39;/&amp;#39;)[-1] return self.m[idx] # Your Codec object will be instantiated and called as such: # codec = Codec() # codec.decode(codec.encode(url))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/536/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/536/</guid><description># Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def str2tree(self, s: str) -&amp;gt; TreeNode: def dfs(s): if not s: return None p = s.find(&amp;#39;(&amp;#39;) if p == -1: return TreeNode(int(s)) root = TreeNode(int(s[:p])) start = p cnt = 0 for i in range(p, len(s)): if s[i] == &amp;#39;(&amp;#39;: cnt += 1 elif s[i] == &amp;#39;)&amp;#39;: cnt -= 1 if cnt == 0: if start == p: root.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/537/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/medium/537/</guid><description>class Solution: def complexNumberMultiply(self, num1: str, num2: str) -&amp;gt; str: a, b = map(int, num1[:-1].split(&amp;#39;+&amp;#39;)) c, d = map(int, num2[:-1].split(&amp;#39;+&amp;#39;)) return f&amp;#39;{a * c - b * d}+{a * d + c * b}i&amp;#39;</description></item></channel></rss>