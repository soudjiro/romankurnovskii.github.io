<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Easy on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/</link><description>Recent content in Easy on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Two Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1/</guid><description>LeetCode problem
Problem Statement In this problem, you&amp;rsquo;re given an array of integers nums and an integer target. Your task is to find the indices of two numbers in the array that add up to the target. The input array is guaranteed to have exactly one solution, and you can&amp;rsquo;t use the same element twice. The indices can be returned in any order.
Naive Solution A naive solution would involve using two nested loops to iterate through each pair of elements in the array and check if their sum is equal to the target.</description></item><item><title>9. Palindrome Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/9/</guid><description>LeetCode problem 9. Palindrome Number
Problem Statement Determine whether an integer is a palindrome without converting it to a string.
Naive Solution A straightforward solution might be to convert the integer to a string and check if it reads the same both ways. However, this challenge encourages solving it without such conversion.
Hints &amp;amp; Tips By reversing the number and comparing it to the original, you can determine if it&amp;rsquo;s a palindrome.
Approach Instead of converting the number to a string, we can reverse its digits using mathematical operations and then compare the reversed number to the original number.</description></item><item><title>13. Roman to Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/13/</guid><description>LeetCode problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.</description></item><item><title>14. Longest Common Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/14/</guid><description>LeetCode problem
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. First accepted Idea:
class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: strs.sort() l = strs[0] r = strs[-1] if l == r: return l res = &amp;#34;&amp;#34; for i in range(0, len(l)): if l[i] == r[i]: res += l[i] else: return res return res</description></item><item><title>20. Valid Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/20/</guid><description>LeetCode problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true First accepted Idea:</description></item><item><title>21. Merge Two Sorted Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/21/</guid><description>LeetCode problem
You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: list1 = [], list2 = [0] Output: [0] First accepted Idea:
Get smallest head. Loop and update its next.</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/26/</guid><description>LeetCode problem
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description></item><item><title>66. Plus One</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</link><pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/66/</guid><description>LeetCode problem
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;rsquo;s.
Increment the large integer by one and return the resulting array of digits.
Example 1:
Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124.</description></item><item><title>69. Sqrt(x)</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/69/</guid><description>LeetCode problem
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.
You must not use any built-in exponent function or operator.
For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2. Example 2:
Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title>70. Climbing Stairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</link><pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/70/</guid><description>LeetCode problem
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description></item><item><title>88. Merge Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</link><pubDate>Sun, 30 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/88/</guid><description>LeetCode problem
First accepted class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify nums1 in-place instead. &amp;#34;&amp;#34;&amp;#34; i = len(nums1) - n for j in nums2: nums1[i] = j i += 1 nums1.sort()</description></item><item><title>94. Binary Tree Inorder Traversal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/94/</guid><description>LeetCode problem
Given the root of a binary tree, return the inorder traversal of its nodes' values.
Example 1:
Input: root = [1,null,2,3] Output: [1,3,2] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Thoughts Don&amp;rsquo;t understand what needed. Why:
1-null-2-3 becomes 1-3-2 [1,2,5,7,8,9,10] becomes [7,2,8,1,9,5,10] In 1-null-2-3 1 becomes the first because we loop to its left node which is null, then come back and first value here is 1.</description></item><item><title>100. Same Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/100/</link><pubDate>Mon, 26 Feb 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/100/</guid><description>LeetCode 100
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&amp;gt; bool: if not p and not q: return True if not p or not q: return False if p.val != q.val: return False left = self.isSameTree(p.left, q.left) right = self.isSameTree(p.right, q.right) return left == right == True</description></item><item><title>104. Maximum Depth of Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/104/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/104/</guid><description>LeetCode задача 104
Задача Дан корень бинарного дерева. Задача состоит в том, чтобы найти его максимальную глубину. Глубина бинарного дерева определяется как максимальное количество узлов на пути от корня дерева до любого листового узла, включая сам корень.
Подсказки Бинарное дерево представляет собой иерархическую структуру, в которой каждый узел имеет максимум двух потомков: левого и правого.
Подход / Идея решения Чтобы найти максимальную глубину бинарного дерева, можно использовать рекурсивный метод. Для каждого узла дерева, максимальная глубина поддерева с этим узлом в качестве корня будет равна максимуму из глубин левого и правого поддеревьев, увеличенному на 1 (сам узел).</description></item><item><title>118. Pascal's Triangle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/118/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/118/</guid><description>LeetCode задача 118
Задача Дано целое число numRows. Верните первые numRows строк Треугольника Паскаля.
В Треугольнике Паскаля каждое число является суммой двух чисел, находящихся непосредственно над ним.
Подсказки Для построения каждой следующей строки можно использовать последнюю строку в текущей итерации. Например, если есть строка [1, 2, 1], то следующая строка начнется и закончится с 1, а числа внутри будут получены путем сложения пар чисел: 1+2 и 2+1.
Подход Для того чтобы построить Треугольник Паскаля, начнем с первой строки, состоящей только из числа 1.</description></item><item><title>136. Single Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/136/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/136/</guid><description>LeetCode problem 136
class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: d = {} for i in nums: if i in d: del d[i] else: d[i]=1 return d.popitem()[0] Consider using a bit manipulation technique, specifically XOR, to solve this problem efficiently.
The concept of XOR (exclusive OR) operation can be used cleverly here. XOR of a number with itself is 0, and the XOR of a number with 0 is the number itself. Also, XOR operation is commutative and associative, which means the order of operations does not change the result.</description></item><item><title>141. Linked List Cycle</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</link><pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/141/</guid><description>LeetCode problem 141
Problem Statement The problem asks us to determine if a given linked list contains a cycle. A cycle in a linked list occurs when a node&amp;rsquo;s next pointer points back to a previous node in the list, causing an infinite loop.
Hints &amp;amp; Tips In this problem, you can take advantage of the Floyd&amp;rsquo;s &amp;ldquo;Tortoise and Hare&amp;rdquo; cycle detection algorithm. This algorithm allows you to detect a cycle in O(1) space and O(n) time complexity, where n is the number of nodes.</description></item><item><title>160. Intersection of Two Linked Lists</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</link><pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/160/</guid><description>LeetCode problem
Solution 1 Using hashmap.
# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode): nodes = set() cur = headA while cur: nodes.add(cur) cur = cur.next cur = headB while cur: if cur in nodes: return cur cur = cur.next return None Solution 2 Initialize two pointers, one for each head. Move each pointer to the next node in its list. If a pointer reaches the end of its list, move it to the start of the other list.</description></item><item><title>171. Excel Sheet Column Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</link><pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/171/</guid><description>LeetCode problem
The column titles in an Excel sheet are designed similar to a base-26 number system. The columns start from &amp;lsquo;A&amp;rsquo; (which is 1) to &amp;lsquo;Z&amp;rsquo; (which is 26), then after &amp;lsquo;Z&amp;rsquo;, the column titles go to &amp;lsquo;AA&amp;rsquo; (which is 27), &amp;lsquo;AB&amp;rsquo; (28), and so on.
This problem is essentially asking us to convert a base-26 number (represented by uppercase English letters) to a decimal number.
That means that for each &amp;ldquo;new&amp;rdquo; index in columnTitle we already pass alphabet.</description></item><item><title>190. Reverse Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/190/</guid><description>LeetCode problem
This task involves understanding how binary representation works. An unsigned integer is a 32-bit value, where each bit represents a power of 2, from 2^0 (the least significant bit) to 2^31 (the most significant bit).
Unsigned Integers (often called &amp;ldquo;uints&amp;rdquo;) are just like integers (whole numbers) but have the property that they don&amp;rsquo;t have a + or - sign associated with them. Thus they are always non-negative (zero or positive).
Naive Solution A naive solution to this problem could involve converting the number to a binary string, reversing the string, and then converting it back to an integer.</description></item><item><title>191. Number of 1 Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/191/</guid><description>LeetCode problem
Problem Statement Given an integer value represented in binary format, we need to count the number of &amp;lsquo;1&amp;rsquo; bits in its binary representation.
Naive Solution The naive solution for this problem would be to convert the binary number into a string and then simply iterate over the string and count the number of &amp;lsquo;1&amp;rsquo;s. However, this solution is not optimal and is not taking advantage of the properties of binary numbers.
Algorithm The optimal solution for this problem involves using bitwise operation.</description></item><item><title>202. Happy Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</link><pubDate>Sun, 18 Jun 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/202/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a number n. We have to determine whether this number is a &amp;ldquo;happy&amp;rdquo; number or not. A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy.</description></item><item><title>206. Reverse Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/206/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/206/</guid><description>LeetCode problem 206
Problem Statement Reverse a given singly linked list and return its head. A singly linked list is a data structure consisting of nodes, where each node has a value and a reference to the next node in the sequence.
Naive Solution A naive approach could be to traverse the entire linked list once to read all its elements into an array. Then, we could reverse the array and construct a new linked list from it. This would work, but it takes up additional space for the array.</description></item><item><title>234. Palindrome Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/234/</guid><description>LeetCode problem
Problem Statement Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
Naive Solution A simple solution to this problem is to:
traverse the linked list storing the value of each node in an array. Then, we could compare the array with its reversed version.
If they match, the linked list is a palindrome. Otherwise, it is not.
This solution takes O(n) time (where n is the number of nodes in the list), as we need to traverse the list once.</description></item><item><title>283. Move Zeroes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/283/</guid><description>LeetCode problem
Problem Statement The problem is asking to move all zeros in an integer array to the end of the array while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.
Naive Solution A naive solution could be to create a new list, iterate over the array, add non-zero elements to the new list and count zero elements. Then extend the new list with the same amount of zeros as counted.</description></item><item><title>345. Reverse Vowels of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/345/</guid><description>LeetCode problem
Problem Statement Given a string s, the task is to reverse only all the vowels in the string and return it. The vowels are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;, and they can appear in both lower and upper cases, more than once.
Naive Solution The naive approach to solve this problem would be to:
Initialize an empty string result. Traverse the given string s from the start to the end. If the current character is a vowel, find the next vowel in the string starting from the end, add it to result, and remove it from the string.</description></item><item><title>389. Find the Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/389/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/389/</guid><description>LeetCode problem 389
Problem Statement Given two strings s and t, the string t is generated by shuffling the characters of s and adding one additional character at a random position. The task is to identify and return that extra character.
Naive Solution A naive solution would involve comparing the characters in both strings one by one to detect the extra character in t. This method is not efficient as it could take a linear amount of time for strings of considerable lengths.</description></item><item><title>392. Is Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/392/</guid><description>LeetCode problem 392
Problem Statement Given two strings s and t, you need to determine if s is a subsequence of t. To be a subsequence, you can remove characters from t without reordering to form s.
Naive Solution The naive approach would be to generate all subsequences of string t and then check if string s is one of them. However, generating all subsequences of t can be computationally expensive especially when the length of t is large.</description></item><item><title>605. Can Place Flowers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/605/</guid><description>LeetCode problem 605
In this problem, we are given a flowerbed represented by an integer array flowerbed, where 0 represents an empty plot and 1 represents a plot with a flower.
We need to determine if we can plant n new flowers in the flowerbed without violating the rule that no two adjacent plots can have flowers.
Naive Solution To solve this problem, we can use a greedy approach. We iterate through the flowerbed and check each plot. If a plot is empty and its adjacent plots are also empty, we can plant a flower in that plot.</description></item><item><title>643. Maximum Average Subarray I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</link><pubDate>Tue, 08 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/643/</guid><description>LeetCode problem
Problem Statement Given an integer array nums consisting of n elements and an integer k, find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. The result must be accurate up to a decimal point of 10^(-5).
Naive Solution A straightforward approach would be to calculate the average for every possible subarray of length k. For each starting point, sum the next k numbers and determine the average.</description></item><item><title>724. Find Pivot Index</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/724/</guid><description>LeetCode problem
Problem Statement Given an array of integers nums, the task is to calculate the pivot index of this array. The pivot index is defined as the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If no such index exists, return -1.
Naive Solution A naive approach would be to iterate over each index and for each index, calculate the sum of elements to the left and right of the index.</description></item><item><title>933. Number of Recent Calls</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/933/</link><pubDate>Fri, 01 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/933/</guid><description>LeetCode задача 933
Задача Реализуйте класс RecentCounter для подсчета вызовов ping за последние 3000 миллисекунд.
Т.е. для вызова t=100, нужно подсчитать количество таких вызовов, время которых меньше t-3000 и учесть сам вызов.
Подход В данной задаче нужно отслеживать количество вызовов ping за последние 3000 миллисекунд.
Можно использовать очередь для хранения времени вызовов ping. При каждом новом вызове будем добавлять текущее время в конец очереди и удалять из начала все времена, которые не попадают в интервал последних 3000 миллисекунд.</description></item><item><title>1046. Last Stone Weight</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1046/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1046/</guid><description>LeetCode problem 1046
class Solution: def lastStoneWeight(self, stones: List[int]) -&amp;gt; int: h = [-x for x in stones] heapify(h) while len(h) &amp;gt; 1: y, x = -heappop(h), -heappop(h) if x != y: heappush(h, x - y) return 0 if not h else -h[0]</description></item><item><title>1047. Remove All Adjacent Duplicates In String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1047/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1047/</guid><description>LeetCode problem 1047
class Solution: def removeDuplicates(self, s: str) -&amp;gt; str: stk = [] for c in s: if stk and stk[-1] == c: stk.pop() else: stk.append(c) return &amp;#39;&amp;#39;.join(stk)</description></item><item><title>1051. Height Checker</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1051/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1051/</guid><description>LeetCode problem 1051
class Solution: def heightChecker(self, heights: List[int]) -&amp;gt; int: cnt = [0] * 101 for h in heights: cnt[h] += 1 res = i = 0 for j in range(1, 101): while cnt[j]: cnt[j] -= 1 if heights[i] != j: res += 1 i += 1 return res</description></item><item><title>1056. Confusing Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1056/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1056/</guid><description>LeetCode problem 1056
class Solution: def confusingNumber(self, n: int) -&amp;gt; bool: x, y = n, 0 d = [0, 1, -1, -1, -1, -1, 9, -1, 8, 6] while x: x, v = divmod(x, 10) if d[v] &amp;lt; 0: return False y = y * 10 + d[v] return y != n</description></item><item><title>1064. Fixed Point</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1064/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1064/</guid><description>LeetCode problem 1064
class Solution: def fixedPoint(self, arr: List[int]) -&amp;gt; int: left, right = 0, len(arr) - 1 while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if arr[mid] &amp;gt;= mid: right = mid else: left = mid + 1 return left if arr[left] == left else -1</description></item><item><title>1065. Index Pairs of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1065/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1065/</guid><description>LeetCode problem 1065
class Trie: def __init__(self): self.children = [None] * 26 self.is_end = False def insert(self, word): node = self for c in word: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: node.children[idx] = Trie() node = node.children[idx] node.is_end = True class Solution: def indexPairs(self, text: str, words: List[str]) -&amp;gt; List[List[int]]: trie = Trie() for w in words: trie.insert(w) n = len(text) res = [] for i in range(n): node = trie for j in range(i, n): idx = ord(text[j]) - ord(&amp;#39;a&amp;#39;) if node.</description></item><item><title>1071. Greatest Common Divisor of Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1071/</guid><description>LeetCode problem
Problem Statement The problem is about finding a greatest common divisor (GCD) of two strings. The term &amp;ldquo;GCD&amp;rdquo; might be familiar from mathematics, as the largest number that divides two numbers without leaving a remainder. Here, we extend the idea to strings: a string x is a GCD of strings str1 and str2 if x can be repeatedly appended to itself to obtain str1 and str2.
Naive Solution A naive approach would be to find all possible divisors of str1 and str2, and then find the largest common divisor.</description></item><item><title>1078. Occurrences After Bigram</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1078/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1078/</guid><description>LeetCode problem 1078
class Solution: def findOcurrences(self, text: str, first: str, second: str) -&amp;gt; List[str]: words = text.split() res = [] for i in range(len(words) - 2): a, b, c = words[i : i + 3] if a == first and b == second: res.append(c) return res</description></item><item><title>1085. Sum of Digits in the Minimum Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1085/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1085/</guid><description>LeetCode problem 1085
class Solution: def sumOfDigits(self, nums: List[int]) -&amp;gt; int: x = min(nums) s = 0 while x: s += x % 10 x //= 10 return s &amp;amp; 1 ^ 1</description></item><item><title>1086. High Five</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1086/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1086/</guid><description>LeetCode problem 1086
class Solution: def highFive(self, items: List[List[int]]) -&amp;gt; List[List[int]]: d = defaultdict(list) m = 0 for i, x in items: d[i].append(x) m = max(m, i) res = [] for i in range(1, m + 1): if xs := d[i]: avg = sum(nlargest(5, xs)) // 5 res.append([i, avg]) return res</description></item><item><title>1089. Duplicate Zeros</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1089/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1089/</guid><description>LeetCode problem 1089
class Solution: def duplicateZeros(self, arr: List[int]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify arr in-place instead. &amp;#34;&amp;#34;&amp;#34; n = len(arr) i, k = -1, 0 while k &amp;lt; n: i += 1 k += 1 if arr[i] else 2 j = n - 1 if k == n + 1: arr[j] = 0 i, j = i - 1, j - 1 while ~j: if arr[i] == 0: arr[j] = arr[j - 1] = arr[i] j -= 1 else: arr[j] = arr[i] i, j = i - 1, j - 1</description></item><item><title>1099. Two Sum Less Than K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1099/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1099/</guid><description>LeetCode problem 1099
class Solution: def twoSumLessThanK(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() i, j = 0, len(nums) - 1 res = -1 while i &amp;lt; j: if (s := nums[i] + nums[j]) &amp;lt; k: res = max(res, s) i += 1 else: j -= 1 return res</description></item><item><title>1103. Distribute Candies to People</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1103/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1103/</guid><description>LeetCode problem 1103
class Solution: def distributeCandies(self, candies: int, num_people: int) -&amp;gt; List[int]: res = [0] * num_people i = 0 while candies: res[i % num_people] += min(candies, i + 1) candies -= min(candies, i + 1) i += 1 return res</description></item><item><title>1108. Defanging an IP Address</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1108/</guid><description>LeetCode problem 1108
class Solution: def defangIPaddr(self, address: str) -&amp;gt; str: return address.replace(&amp;#39;.&amp;#39;, &amp;#39;[.]&amp;#39;)</description></item><item><title>1114. Print in Order</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1114/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1114/</guid><description>LeetCode problem 1114
from threading import Semaphore class Foo: def __init__(self): self.a = Semaphore(1) self.b = Semaphore(0) self.c = Semaphore(0) def first(self, printFirst: &amp;#39;Callable[[], None]&amp;#39;) -&amp;gt; None: self.a.acquire() # printFirst() outputs &amp;#34;first&amp;#34;. Do not change or remove this line. printFirst() self.b.release() def second(self, printSecond: &amp;#39;Callable[[], None]&amp;#39;) -&amp;gt; None: self.b.acquire() # printSecond() outputs &amp;#34;second&amp;#34;. Do not change or remove this line. printSecond() self.c.release() def third(self, printThird: &amp;#39;Callable[[], None]&amp;#39;) -&amp;gt; None: self.c.acquire() # printThird() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.</description></item><item><title>1118. Number of Days in a Month</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1118/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1118/</guid><description>LeetCode problem 1118
class Solution: def numberOfDays(self, year: int, month: int) -&amp;gt; int: leap = (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) days = [0, 31, 29 if leap else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] return days[month]</description></item><item><title>1119. Remove Vowels from a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1119/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1119/</guid><description>LeetCode problem 1119
class Solution: def removeVowels(self, s: str) -&amp;gt; str: return &amp;#34;&amp;#34;.join(c for c in s if c not in &amp;#34;aeiou&amp;#34;)</description></item><item><title>1122. Relative Sort Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1122/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1122/</guid><description>LeetCode problem 1122
class Solution: def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&amp;gt; List[int]: pos = {x: i for i, x in enumerate(arr2)} return sorted(arr1, key=lambda x: pos.get(x, 1000 + x))</description></item><item><title>1128. Number of Equivalent Domino Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1128/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1128/</guid><description>LeetCode problem 1128
class Solution: def numEquivDominoPairs(self, dominoes: List[List[int]]) -&amp;gt; int: cnt = Counter() res = 0 for a, b in dominoes: x = a * 10 + b if a &amp;lt; b else b * 10 + a res += cnt[x] cnt[x] += 1 return res</description></item><item><title>1133. Largest Unique Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1133/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1133/</guid><description>LeetCode problem 1133
class Solution: def largestUniqueNumber(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) return max((x for x, v in cnt.items() if v == 1), default=-1)</description></item><item><title>1134. Armstrong Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1134/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1134/</guid><description>LeetCode problem 1134
class Solution: def isArmstrong(self, n: int) -&amp;gt; bool: k = len(str(n)) s, x = 0, n while x: s += (x % 10) ** k x //= 10 return s == n</description></item><item><title>1137. N-th Tribonacci Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1137/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1137/</guid><description>LeetCode problem 1137
import numpy as np class Solution: def tribonacci(self, n: int) -&amp;gt; int: if n == 0: return 0 if n &amp;lt; 3: return 1 factor = np.mat([(1, 1, 0), (1, 0, 1), (1, 0, 0)], np.dtype(&amp;#34;O&amp;#34;)) res = np.mat([(1, 1, 0)], np.dtype(&amp;#34;O&amp;#34;)) n -= 3 while n: if n &amp;amp; 1: res *= factor factor *= factor n &amp;gt;&amp;gt;= 1 return res.sum()</description></item><item><title>1150. Check If a Number Is Majority Element in a Sorted Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1150/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1150/</guid><description>LeetCode problem 1150
class Solution: def isMajorityElement(self, nums: List[int], target: int) -&amp;gt; bool: left = bisect_left(nums, target) right = left + len(nums) // 2 return right &amp;lt; len(nums) and nums[right] == target</description></item><item><title>1154. Day of the Year</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1154/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1154/</guid><description>LeetCode problem 1154
class Solution: def dayOfYear(self, date: str) -&amp;gt; int: y, m, d = (int(s) for s in date.split(&amp;#39;-&amp;#39;)) v = 29 if y % 400 == 0 or (y % 4 == 0 and y % 100) else 28 days = [31, v, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] return sum(days[: m - 1]) + d</description></item><item><title>1160. Find Words That Can Be Formed by Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1160/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1160/</guid><description>LeetCode problem 1160
class Solution: def countCharacters(self, words: List[str], chars: str) -&amp;gt; int: cnt = Counter(chars) res = 0 for w in words: wc = Counter(w) if all(cnt[c] &amp;gt;= v for c, v in wc.items()): res += len(w) return res</description></item><item><title>1165. Single-Row Keyboard</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1165/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1165/</guid><description>LeetCode problem 1165
class Solution: def calculateTime(self, keyboard: str, word: str) -&amp;gt; int: pos = {c: i for i, c in enumerate(keyboard)} res = i = 0 for c in word: res += abs(pos[c] - i) i = pos[c] return res</description></item><item><title>1175. Prime Arrangements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1175/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1175/</guid><description>LeetCode problem 1175
class Solution: def numPrimeArrangements(self, n: int) -&amp;gt; int: def count(n): cnt = 0 primes = [True] * (n + 1) for i in range(2, n + 1): if primes[i]: cnt += 1 for j in range(i + i, n + 1, i): primes[j] = False return cnt cnt = count(n) res = factorial(cnt) * factorial(n - cnt) return res % (10**9 + 7)</description></item><item><title>1176. Diet Plan Performance</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1176/</guid><description>LeetCode problem 1176
class Solution: def dietPlanPerformance( self, calories: List[int], k: int, lower: int, upper: int ) -&amp;gt; int: def check(s): if s &amp;lt; lower: return -1 if s &amp;gt; upper: return 1 return 0 s, n = sum(calories[:k]), len(calories) res = check(s) for i in range(k, n): s += calories[i] - calories[i - k] res += check(s) return res</description></item><item><title>1180. Count Substrings with Only One Distinct Letter</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1180/</guid><description>LeetCode problem 1180
class Solution: def countLetters(self, s: str) -&amp;gt; int: res = 0 i, n = 0, len(s) while i &amp;lt; n: j = i cnt = 0 while j &amp;lt; n and s[j] == s[i]: j += 1 cnt += 1 res += cnt i = j return res</description></item><item><title>1184. Distance Between Bus Stops</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1184/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1184/</guid><description>LeetCode problem 1184
class Solution: def distanceBetweenBusStops( self, distance: List[int], start: int, destination: int ) -&amp;gt; int: a, n = 0, len(distance) while start != destination: a += distance[start] start = (start + 1) % n return min(a, sum(distance) - a)</description></item><item><title>1185. Day of the Week</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1185/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1185/</guid><description>LeetCode problem 1185
class Solution: def dayOfTheWeek(self, d: int, m: int, y: int) -&amp;gt; str: if m &amp;lt; 3: m += 12 y -= 1 c = y // 100 y = y % 100 w = (c // 4 - 2 * c + y + y // 4 + 13 * (m + 1) // 5 + d - 1) % 7 return [ &amp;#34;Sunday&amp;#34;, &amp;#34;Monday&amp;#34;, &amp;#34;Tuesday&amp;#34;, &amp;#34;Wednesday&amp;#34;, &amp;#34;Thursday&amp;#34;, &amp;#34;Friday&amp;#34;, &amp;#34;Saturday&amp;#34;, ][w]</description></item><item><title>1189. Maximum Number of Balloons</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1189/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1189/</guid><description>LeetCode problem 1189
class Solution: def maxNumberOfBalloons(self, text: str) -&amp;gt; int: cnt = Counter(text) cnt[&amp;#39;o&amp;#39;] &amp;gt;&amp;gt;= 1 cnt[&amp;#39;l&amp;#39;] &amp;gt;&amp;gt;= 1 return min(cnt[c] for c in &amp;#39;balon&amp;#39;)</description></item><item><title>1196. How Many Apples Can You Put into the Basket</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1196/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1196/</guid><description>LeetCode problem 1196
class Solution: def maxNumberOfApples(self, weight: List[int]) -&amp;gt; int: weight.sort() s = 0 for i, x in enumerate(weight): s += x if s &amp;gt; 5000: return i return len(weight)</description></item><item><title>1200. Minimum Absolute Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1200/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1200/</guid><description>LeetCode problem 1200
class Solution: def minimumAbsDifference(self, arr: List[int]) -&amp;gt; List[List[int]]: arr.sort() mi = min(b - a for a, b in pairwise(arr)) return [[a, b] for a, b in pairwise(arr) if b - a == mi]</description></item><item><title>1207. Unique Number of Occurrences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1207/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1207/</guid><description>LeetCode problem
Problem Statement Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
Naive Solution A naive approach would be to create a dictionary to store the count of each integer, then iterate over the dictionary and compare each count with the counts of other integers. This approach requires O(n^2) time complexity, where n is the length of the array. This is not efficient for large input sizes.</description></item><item><title>1213. Intersection of Three Sorted Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1213/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1213/</guid><description>LeetCode problem 1213
class Solution: def arraysIntersection( self, arr1: List[int], arr2: List[int], arr3: List[int] ) -&amp;gt; List[int]: res = [] for x in arr1: i = bisect_left(arr2, x) j = bisect_left(arr3, x) if i &amp;lt; len(arr2) and j &amp;lt; len(arr3) and arr2[i] == x and arr3[j] == x: res.append(x) return res</description></item><item><title>1217. Minimum Cost to Move Chips to The Same Position</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1217/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1217/</guid><description>LeetCode problem 1217
class Solution: def minCostToMoveChips(self, position: List[int]) -&amp;gt; int: a = sum(p % 2 for p in position) b = len(position) - a return min(a, b)</description></item><item><title>1221. Split a String in Balanced Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1221/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1221/</guid><description>LeetCode problem 1221
class Solution: def balancedStringSplit(self, s: str) -&amp;gt; int: res = l = 0 for c in s: if c == &amp;#39;L&amp;#39;: l += 1 else: l -= 1 if l == 0: res += 1 return res</description></item><item><title>1228. Missing Number In Arithmetic Progression</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1228/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1228/</guid><description>LeetCode problem 1228
class Solution: def missingNumber(self, arr: List[int]) -&amp;gt; int: n = len(arr) d = (arr[-1] - arr[0]) // n for i in range(1, n): if arr[i] != arr[i - 1] + d: return arr[i - 1] + d return arr[0]</description></item><item><title>1232. Check If It Is a Straight Line</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1232/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1232/</guid><description>LeetCode problem 1232
class Solution: def checkStraightLine(self, coordinates: List[List[int]]) -&amp;gt; bool: x1, y1 = coordinates[0] x2, y2 = coordinates[1] for x, y in coordinates[2:]: if (x - x1) * (y2 - y1) != (y - y1) * (x2 - x1): return False return True</description></item><item><title>1243. Array Transformation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1243/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1243/</guid><description>LeetCode problem 1243
class Solution: def transformArray(self, arr: List[int]) -&amp;gt; List[int]: f = True while f: f = False t = arr[:] for i in range(1, len(t) - 1): if t[i] &amp;gt; t[i - 1] and t[i] &amp;gt; t[i + 1]: arr[i] -= 1 f = True if t[i] &amp;lt; t[i - 1] and t[i] &amp;lt; t[i + 1]: arr[i] += 1 f = True return arr</description></item><item><title>1252. Cells with Odd Values in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1252/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1252/</guid><description>LeetCode problem 1252
class Solution: def oddCells(self, m: int, n: int, indices: List[List[int]]) -&amp;gt; int: row = [0] * m col = [0] * n for r, c in indices: row[r] += 1 col[c] += 1 cnt1 = sum(v % 2 for v in row) cnt2 = sum(v % 2 for v in col) return cnt1 * (n - cnt2) + cnt2 * (m - cnt1)</description></item><item><title>1266. Minimum Time Visiting All Points</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1266/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1266/</guid><description>LeetCode problem 1266
class Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -&amp;gt; int: return sum( max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) for p1, p2 in pairwise(points) )</description></item><item><title>1271. Hexspeak</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1271/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1271/</guid><description>LeetCode problem 1271
class Solution: def toHexspeak(self, num: str) -&amp;gt; str: s = set(&amp;#39;ABCDEFIO&amp;#39;) t = hex(int(num))[2:].upper().replace(&amp;#39;0&amp;#39;, &amp;#39;O&amp;#39;).replace(&amp;#39;1&amp;#39;, &amp;#39;I&amp;#39;) return t if all(c in s for c in t) else &amp;#39;ERROR&amp;#39;</description></item><item><title>1275. Find Winner on a Tic Tac Toe Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1275/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1275/</guid><description>LeetCode problem 1275
class Solution: def tictactoe(self, moves: List[List[int]]) -&amp;gt; str: n = len(moves) cnt = [0] * 8 for k in range(n - 1, -1, -2): i, j = moves[k] cnt[i] += 1 cnt[j + 3] += 1 if i == j: cnt[6] += 1 if i + j == 2: cnt[7] += 1 if any(v == 3 for v in cnt): return &amp;#34;B&amp;#34; if k &amp;amp; 1 else &amp;#34;A&amp;#34; return &amp;#34;Draw&amp;#34; if n == 9 else &amp;#34;Pending&amp;#34;</description></item><item><title>1279. Traffic Light Controlled Intersection</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1279/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1279/</guid><description>LeetCode problem 1279
from threading import Lock class TrafficLight: def __init__(self): self.lock = Lock() self.road = 1 def carArrived( self, carId: int, # ID of the car # ID of the road the car travels on. Can be 1 (road A) or 2 (road B) roadId: int, direction: int, # Direction of the car # Use turnGreen() to turn light to green on current road turnGreen: &amp;#39;Callable[[], None]&amp;#39;, # Use crossCar() to make car cross the intersection crossCar: &amp;#39;Callable[[], None]&amp;#39;, ) -&amp;gt; None: self.</description></item><item><title>1281. Subtract the Product and Sum of Digits of an Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1281/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1281/</guid><description>LeetCode problem 1281
class Solution: def subtractProductAndSum(self, n: int) -&amp;gt; int: nums = list(map(int, str(n))) return prod(nums) - sum(nums)</description></item><item><title>1290. Convert Binary Number in a Linked List to Integer</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1290/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1290/</guid><description>LeetCode problem 1290
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def getDecimalValue(self, head: ListNode) -&amp;gt; int: res = 0 while head: res = res &amp;lt;&amp;lt; 1 | head.val head = head.next return res</description></item><item><title>1295. Find Numbers with Even Number of Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1295/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1295/</guid><description>LeetCode problem 1295
class Solution: def findNumbers(self, nums: List[int]) -&amp;gt; int: return sum(len(str(v)) % 2 == 0 for v in nums)</description></item><item><title>1299. Replace Elements with Greatest Element on Right Side</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1299/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1299/</guid><description>LeetCode problem 1299
class Solution: def replaceElements(self, arr: List[int]) -&amp;gt; List[int]: m = -1 for i in range(len(arr) - 1, -1, -1): t = arr[i] arr[i] = m m = max(m, t) return arr</description></item><item><title>1304. Find N Unique Integers Sum up to Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1304/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1304/</guid><description>LeetCode problem 1304
class Solution: def sumZero(self, n: int) -&amp;gt; List[int]: res = list(range(1, n)) res.append(-sum(res)) return res</description></item><item><title>1309. Decrypt String from Alphabet to Integer Mapping</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1309/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1309/</guid><description>LeetCode problem 1309
class Solution: def freqAlphabets(self, s: str) -&amp;gt; str: def get(s): return chr(ord(&amp;#39;a&amp;#39;) + int(s) - 1) i, n = 0, len(s) res = [] while i &amp;lt; n: if i + 2 &amp;lt; n and s[i + 2] == &amp;#39;#&amp;#39;: res.append(get(s[i : i + 2])) i += 3 else: res.append(get(s[i])) i += 1 return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1313. Decompress Run-Length Encoded List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1313/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1313/</guid><description>LeetCode problem 1313
class Solution: def decompressRLElist(self, nums: List[int]) -&amp;gt; List[int]: res = [] for i in range(1, len(nums), 2): res.extend([nums[i]] * nums[i - 1]) return res</description></item><item><title>1317. Convert Integer to the Sum of Two No-Zero Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1317/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1317/</guid><description>LeetCode problem 1317
class Solution: def getNoZeroIntegers(self, n: int) -&amp;gt; List[int]: def f(x): while x: if x % 10 == 0: return False x //= 10 return True for a in range(1, n): b = n - a if f(a) and f(b): return [a, b]</description></item><item><title>1331. Rank Transform of an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1331/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1331/</guid><description>LeetCode problem 1331
class Solution: def arrayRankTransform(self, arr: List[int]) -&amp;gt; List[int]: t = sorted(set(arr)) return [bisect_right(t, x) for x in arr]</description></item><item><title>1332. Remove Palindromic Subsequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1332/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1332/</guid><description>LeetCode problem 1332
class Solution: def removePalindromeSub(self, s: str) -&amp;gt; int: return 1 if s[::-1] == s else 2</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1342. Number of Steps to Reduce a Number to Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1342/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1342/</guid><description>LeetCode problem 1342
class Solution: def numberOfSteps(self, num: int) -&amp;gt; int: if num == 0: return 0 return 1 + ( self.numberOfSteps(num // 2) if num % 2 == 0 else self.numberOfSteps(num - 1) )</description></item><item><title>1346. Check If N and Its Double Exist</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1346/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1346/</guid><description>LeetCode problem 1346
class Solution: def checkIfExist(self, arr: List[int]) -&amp;gt; bool: if arr.count(0) &amp;gt; 1: return True arr.sort() n = len(arr) for v in arr: idx = bisect_left(arr, v * 2) if v != 0 and idx != n and arr[idx] == v * 2: return True return False</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1351/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1351/</guid><description>LeetCode problem 1351
class Solution: def countNegatives(self, grid: List[List[int]]) -&amp;gt; int: return sum(bisect_left(row[::-1], 0) for row in grid)</description></item><item><title>1360. Number of Days Between Two Dates</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1360/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1360/</guid><description>LeetCode problem 1360
class Solution: def daysBetweenDates(self, date1: str, date2: str) -&amp;gt; int: def isLeapYear(year: int) -&amp;gt; bool: return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) def daysInMonth(year: int, month: int) -&amp;gt; int: days = [ 31, 28 + int(isLeapYear(year)), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, ] return days[month - 1] def calcDays(date: str) -&amp;gt; int: year, month, day = map(int, date.split(&amp;#34;-&amp;#34;)) days = 0 for y in range(1971, year): days += 365 + int(isLeapYear(y)) for m in range(1, month): days += daysInMonth(year, m) days += day return days return abs(calcDays(date1) - calcDays(date2))</description></item><item><title>1365. How Many Numbers Are Smaller Than the Current Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1365/</guid><description>LeetCode problem 1365
class Solution: def smallerNumbersThanCurrent(self, nums: List[int]) -&amp;gt; List[int]: cnt = [0] * 102 for x in nums: cnt[x + 1] += 1 s = list(accumulate(cnt)) return [s[x] for x in nums]</description></item><item><title>1370. Increasing Decreasing String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1370/</guid><description>LeetCode problem 1370
class Solution: def sortString(self, s: str) -&amp;gt; str: cnt = Counter(s) cs = ascii_lowercase + ascii_lowercase[::-1] res = [] while len(res) &amp;lt; len(s): for c in cs: if cnt[c]: res.append(c) cnt[c] -= 1 return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1374. Generate a String With Characters That Have Odd Counts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1374/</guid><description>LeetCode problem 1374
class Solution: def generateTheString(self, n: int) -&amp;gt; str: return &amp;#39;a&amp;#39; * n if n &amp;amp; 1 else &amp;#39;a&amp;#39; * (n - 1) + &amp;#39;b&amp;#39;</description></item><item><title>1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1379/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1379/</guid><description>LeetCode problem 1379
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def getTargetCopy( self, original: TreeNode, cloned: TreeNode, target: TreeNode ) -&amp;gt; TreeNode: def dfs(root1: TreeNode, root2: TreeNode) -&amp;gt; TreeNode: if root1 is None: return None if root1 == target: return root2 return dfs(root1.left, root2.left) or dfs(root1.right, root2.right) return dfs(original, cloned)</description></item><item><title>1380. Lucky Numbers in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1380/</guid><description>LeetCode problem 1380
class Solution: def luckyNumbers(self, matrix: List[List[int]]) -&amp;gt; List[int]: rows = {min(row) for row in matrix} cols = {max(col) for col in zip(*matrix)} return list(rows &amp;amp; cols)</description></item><item><title>1385. Find the Distance Value Between Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1385/</guid><description>LeetCode problem 1385
class Solution: def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -&amp;gt; int: def check(a: int) -&amp;gt; bool: i = bisect_left(arr2, a - d) return i == len(arr2) or arr2[i] &amp;gt; a + d arr2.sort() return sum(check(a) for a in arr1)</description></item><item><title>1389. Create Target Array in the Given Order</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1389/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1389/</guid><description>LeetCode problem 1389
class Solution: def createTargetArray(self, nums: List[int], index: List[int]) -&amp;gt; List[int]: target = [] for x, i in zip(nums, index): target.insert(i, x) return target</description></item><item><title>1394. Find Lucky Integer in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1394/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1394/</guid><description>LeetCode problem 1394
class Solution: def findLucky(self, arr: List[int]) -&amp;gt; int: cnt = Counter(arr) res = -1 for x, v in cnt.items(): if x == v and res &amp;lt; x: res = x return res</description></item><item><title>1399. Count Largest Group</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1399/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1399/</guid><description>LeetCode problem 1399
class Solution: def countLargestGroup(self, n: int) -&amp;gt; int: cnt = Counter() res = mx = 0 for i in range(1, n + 1): s = 0 while i: s += i % 10 i //= 10 cnt[s] += 1 if mx &amp;lt; cnt[s]: mx = cnt[s] res = 1 elif mx == cnt[s]: res += 1 return res</description></item><item><title>1403. Minimum Subsequence in Non-Increasing Order</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1403/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1403/</guid><description>LeetCode problem 1403
class Solution: def minSubsequence(self, nums: List[int]) -&amp;gt; List[int]: res = [] s, t = sum(nums), 0 for x in sorted(nums, reverse=True): t += x res.append(x) if t &amp;gt; s - t: break return res</description></item><item><title>1408. String Matching in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1408/</guid><description>LeetCode problem 1408
class Solution: def stringMatching(self, words: List[str]) -&amp;gt; List[str]: res = [] for i, s in enumerate(words): if any(i != j and s in t for j, t in enumerate(words)): res.append(s) return res</description></item><item><title>1413. Minimum Value to Get Positive Step by Step Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1413/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1413/</guid><description>LeetCode problem 1413
class Solution: def minStartValue(self, nums: List[int]) -&amp;gt; int: s = list(accumulate(nums)) return 1 if min(s) &amp;gt;= 0 else abs(min(s)) + 1</description></item><item><title>1417. Reformat The String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1417/</guid><description>LeetCode problem 1417
class Solution: def reformat(self, s: str) -&amp;gt; str: a = [c for c in s if c.islower()] b = [c for c in s if c.isdigit()] if abs(len(a) - len(b)) &amp;gt; 1: return &amp;#39;&amp;#39; if len(a) &amp;lt; len(b): a, b = b, a res = [] for x, y in zip(a, b): res.append(x + y) if len(a) &amp;gt; len(b): res.append(a[-1]) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1422. Maximum Score After Splitting a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1422/</guid><description>LeetCode problem 1422
class Solution: def maxScore(self, s: str) -&amp;gt; int: res = t = (s[0] == &amp;#39;0&amp;#39;) + s[1:].count(&amp;#39;1&amp;#39;) for i in range(1, len(s) - 1): t += 1 if s[i] == &amp;#39;0&amp;#39; else -1 res = max(res, t) return res</description></item><item><title>1426. Counting Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1426/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1426/</guid><description>LeetCode problem 1426
class Solution: def countElements(self, arr: List[int]) -&amp;gt; int: cnt = Counter(arr) return sum(v for x, v in cnt.items() if cnt[x + 1])</description></item><item><title>1427. Perform String Shifts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1427/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1427/</guid><description>LeetCode problem 1427
class Solution: def stringShift(self, s: str, shift: List[List[int]]) -&amp;gt; str: x = sum((b if a else -b) for a, b in shift) x %= len(s) return s[-x:] + s[:-x]</description></item><item><title>1431. Kids With the Greatest Number of Candies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1431/</link><pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1431/</guid><description>LeetCode problem 1431. Kids With the Greatest Number of Candies
Problem Statement Imagine you&amp;rsquo;re in a classroom with a bunch of kids, and each kid has a certain number of candies. You, being super generous, have some extra candies to give away. Now, you&amp;rsquo;re wondering, if you give all these extra candies to one kid at a time, will that kid end up having the most candies in the class? And you want to check this for every kid in the class.</description></item><item><title>1436. Destination City</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1436/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1436/</guid><description>LeetCode problem 1436
class Solution: def destCity(self, paths: List[List[str]]) -&amp;gt; str: s = {a for a, _ in paths} return next(b for _, b in paths if b not in s)</description></item><item><title>1446. Consecutive Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1446/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1446/</guid><description>LeetCode problem 1446
class Solution: def maxPower(self, s: str) -&amp;gt; int: res = t = 1 for a, b in pairwise(s): if a == b: t += 1 res = max(res, t) else: t = 1 return res</description></item><item><title>1450. Number of Students Doing Homework at a Given Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1450/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1450/</guid><description>LeetCode problem 1450
class Solution: def busyStudent( self, startTime: List[int], endTime: List[int], queryTime: int ) -&amp;gt; int: c = [0] * 1010 for a, b in zip(startTime, endTime): c[a] += 1 c[b + 1] -= 1 return sum(c[: queryTime + 1])</description></item><item><title>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1455/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1455/</guid><description>LeetCode problem 1455
class Solution: def isPrefixOfWord(self, sentence: str, searchWord: str) -&amp;gt; int: for i, s in enumerate(sentence.split(), 1): if s.startswith(searchWord): return i return -1</description></item><item><title>1460. Make Two Arrays Equal by Reversing Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1460/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1460/</guid><description>LeetCode problem 1460
class Solution: def canBeEqual(self, target: List[int], arr: List[int]) -&amp;gt; bool: cnt = [0] * 1001 for a, b in zip(target, arr): cnt[a] += 1 cnt[b] -= 1 return all(v == 0 for v in cnt)</description></item><item><title>1464. Maximum Product of Two Elements in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1464/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1464/</guid><description>LeetCode problem 1464
class Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: a = b = 0 for v in nums: if v &amp;gt; a: a, b = v, a elif v &amp;gt; b: b = v return (a - 1) * (b - 1)</description></item><item><title>1469. Find All The Lonely Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1469/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1469/</guid><description>LeetCode problem 1469
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getLonelyNodes(self, root: Optional[TreeNode]) -&amp;gt; List[int]: def dfs(root): if root is None or (root.left is None and root.right is None): return if root.left is None: res.append(root.right.val) if root.right is None: res.append(root.left.val) dfs(root.left) dfs(root.right) res = [] dfs(root) return res</description></item><item><title>1470. Shuffle the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1470/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1470/</guid><description>LeetCode problem 1470
class Solution: def shuffle(self, nums: List[int], n: int) -&amp;gt; List[int]: nums[::2], nums[1::2] = nums[:n], nums[n:] return nums</description></item><item><title>1474. Delete N Nodes After M Nodes of a Linked List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1474/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1474/</guid><description>LeetCode problem 1474
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteNodes(self, head: ListNode, m: int, n: int) -&amp;gt; ListNode: pre = head while pre: for _ in range(m - 1): if pre: pre = pre.next if pre is None: return head cur = pre for _ in range(n): if cur: cur = cur.next pre.next = None if cur is None else cur.</description></item><item><title>1475. Final Prices With a Special Discount in a Shop</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1475/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1475/</guid><description>LeetCode problem 1475
class Solution: def finalPrices(self, prices: List[int]) -&amp;gt; List[int]: stk = [] res = prices[:] for i in range(len(prices) - 1, -1, -1): while stk and prices[stk[-1]] &amp;gt; prices[i]: stk.pop() if stk: res[i] -= prices[stk[-1]] stk.append(i) return res</description></item><item><title>1486. XOR Operation in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1486/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1486/</guid><description>LeetCode problem 1486
class Solution: def xorOperation(self, n: int, start: int) -&amp;gt; int: return reduce(xor, ((start + 2 * i) for i in range(n)))</description></item><item><title>1491. Average Salary Excluding the Minimum and Maximum Salary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1491/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1491/</guid><description>LeetCode problem 1491
class Solution: def average(self, salary: List[int]) -&amp;gt; float: s = sum(salary) - min(salary) - max(salary) return s / (len(salary) - 2)</description></item><item><title>1496. Path Crossing</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1496/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1496/</guid><description>LeetCode problem 1496
class Solution: def isPathCrossing(self, path: str) -&amp;gt; bool: i = j = 0 vis = {(0, 0)} for c in path: match c: case &amp;#39;N&amp;#39;: i -= 1 case &amp;#39;S&amp;#39;: i += 1 case &amp;#39;E&amp;#39;: j += 1 case &amp;#39;W&amp;#39;: j -= 1 if (i, j) in vis: return True vis.add((i, j)) return False</description></item><item><title>1502. Can Make Arithmetic Progression From Sequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1502/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1502/</guid><description>LeetCode problem 1502
class Solution: def canMakeArithmeticProgression(self, arr: List[int]) -&amp;gt; bool: a = min(arr) b = max(arr) n = len(arr) if (b - a) % (n - 1): return False d = (b - a) // (n - 1) s = set(arr) return all(a + d * i in s for i in range(n))</description></item><item><title>1507. Reformat Date</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1507/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1507/</guid><description>LeetCode problem 1507
class Solution: def reformatDate(self, date: str) -&amp;gt; str: s = date.split() s.reverse() months = &amp;#34; JanFebMarAprMayJunJulAugSepOctNovDec&amp;#34; s[1] = str(months.index(s[1]) // 3 + 1).zfill(2) s[2] = s[2][:-2].zfill(2) return &amp;#34;-&amp;#34;.join(s)</description></item><item><title>1512. Number of Good Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1512/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1512/</guid><description>LeetCode problem 1512
class Solution: def numIdenticalPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) return sum(v * (v - 1) for v in cnt.values()) &amp;gt;&amp;gt; 1</description></item><item><title>1518. Water Bottles</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1518/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1518/</guid><description>LeetCode problem 1518
class Solution: def numWaterBottles(self, numBottles: int, numExchange: int) -&amp;gt; int: res = numBottles while numBottles &amp;gt;= numExchange: numBottles -= numExchange - 1 res += 1 return res</description></item><item><title>1523. Count Odd Numbers in an Interval Range</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1523/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1523/</guid><description>LeetCode problem 1523
class Solution: def countOdds(self, low: int, high: int) -&amp;gt; int: return ((high + 1) &amp;gt;&amp;gt; 1) - (low &amp;gt;&amp;gt; 1)</description></item><item><title>1528. Shuffle String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1528/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1528/</guid><description>LeetCode problem 1528
class Solution: def restoreString(self, s: str, indices: List[int]) -&amp;gt; str: res = [0] * len(s) for i, c in enumerate(s): res[indices[i]] = c return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1534. Count Good Triplets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1534/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1534/</guid><description>LeetCode problem 1534
class Solution: def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -&amp;gt; int: res, n = 0, len(arr) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): res += ( abs(arr[i] - arr[j]) &amp;lt;= a and abs(arr[j] - arr[k]) &amp;lt;= b and abs(arr[i] - arr[k]) &amp;lt;= c ) return res</description></item><item><title>1539. Kth Missing Positive Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1539/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1539/</guid><description>LeetCode problem 1539
class Solution: def findKthPositive(self, arr: List[int], k: int) -&amp;gt; int: if arr[0] &amp;gt; k: return k left, right = 0, len(arr) while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if arr[mid] - mid - 1 &amp;gt;= k: right = mid else: left = mid + 1 return arr[left - 1] + k - (arr[left - 1] - (left - 1) - 1)</description></item><item><title>1544. Make The String Great</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1544/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1544/</guid><description>LeetCode problem 1544
class Solution: def makeGood(self, s: str) -&amp;gt; str: stk = [] for c in s: if not stk or abs(ord(stk[-1]) - ord(c)) != 32: stk.append(c) else: stk.pop() return &amp;#34;&amp;#34;.join(stk)</description></item><item><title>1550. Three Consecutive Odds</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1550/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1550/</guid><description>LeetCode problem 1550
class Solution: def threeConsecutiveOdds(self, arr: List[int]) -&amp;gt; bool: for i in range(len(arr) - 2): if arr[i] % 2 + arr[i + 1] % 2 + arr[i + 2] % 2 == 3: return True return False</description></item><item><title>1556. Thousand Separator</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1556/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1556/</guid><description>LeetCode problem 1556
class Solution: def thousandSeparator(self, n: int) -&amp;gt; str: cnt = 0 res = [] while 1: n, v = divmod(n, 10) res.append(str(v)) cnt += 1 if n == 0: break if cnt == 3: res.append(&amp;#39;.&amp;#39;) cnt = 0 return &amp;#39;&amp;#39;.join(res[::-1])</description></item><item><title>1560. Most Visited Sector in a Circular Track</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1560/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1560/</guid><description>LeetCode problem 1560
class Solution: def mostVisited(self, n: int, rounds: List[int]) -&amp;gt; List[int]: if rounds[0] &amp;lt;= rounds[-1]: return list(range(rounds[0], rounds[-1] + 1)) return list(range(1, rounds[-1] + 1)) + list(range(rounds[0], n + 1))</description></item><item><title>1566. Detect Pattern of Length M Repeated K or More Times</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1566/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1566/</guid><description>LeetCode problem 1566
class Solution: def containsPattern(self, arr: List[int], m: int, k: int) -&amp;gt; bool: n = len(arr) for i in range(n - m * k + 1): j = 0 while j &amp;lt; m * k: if arr[i + j] != arr[i + (j % m)]: break j += 1 if j == m * k: return True return False</description></item><item><title>1572. Matrix Diagonal Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1572/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1572/</guid><description>LeetCode problem 1572
class Solution: def diagonalSum(self, mat: List[List[int]]) -&amp;gt; int: res = 0 n = len(mat) for i, row in enumerate(mat): j = n - i - 1 res += row[i] + (0 if j == i else row[j]) return res</description></item><item><title>1576. Replace All 's to Avoid Consecutive Repeating Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1576/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1576/</guid><description>LeetCode problem 1576
class Solution: def modifyString(self, s: str) -&amp;gt; str: s = list(s) n = len(s) for i in range(n): if s[i] == &amp;#34;?&amp;#34;: for c in &amp;#34;abc&amp;#34;: if (i and s[i - 1] == c) or (i + 1 &amp;lt; n and s[i + 1] == c): continue s[i] = c break return &amp;#34;&amp;#34;.join(s)</description></item><item><title>1582. Special Positions in a Binary Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1582/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1582/</guid><description>LeetCode problem 1582
class Solution: def numSpecial(self, mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) r = [0] * m c = [0] * n for i, row in enumerate(mat): for j, v in enumerate(row): r[i] += v c[j] += v res = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and r[i] == 1 and c[j] == 1: res += 1 return res</description></item><item><title>1588. Sum of All Odd Length Subarrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1588/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1588/</guid><description>LeetCode problem 1588
class Solution: def sumOddLengthSubarrays(self, arr: List[int]) -&amp;gt; int: res, n = 0, len(arr) for i in range(n): s = 0 for j in range(i, n): s += arr[j] if (j - i + 1) &amp;amp; 1: res += s return res</description></item><item><title>1592. Rearrange Spaces Between Words</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1592/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1592/</guid><description>LeetCode problem 1592
class Solution: def reorderSpaces(self, text: str) -&amp;gt; str: cnt = text.count(&amp;#39; &amp;#39;) words = text.split() m = len(words) - 1 if m == 0: return words[0] + &amp;#39; &amp;#39; * cnt return (&amp;#39; &amp;#39; * (cnt // m)).join(words) + &amp;#39; &amp;#39; * (cnt % m)</description></item><item><title>1598. Crawler Log Folder</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1598/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1598/</guid><description>LeetCode problem 1598
class Solution: def minOperations(self, logs: List[str]) -&amp;gt; int: res = 0 for v in logs: if v == &amp;#34;../&amp;#34;: res = max(0, res - 1) elif v[0] != &amp;#34;.&amp;#34;: res += 1 return res</description></item><item><title>1603. Design Parking System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1603/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1603/</guid><description>LeetCode problem 1603
class ParkingSystem: def __init__(self, big: int, medium: int, small: int): self.cnt = [0, big, medium, small] def addCar(self, carType: int) -&amp;gt; bool: if self.cnt[carType] == 0: return False self.cnt[carType] -= 1 return True # Your ParkingSystem object will be instantiated and called as such: # obj = ParkingSystem(big, medium, small) # param_1 = obj.addCar(carType)</description></item><item><title>1608. Special Array With X Elements Greater Than or Equal X</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1608/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1608/</guid><description>LeetCode problem 1608
class Solution: def specialArray(self, nums: List[int]) -&amp;gt; int: nums.sort() n = len(nums) for x in range(1, n + 1): cnt = n - bisect_left(nums, x) if cnt == x: return x return -1</description></item><item><title>1614. Maximum Nesting Depth of the Parentheses</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1614/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1614/</guid><description>LeetCode problem 1614
class Solution: def maxDepth(self, s: str) -&amp;gt; int: res = d = 0 for c in s: if c == &amp;#39;(&amp;#39;: d += 1 res = max(res, d) elif c == &amp;#39;)&amp;#39;: d -= 1 return res</description></item><item><title>1619. Mean of Array After Removing Some Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1619/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1619/</guid><description>LeetCode problem 1619
class Solution: def trimMean(self, arr: List[int]) -&amp;gt; float: n = len(arr) start, end = int(n * 0.05), int(n * 0.95) arr.sort() t = arr[start:end] return round(sum(t) / len(t), 5)</description></item><item><title>1624. Largest Substring Between Two Equal Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1624/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1624/</guid><description>LeetCode problem 1624
class Solution: def maxLengthBetweenEqualCharacters(self, s: str) -&amp;gt; int: d = {} res = -1 for i, c in enumerate(s): if c in d: res = max(res, i - d[c] - 1) else: d[c] = i return res</description></item><item><title>1629. Slowest Key</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1629/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1629/</guid><description>LeetCode problem 1629
class Solution: def slowestKey(self, releaseTimes: List[int], keysPressed: str) -&amp;gt; str: res = keysPressed[0] mx = releaseTimes[0] for i in range(1, len(keysPressed)): d = releaseTimes[i] - releaseTimes[i - 1] if d &amp;gt; mx or (d == mx and ord(keysPressed[i]) &amp;gt; ord(res)): mx = d res = keysPressed[i] return res</description></item><item><title>1636. Sort Array by Increasing Frequency</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1636/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1636/</guid><description>LeetCode problem 1636
class Solution: def frequencySort(self, nums: List[int]) -&amp;gt; List[int]: cnt = Counter(nums) return sorted(nums, key=lambda x: (cnt[x], -x))</description></item><item><title>1637. Widest Vertical Area Between Two Points Containing No Points</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1637/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1637/</guid><description>LeetCode problem 1637
class Solution: def maxWidthOfVerticalArea(self, points: List[List[int]]) -&amp;gt; int: nums = [x for x, _ in points] n = len(nums) mi, mx = min(nums), max(nums) bucket_size = max(1, (mx - mi) // (n - 1)) bucket_count = (mx - mi) // bucket_size + 1 buckets = [[inf, -inf] for _ in range(bucket_count)] for x in nums: i = (x - mi) // bucket_size buckets[i][0] = min(buckets[i][0], x) buckets[i][1] = max(buckets[i][1], x) res = 0 prev = inf for curmin, curmax in buckets: if curmin &amp;gt; curmax: continue res = max(res, curmin - prev) prev = curmax return res</description></item><item><title>1640. Check Array Formation Through Concatenation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1640/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1640/</guid><description>LeetCode problem 1640
class Solution: def canFormArray(self, arr: List[int], pieces: List[List[int]]) -&amp;gt; bool: d = {p[0]: p for p in pieces} i, n = 0, len(arr) while i &amp;lt; n: if arr[i] not in d: return False p = d[arr[i]] if arr[i : i + len(p)] != p: return False i += len(p) return True</description></item><item><title>1646. Get Maximum in Generated Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1646/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1646/</guid><description>LeetCode problem 1646
class Solution: def getMaximumGenerated(self, n: int) -&amp;gt; int: if n &amp;lt; 2: return n nums = [0] * (n + 1) nums[1] = 1 for i in range(2, n + 1): nums[i] = nums[i &amp;gt;&amp;gt; 1] if i % 2 == 0 else nums[i &amp;gt;&amp;gt; 1] + nums[(i &amp;gt;&amp;gt; 1) + 1] return max(nums)</description></item><item><title>1652. Defuse the Bomb</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1652/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1652/</guid><description>LeetCode problem 1652
class Solution: def decrypt(self, code: List[int], k: int) -&amp;gt; List[int]: n = len(code) res = [0] * n if k == 0: return res s = list(accumulate(code + code, initial=0)) for i in range(n): if k &amp;gt; 0: res[i] = s[i + k + 1] - s[i + 1] else: res[i] = s[i + n] - s[i + k + n] return res</description></item><item><title>1656. Design an Ordered Stream</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1656/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1656/</guid><description>LeetCode problem 1656
class OrderedStream: def __init__(self, n: int): self.data = [None] * n self.ptr = 0 def insert(self, idKey: int, value: str) -&amp;gt; List[str]: self.data[idKey - 1] = value res = [] while self.ptr &amp;lt; len(self.data) and self.data[self.ptr]: res.append(self.data[self.ptr]) self.ptr += 1 return res # Your OrderedStream object will be instantiated and called as such: # obj = OrderedStream(n) # param_1 = obj.insert(idKey,value)</description></item><item><title>1662. Check If Two String Arrays are Equivalent</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1662/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1662/</guid><description>LeetCode problem 1662
class Solution: def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -&amp;gt; bool: i = j = x = y = 0 while i &amp;lt; len(word1) and j &amp;lt; len(word2): if word1[i][x] != word2[j][y]: return False x, y = x + 1, y + 1 if x == len(word1[i]): x, i = 0, i + 1 if y == len(word2[j]): y, j = 0, j + 1 return i == len(word1) and j == len(word2)</description></item><item><title>1668. Maximum Repeating Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1668/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1668/</guid><description>LeetCode problem 1668
class Solution: def maxRepeating(self, sequence: str, word: str) -&amp;gt; int: for k in range(len(sequence) // len(word), -1, -1): if word * k in sequence: return k</description></item><item><title>1672. Richest Customer Wealth</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1672/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1672/</guid><description>LeetCode problem 1672
class Solution: def maximumWealth(self, accounts: List[List[int]]) -&amp;gt; int: return max(sum(v) for v in accounts)</description></item><item><title>1678. Goal Parser Interpretation</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1678/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1678/</guid><description>LeetCode problem 1678
class Solution: def interpret(self, command: str) -&amp;gt; str: res = [] for i, c in enumerate(command): if c == &amp;#39;G&amp;#39;: res.append(c) elif c == &amp;#39;(&amp;#39;: res.append(&amp;#39;o&amp;#39; if command[i + 1] == &amp;#39;)&amp;#39; else &amp;#39;al&amp;#39;) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1684. Count the Number of Consistent Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1684/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1684/</guid><description>LeetCode problem 1684
class Solution: def countConsistentStrings(self, allowed: str, words: List[str]) -&amp;gt; int: def f(w): return reduce(or_, (1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) for c in w)) mask = f(allowed) return sum((mask | f(w)) == mask for w in words)</description></item><item><title>1688. Count of Matches in Tournament</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1688/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1688/</guid><description>LeetCode problem 1688
class Solution: def numberOfMatches(self, n: int) -&amp;gt; int: return n - 1</description></item><item><title>1694. Reformat Phone Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1694/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1694/</guid><description>LeetCode problem 1694
class Solution: def reformatNumber(self, number: str) -&amp;gt; str: number = number.replace(&amp;#34;-&amp;#34;, &amp;#34;&amp;#34;).replace(&amp;#34; &amp;#34;, &amp;#34;&amp;#34;) n = len(number) res = [number[i * 3 : i * 3 + 3] for i in range(n // 3)] if n % 3 == 1: res[-1] = res[-1][:2] res.append(number[-2:]) elif n % 3 == 2: res.append(number[-2:]) return &amp;#34;-&amp;#34;.join(res)</description></item><item><title>1700. Number of Students Unable to Eat Lunch</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1700/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1700/</guid><description>LeetCode problem 1700
class Solution: def countStudents(self, students: List[int], sandwiches: List[int]) -&amp;gt; int: cnt = Counter(students) for v in sandwiches: if cnt[v] == 0: return cnt[v ^ 1] cnt[v] -= 1 return 0</description></item><item><title>1704. Determine if String Halves Are Alike</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1704/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1704/</guid><description>LeetCode problem 1704
class Solution: def halvesAreAlike(self, s: str) -&amp;gt; bool: vowels = set(&amp;#39;aeiouAEIOU&amp;#39;) a, b = s[: len(s) &amp;gt;&amp;gt; 1], s[len(s) &amp;gt;&amp;gt; 1 :] return sum(c in vowels for c in a) == sum(c in vowels for c in b)</description></item><item><title>1708. Largest Subarray Length K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1708/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1708/</guid><description>LeetCode problem 1708
class Solution: def largestSubarray(self, nums: List[int], k: int) -&amp;gt; List[int]: i = nums.index(max(nums[: len(nums) - k + 1])) return nums[i : i + k]</description></item><item><title>1710. Maximum Units on a Truck</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1710/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1710/</guid><description>LeetCode problem 1710
class Solution: def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -&amp;gt; int: cnt = [0] * 1001 for a, b in boxTypes: cnt[b] += a res = 0 for b in range(1000, 0, -1): a = cnt[b] if a: res += b * min(truckSize, a) truckSize -= a if truckSize &amp;lt;= 0: break return res</description></item><item><title>1716. Calculate Money in Leetcode Bank</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1716/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1716/</guid><description>LeetCode problem 1716
class Solution: def totalMoney(self, n: int) -&amp;gt; int: a, b = divmod(n, 7) return (28 + 28 + 7 * (a - 1)) * a // 2 + (a * 2 + b + 1) * b // 2</description></item><item><title>1720. Decode XORed Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1720/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1720/</guid><description>LeetCode problem 1720
class Solution: def decode(self, encoded: List[int], first: int) -&amp;gt; List[int]: res = [first] for e in encoded: res.append(res[-1] ^ e) return res</description></item><item><title>1725. Number Of Rectangles That Can Form The Largest Square</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1725/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1725/</guid><description>LeetCode problem 1725
class Solution: def countGoodRectangles(self, rectangles: List[List[int]]) -&amp;gt; int: res = mx = 0 for l, w in rectangles: x = min(l, w) if mx &amp;lt; x: res = 1 mx = x elif mx == x: res += 1 return res</description></item><item><title>1732. Find the Highest Altitude</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1732/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1732/</guid><description>LeetCode problem
Problem Statement In this problem, we are given a biker who is going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal to 0.
We are also given an integer array gain of length n where gain[i] represents the net gain in altitude between points i and i + 1 for all 0 &amp;lt;= i &amp;lt; n. The net gain could be negative, indicating a decrease in altitude, or positive, indicating an increase in altitude.</description></item><item><title>1736. Latest Time by Replacing Hidden Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1736/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1736/</guid><description>LeetCode problem 1736
class Solution: def maximumTime(self, time: str) -&amp;gt; str: t = list(time) if t[0] == &amp;#39;?&amp;#39;: t[0] = &amp;#39;1&amp;#39; if &amp;#39;4&amp;#39; &amp;lt;= t[1] &amp;lt;= &amp;#39;9&amp;#39; else &amp;#39;2&amp;#39; if t[1] == &amp;#39;?&amp;#39;: t[1] = &amp;#39;3&amp;#39; if t[0] == &amp;#39;2&amp;#39; else &amp;#39;9&amp;#39; if t[3] == &amp;#39;?&amp;#39;: t[3] = &amp;#39;5&amp;#39; if t[4] == &amp;#39;?&amp;#39;: t[4] = &amp;#39;9&amp;#39; return &amp;#39;&amp;#39;.join(t)</description></item><item><title>1742. Maximum Number of Balls in a Box</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1742/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1742/</guid><description>LeetCode problem 1742
class Solution: def countBalls(self, lowLimit: int, highLimit: int) -&amp;gt; int: cnt = [0] * 50 for x in range(lowLimit, highLimit + 1): y = 0 while x: y += x % 10 x //= 10 cnt[y] += 1 return max(cnt)</description></item><item><title>1748. Sum of Unique Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1748/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1748/</guid><description>LeetCode problem 1748
class Solution: def sumOfUnique(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) return sum(x for x, v in cnt.items() if v == 1)</description></item><item><title>1752. Check if Array Is Sorted and Rotated</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1752/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1752/</guid><description>LeetCode problem 1752
class Solution: def check(self, nums: List[int]) -&amp;gt; bool: return sum(nums[i - 1] &amp;gt; v for i, v in enumerate(nums)) &amp;lt;= 1</description></item><item><title>1757. Recyclable and Low Fat Products</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1757/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1757/</guid><description>LeetCode problem 1757
import pandas as pd def find_products(products: pd.DataFrame) -&amp;gt; pd.DataFrame: rs = products[(products[&amp;#34;low_fats&amp;#34;] == &amp;#34;Y&amp;#34;) &amp;amp; (products[&amp;#34;recyclable&amp;#34;] == &amp;#34;Y&amp;#34;)] rs = rs[[&amp;#34;product_id&amp;#34;]] return rs</description></item><item><title>1758. Minimum Changes To Make Alternating Binary String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1758/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1758/</guid><description>LeetCode problem 1758
class Solution: def minOperations(self, s: str) -&amp;gt; int: cnt = sum(c != &amp;#39;01&amp;#39;[i &amp;amp; 1] for i, c in enumerate(s)) return min(cnt, len(s) - cnt)</description></item><item><title>1763. Longest Nice Substring</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1763/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1763/</guid><description>LeetCode problem 1763
class Solution: def longestNiceSubstring(self, s: str) -&amp;gt; str: n = len(s) res = &amp;#39;&amp;#39; for i in range(n): lower = upper = 0 for j in range(i, n): if s[j].islower(): lower |= 1 &amp;lt;&amp;lt; (ord(s[j]) - ord(&amp;#39;a&amp;#39;)) else: upper |= 1 &amp;lt;&amp;lt; (ord(s[j]) - ord(&amp;#39;A&amp;#39;)) if lower == upper and len(res) &amp;lt; j - i + 1: res = s[i : j + 1] return res</description></item><item><title>1768. Merge Strings Alternately</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1768/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1768/</guid><description>LeetCode problem
Problem Statement The task is to merge two strings alternately, i.e., take one character from the first string, then one from the second, then again from the first, and so on. If one string finishes before the other, the remaining characters from the longer string are appended at the end.
Naive Solution A naive approach could involve maintaining two pointers, one for each string, and incrementally appending characters from each string to the result. Once we reach the end of one string, we append the rest of the other string to the result.</description></item><item><title>1773. Count Items Matching a Rule</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1773/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1773/</guid><description>LeetCode problem 1773
class Solution: def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -&amp;gt; int: i = 0 if ruleKey[0] == &amp;#39;t&amp;#39; else (1 if ruleKey[0] == &amp;#39;c&amp;#39; else 2) return sum(v[i] == ruleValue for v in items)</description></item><item><title>1779. Find Nearest Point That Has the Same X or Y Coordinate</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1779/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1779/</guid><description>LeetCode problem 1779
class Solution: def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -&amp;gt; int: res, mi = -1, inf for i, (a, b) in enumerate(points): if a == x or b == y: d = abs(a - x) + abs(b - y) if mi &amp;gt; d: res, mi = i, d return res</description></item><item><title>1784. Check if Binary String Has at Most One Segment of Ones</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1784/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1784/</guid><description>LeetCode problem 1784
class Solution: def checkOnesSegment(self, s: str) -&amp;gt; bool: return &amp;#39;01&amp;#39; not in s</description></item><item><title>1790. Check if One String Swap Can Make Strings Equal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1790/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1790/</guid><description>LeetCode problem 1790
class Solution: def areAlmostEqual(self, s1: str, s2: str) -&amp;gt; bool: cnt = 0 c1 = c2 = None for a, b in zip(s1, s2): if a != b: cnt += 1 if cnt &amp;gt; 2 or (cnt == 2 and (a != c2 or b != c1)): return False c1, c2 = a, b return cnt != 1</description></item><item><title>1791. Find Center of Star Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1791/</guid><description>LeetCode problem 1791
class Solution: def findCenter(self, edges: List[List[int]]) -&amp;gt; int: return edges[0][0] if edges[0][0] in edges[1] else edges[0][1]</description></item><item><title>1796. Second Largest Digit in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1796/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1796/</guid><description>LeetCode problem 1796
class Solution: def secondHighest(self, s: str) -&amp;gt; int: mask = reduce(or_, (1 &amp;lt;&amp;lt; int(c) for c in s if c.isdigit()), 0) cnt = 0 for i in range(9, -1, -1): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: cnt += 1 if cnt == 2: return i return -1</description></item><item><title>1800. Maximum Ascending Subarray Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1800/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1800/</guid><description>LeetCode problem 1800
class Solution: def maxAscendingSum(self, nums: List[int]) -&amp;gt; int: res = t = 0 for i, v in enumerate(nums): if i == 0 or v &amp;gt; nums[i - 1]: t += v res = max(res, t) else: t = v return res</description></item><item><title>1805. Number of Different Integers in a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1805/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1805/</guid><description>LeetCode problem 1805
class Solution: def numDifferentIntegers(self, word: str) -&amp;gt; int: s = set() i, n = 0, len(word) while i &amp;lt; n: if word[i].isdigit(): while i &amp;lt; n and word[i] == &amp;#39;0&amp;#39;: i += 1 j = i while j &amp;lt; n and word[j].isdigit(): j += 1 s.add(word[i:j]) i = j i += 1 return len(s)</description></item><item><title>1812. Determine Color of a Chessboard Square</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1812/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1812/</guid><description>LeetCode problem 1812
class Solution: def squareIsWhite(self, coordinates: str) -&amp;gt; bool: return (ord(coordinates[0]) + ord(coordinates[1])) % 2 == 1</description></item><item><title>1816. Truncate Sentence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1816/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1816/</guid><description>LeetCode problem 1816
class Solution: def truncateSentence(self, s: str, k: int) -&amp;gt; str: for i, c in enumerate(s): k -= c == &amp;#39; &amp;#39; if k == 0: return s[:i] return s</description></item><item><title>1822. Sign of the Product of an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1822/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1822/</guid><description>LeetCode problem 1822
class Solution: def arraySign(self, nums: List[int]) -&amp;gt; int: res = 1 for v in nums: if v == 0: return 0 if v &amp;lt; 0: res *= -1 return res</description></item><item><title>1826. Faulty Sensor</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1826/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1826/</guid><description>LeetCode problem 1826
class Solution: def badSensor(self, sensor1: List[int], sensor2: List[int]) -&amp;gt; int: i, n = 0, len(sensor1) while i &amp;lt; n - 1: if sensor1[i] != sensor2[i]: break i += 1 while i &amp;lt; n - 1: if sensor1[i + 1] != sensor2[i]: return 1 if sensor1[i] != sensor2[i + 1]: return 2 i += 1 return -1</description></item><item><title>1929. Concatenation of Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1929/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1929/</guid><description>LeetCode problem 1929
class Solution: def getConcatenation(self, nums: List[int]) -&amp;gt; List[int]: return nums + nums</description></item><item><title>1933. Check if String Is Decomposable Into Value-Equal Substrings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1933/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1933/</guid><description>LeetCode problem 1933
class Solution: def isDecomposable(self, s: str) -&amp;gt; bool: cnt2 = 0 for _, g in groupby(s): m = len(list(g)) if m % 3 == 1: return False cnt2 += m % 3 == 2 if cnt2 &amp;gt; 1: return False return cnt2 == 1</description></item><item><title>1935. Maximum Number of Words You Can Type</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1935/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1935/</guid><description>LeetCode problem 1935
class Solution: def canBeTypedWords(self, text: str, brokenLetters: str) -&amp;gt; int: s = set(brokenLetters) return sum(all(c not in s for c in w) for w in text.split())</description></item><item><title>1941. Check if All Characters Have Equal Number of Occurrences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1941/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1941/</guid><description>LeetCode problem 1941
class Solution: def areOccurrencesEqual(self, s: str) -&amp;gt; bool: cnt = Counter(s) return len(set(cnt.values())) == 1</description></item><item><title>1945. Sum of Digits of String After Convert</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1945/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1945/</guid><description>LeetCode problem 1945
class Solution: def getLucky(self, s: str, k: int) -&amp;gt; int: s = &amp;#39;&amp;#39;.join(str(ord(c) - ord(&amp;#39;a&amp;#39;) + 1) for c in s) for _ in range(k): t = sum(int(c) for c in s) s = str(t) return int(s)</description></item><item><title>1952. Three Divisors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1952/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1952/</guid><description>LeetCode problem 1952
class Solution: def isThree(self, n: int) -&amp;gt; bool: cnt = 0 i = 1 while i &amp;lt;= n // i: if n % i == 0: cnt += 1 if i == n // i else 2 i += 1 return cnt == 3</description></item><item><title>1957. Delete Characters to Make Fancy String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1957/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1957/</guid><description>LeetCode problem 1957
class Solution: def makeFancyString(self, s: str) -&amp;gt; str: res = [] for c in s: if len(res) &amp;gt; 1 and res[-1] == res[-2] == c: continue res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1961. Check If String Is a Prefix of Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1961/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1961/</guid><description>LeetCode problem 1961
class Solution: def isPrefixString(self, s: str, words: List[str]) -&amp;gt; bool: n, m = len(s), 0 for i, w in enumerate(words): m += len(w) if m == n: return &amp;#34;&amp;#34;.join(words[: i + 1]) == s return False</description></item><item><title>1967. Number of Strings That Appear as Substrings in Word</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1967/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1967/</guid><description>LeetCode problem 1967
class Solution: def numOfStrings(self, patterns: List[str], word: str) -&amp;gt; int: return sum(p in word for p in patterns)</description></item><item><title>1971. Find if Path Exists in Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1971/</guid><description>LeetCode problem 1971
class Solution: def validPath( self, n: int, edges: List[List[int]], source: int, destination: int ) -&amp;gt; bool: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(n)) for u, v in edges: p[find(u)] = find(v) return find(source) == find(destination)</description></item><item><title>1974. Minimum Time to Type Word Using Special Typewriter</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1974/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1974/</guid><description>LeetCode problem 1974
class Solution: def minTimeToType(self, word: str) -&amp;gt; int: res = prev = 0 for c in word: curr = ord(c) - ord(&amp;#39;a&amp;#39;) t = abs(prev - curr) t = min(t, 26 - t) res += t + 1 prev = curr return res</description></item><item><title>1979. Find Greatest Common Divisor of Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1979/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1979/</guid><description>LeetCode problem 1979
class Solution: def findGCD(self, nums: List[int]) -&amp;gt; int: return gcd(max(nums), min(nums))</description></item><item><title>1984. Minimum Difference Between Highest and Lowest of K Scores</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1984/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1984/</guid><description>LeetCode problem 1984
class Solution: def minimumDifference(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() return min(nums[i + k - 1] - nums[i] for i in range(len(nums) - k + 1))</description></item><item><title>1991. Find the Middle Index in Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1991/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1991/</guid><description>LeetCode problem 1991
class Solution: def findMiddleIndex(self, nums: List[int]) -&amp;gt; int: left, right = 0, sum(nums) for i, x in enumerate(nums): right -= x if left == right: return i left += x return -1</description></item><item><title>1995. Count Special Quadruplets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1995/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/1995/</guid><description>LeetCode problem 1995
class Solution: def countQuadruplets(self, nums: List[int]) -&amp;gt; int: res, n = 0, len(nums) counter = Counter() for b in range(n - 3, 0, -1): c = b + 1 for d in range(c + 1, n): counter[nums[d] - nums[c]] += 1 for a in range(b): res += counter[nums[a] + nums[b]] return res</description></item><item><title>2000. Reverse Prefix of Word</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2000/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2000/</guid><description>LeetCode problem 2000
class Solution: def reversePrefix(self, word: str, ch: str) -&amp;gt; str: i = word.find(ch) return word if i == -1 else word[i::-1] + word[i + 1 :]</description></item><item><title>2006. Count Number of Pairs With Absolute Difference K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2006/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2006/</guid><description>LeetCode problem 2006
class Solution: def countKDifference(self, nums: List[int], k: int) -&amp;gt; int: res = 0 cnt = Counter() for num in nums: res += cnt[num - k] + cnt[num + k] cnt[num] += 1 return res</description></item><item><title>2011. Final Value of Variable After Performing Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2011/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2011/</guid><description>LeetCode problem 2011
class Solution: def finalValueAfterOperations(self, operations: List[str]) -&amp;gt; int: return sum(1 if s[1] == &amp;#39;+&amp;#39; else -1 for s in operations)</description></item><item><title>2016. Maximum Difference Between Increasing Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2016/</guid><description>LeetCode problem 2016
class Solution: def maximumDifference(self, nums: List[int]) -&amp;gt; int: mi = inf res = -1 for x in nums: if x &amp;gt; mi: res = max(res, x - mi) else: mi = x return res</description></item><item><title>2027. Minimum Moves to Convert String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2027/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2027/</guid><description>LeetCode problem 2027
class Solution: def minimumMoves(self, s: str) -&amp;gt; int: res = i = 0 while i &amp;lt; len(s): if s[i] == &amp;#34;X&amp;#34;: res += 1 i += 3 else: i += 1 return res</description></item><item><title>2032. Two Out of Three</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2032/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2032/</guid><description>LeetCode problem 2032
class Solution: def twoOutOfThree( self, nums1: List[int], nums2: List[int], nums3: List[int] ) -&amp;gt; List[int]: s1, s2, s3 = set(nums1), set(nums2), set(nums3) return [i for i in range(1, 101) if (i in s1) + (i in s2) + (i in s3) &amp;gt; 1]</description></item><item><title>2037. Minimum Number of Moves to Seat Everyone</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2037/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2037/</guid><description>LeetCode problem 2037
class Solution: def minMovesToSeat(self, seats: List[int], students: List[int]) -&amp;gt; int: seats.sort() students.sort() return sum(abs(a - b) for a, b in zip(seats, students))</description></item><item><title>2042. Check if Numbers Are Ascending in a Sentence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2042/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2042/</guid><description>LeetCode problem 2042
class Solution: def areNumbersAscending(self, s: str) -&amp;gt; bool: pre = i = 0 n = len(s) while i &amp;lt; n: if s[i].isdigit(): cur = 0 while i &amp;lt; n and s[i].isdigit(): cur = cur * 10 + int(s[i]) i += 1 if pre &amp;gt;= cur: return False pre = cur else: i += 1 return True</description></item><item><title>2047. Number of Valid Words in a Sentence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2047/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2047/</guid><description>LeetCode problem 2047
class Solution: def countValidWords(self, sentence: str) -&amp;gt; int: def check(token): hyphen = False for i, c in enumerate(token): if c.isdigit() or (c in &amp;#39;!.,&amp;#39; and i &amp;lt; len(token) - 1): return False if c == &amp;#39;-&amp;#39;: if ( hyphen or i == 0 or i == len(token) - 1 or not token[i - 1].islower() or not token[i + 1].islower() ): return False hyphen = True return True return sum(check(token) for token in sentence.split())</description></item><item><title>2053. Kth Distinct String in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2053/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2053/</guid><description>LeetCode problem 2053
class Solution: def kthDistinct(self, arr: List[str], k: int) -&amp;gt; str: counter = Counter(arr) for v in arr: if counter[v] == 1: k -= 1 if k == 0: return v return &amp;#39;&amp;#39;</description></item><item><title>2057. Smallest Index With Equal Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2057/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2057/</guid><description>LeetCode problem 2057
class Solution: def smallestEqual(self, nums: List[int]) -&amp;gt; int: for i, v in enumerate(nums): if i % 10 == v: return i return -1</description></item><item><title>2062. Count Vowel Substrings of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2062/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2062/</guid><description>LeetCode problem 2062
class Solution: def countVowelSubstrings(self, word: str) -&amp;gt; int: s = set(&amp;#39;aeiou&amp;#39;) res, n = 0, len(word) for i in range(n): t = set() for c in word[i:]: if c not in s: break t.add(c) res += len(t) == 5 return res</description></item><item><title>2068. Check Whether Two Strings are Almost Equivalent</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2068/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2068/</guid><description>LeetCode problem 2068
class Solution: def checkAlmostEquivalent(self, word1: str, word2: str) -&amp;gt; bool: cnt = Counter(word1) for c in word2: cnt[c] -= 1 return all(abs(x) &amp;lt;= 3 for x in cnt.values())</description></item><item><title>2073. Time Needed to Buy Tickets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2073/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2073/</guid><description>LeetCode problem 2073
class Solution: def timeRequiredToBuy(self, tickets: List[int], k: int) -&amp;gt; int: res = 0 for i, t in enumerate(tickets): if i &amp;lt;= k: res += min(tickets[k], t) else: res += min(tickets[k] - 1, t) return res</description></item><item><title>2078. Two Furthest Houses With Different Colors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2078/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2078/</guid><description>LeetCode problem 2078
class Solution: def maxDistance(self, colors: List[int]) -&amp;gt; int: n = len(colors) if colors[0] != colors[-1]: return n - 1 i, j = 1, n - 2 while colors[i] == colors[0]: i += 1 while colors[j] == colors[0]: j -= 1 return max(n - i - 1, j)</description></item><item><title>2085. Count Common Words With One Occurrence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2085/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2085/</guid><description>LeetCode problem 2085
class Solution: def countWords(self, words1: List[str], words2: List[str]) -&amp;gt; int: cnt1 = Counter(words1) cnt2 = Counter(words2) return sum(v == 1 and cnt2[w] == 1 for w, v in cnt1.items())</description></item><item><title>2089. Find Target Indices After Sorting Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2089/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2089/</guid><description>LeetCode problem 2089
class Solution: def targetIndices(self, nums: List[int], target: int) -&amp;gt; List[int]: nums.sort() return [i for i, v in enumerate(nums) if v == target]</description></item><item><title>2099. Find Subsequence of Length K With the Largest Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2099/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2099/</guid><description>LeetCode problem 2099
class Solution: def maxSubsequence(self, nums: List[int], k: int) -&amp;gt; List[int]: idx = list(range(len(nums))) idx.sort(key=lambda i: nums[i]) return [nums[i] for i in sorted(idx[-k:])]</description></item><item><title>2103. Rings and Rods</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2103/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2103/</guid><description>LeetCode problem 2103
class Solution: def countPoints(self, rings: str) -&amp;gt; int: mask = [0] * 10 d = {&amp;#34;R&amp;#34;: 1, &amp;#34;G&amp;#34;: 2, &amp;#34;B&amp;#34;: 4} for i in range(0, len(rings), 2): c = rings[i] j = int(rings[i + 1]) mask[j] |= d[c] return mask.count(7)</description></item><item><title>2108. Find First Palindromic String in the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2108/</guid><description>LeetCode problem 2108
class Solution: def firstPalindrome(self, words: List[str]) -&amp;gt; str: return next((w for w in words if w == w[::-1]), &amp;#34;&amp;#34;)</description></item><item><title>2114. Maximum Number of Words Found in Sentences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2114/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2114/</guid><description>LeetCode problem 2114
class Solution: def mostWordsFound(self, sentences: List[str]) -&amp;gt; int: return 1 + max(s.count(&amp;#39; &amp;#39;) for s in sentences)</description></item><item><title>2119. A Number After a Double Reversal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2119/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2119/</guid><description>LeetCode problem 2119
class Solution: def isSameAfterReversals(self, num: int) -&amp;gt; bool: return num == 0 or num % 10 != 0</description></item><item><title>2124. Check if All A's Appears Before All B's</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2124/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2124/</guid><description>LeetCode problem 2124
class Solution: def checkString(self, s: str) -&amp;gt; bool: return &amp;#34;ba&amp;#34; not in s</description></item><item><title>2129. Capitalize the Title</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2129/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2129/</guid><description>LeetCode problem 2129
class Solution: def capitalizeTitle(self, title: str) -&amp;gt; str: words = [w.lower() if len(w) &amp;lt; 3 else w.capitalize() for w in title.split()] return &amp;#34; &amp;#34;.join(words)</description></item><item><title>2133. Check if Every Row and Column Contains All Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2133/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2133/</guid><description>LeetCode problem 2133
class Solution: def checkValid(self, matrix: List[List[int]]) -&amp;gt; bool: n = len(matrix) for i in range(n): seen = [False] * n for j in range(n): v = matrix[i][j] - 1 if seen[v]: return False seen[v] = True for j in range(n): seen = [False] * n for i in range(n): v = matrix[i][j] - 1 if seen[v]: return False seen[v] = True return True</description></item><item><title>2138. Divide a String Into Groups of Size k</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2138/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2138/</guid><description>LeetCode problem 2138
class Solution: def divideString(self, s: str, k: int, fill: str) -&amp;gt; List[str]: return [s[i : i + k].ljust(k, fill) for i in range(0, len(s), k)]</description></item><item><title>2144. Minimum Cost of Buying Candies With Discount</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2144/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2144/</guid><description>LeetCode problem 2144
class Solution: def minimumCost(self, cost: List[int]) -&amp;gt; int: cost.sort(reverse=True) return sum(cost) - sum(cost[2::3])</description></item><item><title>2148. Count Elements With Strictly Smaller and Greater Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2148/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2148/</guid><description>LeetCode problem 2148
class Solution: def countElements(self, nums: List[int]) -&amp;gt; int: mi, mx = min(nums), max(nums) return sum(mi &amp;lt; num &amp;lt; mx for num in nums)</description></item><item><title>2154. Keep Multiplying Found Values by Two</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2154/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2154/</guid><description>LeetCode problem 2154
class Solution: def findFinalValue(self, nums: List[int], original: int) -&amp;gt; int: s = set(nums) while original in s: original &amp;lt;&amp;lt;= 1 return original</description></item><item><title>2160. Minimum Sum of Four Digit Number After Splitting Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2160/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2160/</guid><description>LeetCode problem 2160
class Solution: def minimumSum(self, num: int) -&amp;gt; int: nums = [] while num: nums.append(num % 10) num //= 10 nums.sort() return 10 * (nums[0] + nums[1]) + nums[2] + nums[3]</description></item><item><title>2164. Sort Even and Odd Indices Independently</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2164/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2164/</guid><description>LeetCode problem 2164
class Solution: def sortEvenOdd(self, nums: List[int]) -&amp;gt; List[int]: a = sorted(nums[::2]) b = sorted(nums[1::2], reverse=True) nums[::2] = a nums[1::2] = b return nums</description></item><item><title>2169. Count Operations to Obtain Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2169/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2169/</guid><description>LeetCode problem 2169
class Solution: def countOperations(self, num1: int, num2: int) -&amp;gt; int: res = 0 while num1 and num2: if num1 &amp;gt;= num2: num1, num2 = num2, num1 num2 -= num1 res += 1 return res</description></item><item><title>2176. Count Equal and Divisible Pairs in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2176/</guid><description>LeetCode problem 2176
class Solution: def countPairs(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) return sum( nums[i] == nums[j] and (i * j) % k == 0 for i in range(n) for j in range(i + 1, n) )</description></item><item><title>2180. Count Integers With Even Digit Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2180/</guid><description>LeetCode problem 2180
class Solution: def countEven(self, num: int) -&amp;gt; int: res = num // 10 * 5 - 1 x, s = num // 10, 0 while x: s += x % 10 x //= 10 res += (num % 10 + 2 - (s &amp;amp; 1)) &amp;gt;&amp;gt; 1 return res</description></item><item><title>2185. Counting Words With a Given Prefix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2185/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2185/</guid><description>LeetCode problem 2185
class Trie: def __init__(self): self.children = [None] * 26 self.cnt = 0 def insert(self, w): node = self for c in w: i = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[i] is None: node.children[i] = Trie() node = node.children[i] node.cnt += 1 def search(self, pref): node = self for c in pref: i = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[i] is None: return 0 node = node.children[i] return node.cnt class Solution: def prefixCount(self, words: List[str], pref: str) -&amp;gt; int: tree = Trie() for w in words: tree.</description></item><item><title>2190. Most Frequent Number Following Key In an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2190/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2190/</guid><description>LeetCode problem 2190
class Solution: def mostFrequent(self, nums: List[int], key: int) -&amp;gt; int: cnt = Counter() res = mx = 0 for a, b in pairwise(nums): if a == key: cnt[b] += 1 if mx &amp;lt; cnt[b]: mx = cnt[b] res = b return res</description></item><item><title>2194. Cells in a Range on an Excel Sheet</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2194/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2194/</guid><description>LeetCode problem 2194
class Solution: def cellsInRange(self, s: str) -&amp;gt; List[str]: return [ chr(i) + str(j) for i in range(ord(s[0]), ord(s[-2]) + 1) for j in range(int(s[1]), int(s[-1]) + 1) ]</description></item><item><title>2200. Find All K-Distant Indices in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2200/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2200/</guid><description>LeetCode problem 2200
class Solution: def findKDistantIndices(self, nums: List[int], key: int, k: int) -&amp;gt; List[int]: res = [] j, n = 0, len(nums) for i in range(n): while j &amp;lt; i - k or (j &amp;lt; n and nums[j] != key): j += 1 if j &amp;lt; n and j &amp;lt;= (i + k): res.append(i) return res</description></item><item><title>2206. Divide Array Into Equal Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2206/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2206/</guid><description>LeetCode problem 2206
class Solution: def divideArray(self, nums: List[int]) -&amp;gt; bool: cnt = Counter(nums) return all(v % 2 == 0 for v in cnt.values())</description></item><item><title>2210. Count Hills and Valleys in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2210/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2210/</guid><description>LeetCode problem 2210
class Solution: def countHillValley(self, nums: List[int]) -&amp;gt; int: res = j = 0 for i in range(1, len(nums) - 1): if nums[i] == nums[i + 1]: continue if nums[i] &amp;gt; nums[j] and nums[i] &amp;gt; nums[i + 1]: res += 1 if nums[i] &amp;lt; nums[j] and nums[i] &amp;lt; nums[i + 1]: res += 1 j = i return res</description></item><item><title>2215. Find the Difference of Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2215/</guid><description>LeetCode problem
Problem Statement Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:
answer[0] is a list of all distinct integers in nums1 which are not present in nums2. answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order.
Naive Solution A naive approach would be to iterate over each element of the first array and check whether it&amp;rsquo;s in the second array.</description></item><item><title>2220. Minimum Bit Flips to Convert Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2220/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2220/</guid><description>LeetCode problem 2220
class Solution: def minBitFlips(self, start: int, goal: int) -&amp;gt; int: t = start ^ goal res = 0 while t: res += t &amp;amp; 1 t &amp;gt;&amp;gt;= 1 return res</description></item><item><title>2224. Minimum Number of Operations to Convert Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2224/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2224/</guid><description>LeetCode problem 2224
class Solution: def convertTime(self, current: str, correct: str) -&amp;gt; int: a = int(current[:2]) * 60 + int(current[3:]) b = int(correct[:2]) * 60 + int(correct[3:]) res, d = 0, b - a for i in [60, 15, 5, 1]: res += d // i d %= i return res</description></item><item><title>2229. Check if an Array Is Consecutive</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2229/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2229/</guid><description>LeetCode problem 2229
class Solution: def isConsecutive(self, nums: List[int]) -&amp;gt; bool: mi, mx = min(nums), max(nums) n = len(nums) return len(set(nums)) == n and mx == mi + n - 1</description></item><item><title>2231. Largest Number After Digit Swaps by Parity</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2231/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2231/</guid><description>LeetCode problem 2231
class Solution: def largestInteger(self, num: int) -&amp;gt; int: cnt = Counter() x = num while x: x, v = divmod(x, 10) cnt[v] += 1 x = num res = 0 t = 1 while x: x, v = divmod(x, 10) for y in range(10): if ((v ^ y) &amp;amp; 1) == 0 and cnt[y]: res += y * t t *= 10 cnt[y] -= 1 break return res</description></item><item><title>2235. Add Two Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2235/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2235/</guid><description>LeetCode problem 2235
class Solution: def sum(self, num1: int, num2: int) -&amp;gt; int: num1, num2 = num1 &amp;amp; 0xFFFFFFFF, num2 &amp;amp; 0xFFFFFFFF while num2: carry = ((num1 &amp;amp; num2) &amp;lt;&amp;lt; 1) &amp;amp; 0xFFFFFFFF num1, num2 = num1 ^ num2, carry return num1 if num1 &amp;lt; 0x80000000 else ~(num1 ^ 0xFFFFFFFF)</description></item><item><title>2236. Root Equals Sum of Children</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2236/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2236/</guid><description>LeetCode problem 2236
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def checkTree(self, root: Optional[TreeNode]) -&amp;gt; bool: return root.val == root.left.val + root.right.val</description></item><item><title>2239. Find Closest Number to Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2239/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2239/</guid><description>LeetCode problem 2239
class Solution: def findClosestNumber(self, nums: List[int]) -&amp;gt; int: res, d = 0, inf for x in nums: if (y := abs(x)) &amp;lt; d or (y == d and x &amp;gt; res): res, d = x, y return res</description></item><item><title>2243. Calculate Digit Sum of a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2243/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2243/</guid><description>LeetCode problem 2243
class Solution: def digitSum(self, s: str, k: int) -&amp;gt; str: if len(s) &amp;lt;= k: return s t = [] while s: t.append(str(sum(int(v) for v in s[:k]))) s = s[k:] return self.digitSum(&amp;#39;&amp;#39;.join(t), k)</description></item><item><title>2248. Intersection of Multiple Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2248/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2248/</guid><description>LeetCode problem 2248
class Solution: def intersection(self, nums: List[List[int]]) -&amp;gt; List[int]: cnt = Counter() res = [] for arr in nums: for x in arr: cnt[x] += 1 if cnt[x] == len(nums): res.append(x) res.sort() return res</description></item><item><title>2255. Count Prefixes of a Given String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2255/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2255/</guid><description>LeetCode problem 2255
class Solution: def countPrefixes(self, words: List[str], s: str) -&amp;gt; int: return sum(s.startswith(w) for w in words)</description></item><item><title>2259. Remove Digit From Number to Maximize Result</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2259/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2259/</guid><description>LeetCode problem 2259
class Solution: def removeDigit(self, number: str, digit: str) -&amp;gt; str: last = -1 n = len(number) for i, d in enumerate(number): if d == digit: last = i if i + 1 &amp;lt; n and d &amp;lt; number[i + 1]: break return number[:last] + number[last + 1 :]</description></item><item><title>2269. Find the K-Beauty of a Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2269/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2269/</guid><description>LeetCode problem 2269
class Solution: def divisorSubstrings(self, num: int, k: int) -&amp;gt; int: res = 0 s = str(num) for i in range(len(s) - k + 1): t = int(s[i : i + k]) if t and num % t == 0: res += 1 return res</description></item><item><title>2273. Find Resultant Array After Removing Anagrams</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2273/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2273/</guid><description>LeetCode problem 2273
class Solution: def removeAnagrams(self, words: List[str]) -&amp;gt; List[str]: return [ w for i, w in enumerate(words) if i == 0 or sorted(w) != sorted(words[i - 1]) ]</description></item><item><title>2278. Percentage of Letter in String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2278/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2278/</guid><description>LeetCode problem 2278
class Solution: def percentageLetter(self, s: str, letter: str) -&amp;gt; int: return s.count(letter) * 100 // len(s)</description></item><item><title>2283. Check if Number Has Equal Digit Count and Digit Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2283/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2283/</guid><description>LeetCode problem 2283
class Solution: def digitCount(self, num: str) -&amp;gt; bool: cnt = Counter(num) return all(cnt[str(i)] == int(v) for i, v in enumerate(num))</description></item><item><title>2287. Rearrange Characters to Make Target String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2287/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2287/</guid><description>LeetCode problem 2287
class Solution: def rearrangeCharacters(self, s: str, target: str) -&amp;gt; int: cnt1 = Counter(s) cnt2 = Counter(target) return min(cnt1[c] // v for c, v in cnt2.items())</description></item><item><title>2293. Min Max Game</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2293/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2293/</guid><description>LeetCode problem 2293
class Solution: def minMaxGame(self, nums: List[int]) -&amp;gt; int: n = len(nums) while n &amp;gt; 1: n &amp;gt;&amp;gt;= 1 for i in range(n): a, b = nums[i &amp;lt;&amp;lt; 1], nums[i &amp;lt;&amp;lt; 1 | 1] nums[i] = min(a, b) if i % 2 == 0 else max(a, b) return nums[0]</description></item><item><title>2299. Strong Password Checker II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2299/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2299/</guid><description>LeetCode problem 2299
class Solution: def strongPasswordCheckerII(self, password: str) -&amp;gt; bool: if len(password) &amp;lt; 8: return False mask = 0 for i, c in enumerate(password): if i and c == password[i - 1]: return False if c.islower(): mask |= 1 elif c.isupper(): mask |= 2 elif c.isdigit(): mask |= 4 else: mask |= 8 return mask == 15</description></item><item><title>2303. Calculate Amount Paid in Taxes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2303/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2303/</guid><description>LeetCode problem 2303
class Solution: def calculateTax(self, brackets: List[List[int]], income: int) -&amp;gt; float: res = prev = 0 for upper, percent in brackets: res += max(0, min(income, upper) - prev) * percent prev = upper return res / 100</description></item><item><title>2309. Greatest English Letter in Upper and Lower Case</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2309/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2309/</guid><description>LeetCode problem 2309
class Solution: def greatestLetter(self, s: str) -&amp;gt; str: mask1 = mask2 = 0 for c in s: if c.islower(): mask1 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) else: mask2 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;A&amp;#34;)) mask = mask1 &amp;amp; mask2 return chr(mask.bit_length() - 1 + ord(&amp;#34;A&amp;#34;)) if mask else &amp;#34;&amp;#34;</description></item><item><title>2315. Count Asterisks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2315/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2315/</guid><description>LeetCode problem 2315
class Solution: def countAsterisks(self, s: str) -&amp;gt; int: res, ok = 0, 1 for c in s: if c == &amp;#34;*&amp;#34;: res += ok elif c == &amp;#34;|&amp;#34;: ok ^= 1 return res</description></item><item><title>2319. Check if Matrix Is X-Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2319/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2319/</guid><description>LeetCode problem 2319
class Solution: def checkXMatrix(self, grid: List[List[int]]) -&amp;gt; bool: for i, row in enumerate(grid): for j, v in enumerate(row): if i == j or i + j == len(grid) - 1: if v == 0: return False elif v: return False return True</description></item><item><title>2325. Decode the Message</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2325/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2325/</guid><description>LeetCode problem 2325
class Solution: def decodeMessage(self, key: str, message: str) -&amp;gt; str: d = {&amp;#34; &amp;#34;: &amp;#34; &amp;#34;} i = 0 for c in key: if c not in d: d[c] = ascii_lowercase[i] i += 1 return &amp;#34;&amp;#34;.join(d[c] for c in message)</description></item><item><title>2331. Evaluate Boolean Binary Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2331/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2331/</guid><description>LeetCode problem 2331
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def evaluateTree(self, root: Optional[TreeNode]) -&amp;gt; bool: if root.left is None: return bool(root.val) l = self.evaluateTree(root.left) r = self.evaluateTree(root.right) return l or r if root.val == 2 else l and r</description></item><item><title>2335. Minimum Amount of Time to Fill Cups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2335/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2335/</guid><description>LeetCode problem 2335
class Solution: def fillCups(self, amount: List[int]) -&amp;gt; int: amount.sort() if amount[0] + amount[1] &amp;lt;= amount[2]: return amount[2] return (sum(amount) + 1) // 2</description></item><item><title>2341. Maximum Number of Pairs in Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2341/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2341/</guid><description>LeetCode problem 2341
class Solution: def numberOfPairs(self, nums: List[int]) -&amp;gt; List[int]: cnt = Counter(nums) s = sum(v // 2 for v in cnt.values()) return [s, len(nums) - s * 2]</description></item><item><title>2347. Best Poker Hand</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2347/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2347/</guid><description>LeetCode problem 2347
class Solution: def bestHand(self, ranks: List[int], suits: List[str]) -&amp;gt; str: # if len(set(suits)) == 1: if all(a == b for a, b in pairwise(suits)): return &amp;#39;Flush&amp;#39; cnt = Counter(ranks) if any(v &amp;gt;= 3 for v in cnt.values()): return &amp;#39;Three of a Kind&amp;#39; if any(v == 2 for v in cnt.values()): return &amp;#39;Pair&amp;#39; return &amp;#39;High Card&amp;#39;</description></item><item><title>2351. First Letter to Appear Twice</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2351/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2351/</guid><description>LeetCode problem 2351
class Solution: def repeatedCharacter(self, s: str) -&amp;gt; str: mask = 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if mask &amp;gt;&amp;gt; i &amp;amp; 1: return c mask |= 1 &amp;lt;&amp;lt; i</description></item><item><title>2357. Make Array Zero by Subtracting Equal Amounts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2357/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2357/</guid><description>LeetCode problem 2357
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: return len({x for x in nums if x})</description></item><item><title>2363. Merge Similar Items</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2363/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2363/</guid><description>LeetCode problem 2363
class Solution: def mergeSimilarItems( self, items1: List[List[int]], items2: List[List[int]] ) -&amp;gt; List[List[int]]: cnt = Counter() for v, w in chain(items1, items2): cnt[v] += w return sorted(cnt.items())</description></item><item><title>2367. Number of Arithmetic Triplets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2367/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2367/</guid><description>LeetCode problem 2367
class Solution: def arithmeticTriplets(self, nums: List[int], diff: int) -&amp;gt; int: vis = set(nums) return sum(x + diff in vis and x + diff * 2 in vis for x in nums)</description></item><item><title>2373. Largest Local Values in a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2373/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2373/</guid><description>LeetCode problem 2373
class Solution: def largestLocal(self, grid: List[List[int]]) -&amp;gt; List[List[int]]: n = len(grid) res = [[0] * (n - 2) for _ in range(n - 2)] for i in range(n - 2): for j in range(n - 2): res[i][j] = max( grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3) ) return res</description></item><item><title>2379. Minimum Recolors to Get K Consecutive Black Blocks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2379/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2379/</guid><description>LeetCode problem 2379
class Solution: def minimumRecolors(self, blocks: str, k: int) -&amp;gt; int: res = cnt = blocks[:k].count(&amp;#39;W&amp;#39;) for i in range(k, len(blocks)): cnt += blocks[i] == &amp;#39;W&amp;#39; cnt -= blocks[i - k] == &amp;#39;W&amp;#39; res = min(res, cnt) return res</description></item><item><title>2383. Minimum Hours of Training to Win a Competition</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2383/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2383/</guid><description>LeetCode problem 2383
class Solution: def minNumberOfHours( self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int], ) -&amp;gt; int: res = max(0, sum(energy) - initialEnergy + 1) for x in experience: if initialExperience &amp;lt;= x: res += x - initialExperience + 1 initialExperience = x + 1 initialExperience += x return res</description></item><item><title>2389. Longest Subsequence With Limited Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2389/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2389/</guid><description>LeetCode problem 2389
class Solution: def answerQueries(self, nums: List[int], queries: List[int]) -&amp;gt; List[int]: nums.sort() m = len(queries) res = [0] * m idx = sorted(range(m), key=lambda i: queries[i]) s = j = 0 for i in idx: while j &amp;lt; len(nums) and s + nums[j] &amp;lt;= queries[i]: s += nums[j] j += 1 res[i] = j return res</description></item><item><title>2395. Find Subarrays With Equal Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2395/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2395/</guid><description>LeetCode problem 2395
class Solution: def findSubarrays(self, nums: List[int]) -&amp;gt; bool: vis = set() for a, b in pairwise(nums): if (x := a + b) in vis: return True vis.add(x) return False</description></item><item><title>2399. Check Distances Between Same Letters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2399/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2399/</guid><description>LeetCode problem 2399
class Solution: def checkDistances(self, s: str, distance: List[int]) -&amp;gt; bool: d = defaultdict(int) for i, c in enumerate(s, 1): if d[c] and i - d[c] - 1 != distance[ord(c) - ord(&amp;#39;a&amp;#39;)]: return False d[c] = i return True</description></item><item><title>2404. Most Frequent Even Element</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2404/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2404/</guid><description>LeetCode problem 2404
class Solution: def mostFrequentEven(self, nums: List[int]) -&amp;gt; int: cnt = Counter(x for x in nums if x % 2 == 0) res, mx = -1, 0 for x, v in cnt.items(): if v &amp;gt; mx or (v == mx and res &amp;gt; x): res, mx = x, v return res</description></item><item><title>2409. Count Days Spent Together</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2409/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2409/</guid><description>LeetCode problem 2409
class Solution: def countDaysTogether( self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str ) -&amp;gt; int: a = max(arriveAlice, arriveBob) b = min(leaveAlice, leaveBob) days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) x = sum(days[: int(a[:2]) - 1]) + int(a[3:]) y = sum(days[: int(b[:2]) - 1]) + int(b[3:]) return max(y - x + 1, 0)</description></item><item><title>2413. Smallest Even Multiple</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2413/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2413/</guid><description>LeetCode problem 2413
class Solution: def smallestEvenMultiple(self, n: int) -&amp;gt; int: return n if n % 2 == 0 else n * 2</description></item><item><title>2418. Sort the People</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2418/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2418/</guid><description>LeetCode problem 2418
class Solution: def sortPeople(self, names: List[str], heights: List[int]) -&amp;gt; List[str]: return [name for _, name in sorted(zip(heights, names), reverse=True)]</description></item><item><title>2423. Remove Letter To Equalize Frequency</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2423/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2423/</guid><description>LeetCode problem 2423
class Solution: def equalFrequency(self, word: str) -&amp;gt; bool: cnt = Counter(word) for c in cnt.keys(): cnt[c] -= 1 if len(set(v for v in cnt.values() if v)) == 1: return True cnt[c] += 1 return False</description></item><item><title>2427. Number of Common Factors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2427/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2427/</guid><description>LeetCode problem 2427
class Solution: def commonFactors(self, a: int, b: int) -&amp;gt; int: g = gcd(a, b) res, x = 0, 1 while x * x &amp;lt;= g: if g % x == 0: res += 1 res += x * x &amp;lt; g x += 1 return res</description></item><item><title>Minimum Common Value</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2540/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2540/</guid><description>LeetCode problem 2540
By initializing two pointers, one for each array, we can compare the elements they point to. If the elements are equal, we&amp;rsquo;ve found a common value. If not, we move the pointer pointing to the smaller value forward. This approach ensures that we only traverse each array once.
class Solution: def getCommon(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: i = 0 j = 0 N1 = len(nums1) N2 = len(nums2) while i &amp;lt; N1 and j &amp;lt; N2: if nums1[i] == nums2[j]: return nums1[i] if nums1[i] &amp;lt; nums2[j]: i += 1 else: j += 1 return -1</description></item><item><title>2839. Check if Strings Can be Made Equal With Operations I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2839/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2839/</guid><description>LeetCode Problem
Problem Statement You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters. The objective is to find out if it&amp;rsquo;s possible to make the two strings equal by swapping certain pairs of characters.
Naive Solution A naive approach would be to try out all possible swap combinations. However, this can be very inefficient, especially when the strings have a large number of characters.
Hints &amp;amp; Tips Observe that the swapping condition is quite specific: j - i = 2.</description></item><item><title>2848. Points That Intersect With Cars</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2848/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2848/</guid><description>LeetCode problem 2848
Problem Statement Given cars parked on a number line, represented by starting and ending coordinates, we aim to determine the number of points on this line that are covered by any part of these cars.
Naive Solution A basic approach is to simply iterate through each interval and for each interval, iterate through its range, adding each point to a list. Finally, we can return the length of this list to get the total points. However, this approach has a risk of counting points multiple times when two cars overlap.</description></item><item><title>2855. Minimum Right Shifts to Sort the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2855/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2855/</guid><description>LeetCode problem 2855
class Solution: def minimumRightShifts(self, nums: List[int]) -&amp;gt; int: n = len(nums) i = 1 while i &amp;lt; n and nums[i - 1] &amp;lt; nums[i]: i += 1 k = i + 1 while k &amp;lt; n and nums[k - 1] &amp;lt; nums[k] &amp;lt; nums[0]: k += 1 return -1 if k &amp;lt; n else n - i</description></item><item><title>2859. Sum of Values at Indices With K Set Bits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2859/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2859/</guid><description>LeetCode problem 2859
class Solution: def sumIndicesWithKSetBits(self, nums: List[int], k: int) -&amp;gt; int: return sum(x for i, x in enumerate(nums) if i.bit_count() == k)</description></item><item><title>Maximum Odd Binary Number</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2864/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2864/</guid><description>LeetCode problem 2864
class Solution: def maximumOddBinaryNumber(self, s: str) -&amp;gt; str: ones = [] zeros = [] for c in s: if c == &amp;#39;0&amp;#39;: zeros.append(c) else: ones.append(c) zeros = &amp;#39;&amp;#39;.join(zeros) ones = &amp;#39;&amp;#39;.join(ones) if len(ones) &amp;gt; 1: res = ones[1:] + zeros + &amp;#39;1&amp;#39; return res return zeros + ones class Solution: def maximumOddBinaryNumber(self, s: str) -&amp;gt; str: cnt = s.count(&amp;#34;1&amp;#34;) return &amp;#34;1&amp;#34; * (cnt - 1) + (len(s) - cnt) * &amp;#34;0&amp;#34; + &amp;#34;1&amp;#34;</description></item><item><title>2869. Minimum Operations to Collect Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2869/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2869/</guid><description>LeetCode problem 2869
class Solution: def minOperations(self, nums: List[int], k: int) -&amp;gt; int: is_added = [False] * k count = 0 n = len(nums) for i in range(n - 1, -1, -1): if nums[i] &amp;gt; k or is_added[nums[i] - 1]: continue is_added[nums[i] - 1] = True count += 1 if count == k: return n - i</description></item><item><title>2873. Maximum Value of an Ordered Triplet I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2873/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2873/</guid><description>LeetCode problem 2873
class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title>2877. Create a DataFrame from List</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2877/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2877/</guid><description>LeetCode problem 2877
import pandas as pd def createDataframe(student_data: List[List[int]]) -&amp;gt; pd.DataFrame: return pd.DataFrame(student_data, columns=[&amp;#39;student_id&amp;#39;, &amp;#39;age&amp;#39;])</description></item><item><title>2878. Get the Size of a DataFrame</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2878/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2878/</guid><description>LeetCode problem 2878
import pandas as pd def getDataframeSize(players: pd.DataFrame) -&amp;gt; List[int]: return list(players.shape)</description></item><item><title>2879. Display the First Three Rows</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2879/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2879/</guid><description>LeetCode problem 2879
import pandas as pd def selectFirstRows(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: return employees.head(3)</description></item><item><title>2880. Select Data</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2880/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2880/</guid><description>LeetCode problem 2880
import pandas as pd def selectData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;student_id&amp;#39;] == 101][[&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;]]</description></item><item><title>2881. Create a New Column</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2881/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2881/</guid><description>LeetCode problem 2881
import pandas as pd def createBonusColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;bonus&amp;#39;] = employees[&amp;#39;salary&amp;#39;] * 2 return employees</description></item><item><title>2882. Drop Duplicate Rows</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2882/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2882/</guid><description>LeetCode problem 2882
import pandas as pd def dropDuplicateEmails(customers: pd.DataFrame) -&amp;gt; pd.DataFrame: return customers.drop_duplicates(subset=[&amp;#39;email&amp;#39;])</description></item><item><title>2883. Drop Missing Data</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2883/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2883/</guid><description>LeetCode problem 2883
import pandas as pd def dropMissingData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;name&amp;#39;].notnull()]</description></item><item><title>2884. Modify Columns</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2884/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2884/</guid><description>LeetCode problem 2884
import pandas as pd def modifySalaryColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;salary&amp;#39;] *= 2 return employees</description></item><item><title>2885. Rename Columns</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2885/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2885/</guid><description>LeetCode problem 2885
import pandas as pd def renameColumns(students: pd.DataFrame) -&amp;gt; pd.DataFrame: students.rename( columns={ &amp;#39;id&amp;#39;: &amp;#39;student_id&amp;#39;, &amp;#39;first&amp;#39;: &amp;#39;first_name&amp;#39;, &amp;#39;last&amp;#39;: &amp;#39;last_name&amp;#39;, &amp;#39;age&amp;#39;: &amp;#39;age_in_years&amp;#39;, }, inplace=True, ) return students</description></item><item><title>2886. Change Data Type</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2886/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2886/</guid><description>LeetCode problem 2886
import pandas as pd def changeDatatype(students: pd.DataFrame) -&amp;gt; pd.DataFrame: students[&amp;#39;grade&amp;#39;] = students[&amp;#39;grade&amp;#39;].astype(int) return students</description></item><item><title>2887. Fill Missing Data</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2887/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2887/</guid><description>LeetCode problem 2887
import pandas as pd def fillMissingValues(products: pd.DataFrame) -&amp;gt; pd.DataFrame: products[&amp;#39;quantity&amp;#39;] = products[&amp;#39;quantity&amp;#39;].fillna(0) return products</description></item><item><title>2888. Reshape Data Concatenate</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2888/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2888/</guid><description>LeetCode problem 2888
import pandas as pd def concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.concat([df1, df2], ignore_index=True)</description></item><item><title>2889. Reshape Data Pivot</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2889/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2889/</guid><description>LeetCode problem 2889
import pandas as pd def pivotTable(weather: pd.DataFrame) -&amp;gt; pd.DataFrame: return weather.pivot(index=&amp;#39;month&amp;#39;, columns=&amp;#39;city&amp;#39;, values=&amp;#39;temperature&amp;#39;)</description></item><item><title>2890. Reshape Data Melt</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2890/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2890/</guid><description>LeetCode problem 2890
import pandas as pd def meltTable(report: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.melt(report, id_vars=[&amp;#39;product&amp;#39;], var_name=&amp;#39;quarter&amp;#39;, value_name=&amp;#39;sales&amp;#39;)</description></item><item><title>2891. Method Chaining</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2891/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2891/</guid><description>LeetCode problem 2891
import pandas as pd def findHeavyAnimals(animals: pd.DataFrame) -&amp;gt; pd.DataFrame: return animals[animals[&amp;#39;weight&amp;#39;] &amp;gt; 100].sort_values(&amp;#39;weight&amp;#39;, ascending=False)[ [&amp;#39;name&amp;#39;] ]</description></item><item><title>2894. Divisible and Non-divisible Sums Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2894/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2894/</guid><description>LeetCode problem 2894
class Solution: def differenceOfSums(self, n: int, m: int) -&amp;gt; int: return sum(i if i % m else -i for i in range(1, n + 1))</description></item><item><title>2899. Last Visited Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2899/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2899/</guid><description>LeetCode problem 2899
class Solution: def lastVisitedIntegers(self, words: List[str]) -&amp;gt; List[int]: nums = [] res = [] k = 0 for w in words: if w == &amp;#34;prev&amp;#34;: k += 1 i = len(nums) - k res.append(-1 if i &amp;lt; 0 else nums[i]) else: k = 0 nums.append(int(w)) return res</description></item><item><title>2903. Find Indices With Index and Value Difference I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2903/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2903/</guid><description>LeetCode problem 2903
class Solution: def findIndices( self, nums: List[int], indexDifference: int, valueDifference: int ) -&amp;gt; List[int]: mi = mx = 0 for i in range(indexDifference, len(nums)): j = i - indexDifference if nums[j] &amp;lt; nums[mi]: mi = j if nums[j] &amp;gt; nums[mx]: mx = j if nums[i] - nums[mi] &amp;gt;= valueDifference: return [mi, i] if nums[mx] - nums[i] &amp;gt;= valueDifference: return [mx, i] return [-1, -1]</description></item><item><title>2908. Minimum Sum of Mountain Triplets I</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2908/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2908/</guid><description>LeetCode problem 2908
class Solution: def minimumSum(self, nums: List[int]) -&amp;gt; int: n = len(nums) right = [inf] * (n + 1) for i in range(n - 1, -1, -1): right[i] = min(right[i + 1], nums[i]) res = left = inf for i, x in enumerate(nums): if left &amp;lt; x and right[i + 1] &amp;lt; x: res = min(res, left + x + right[i + 1]) left = min(left, x) return -1 if res == inf else res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2917/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2917/</guid><description>class Solution: def findKOr(self, nums: List[int], k: int) -&amp;gt; int: res = 0 for i in range(32): cnt = sum(x &amp;gt;&amp;gt; i &amp;amp; 1 for x in nums) if cnt &amp;gt;= k: res |= 1 &amp;lt;&amp;lt; i return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2923/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2923/</guid><description>class Solution: def findChampion(self, grid: List[List[int]]) -&amp;gt; int: for i, row in enumerate(grid): if all(x == 1 for j, x in enumerate(row) if i != j): return i</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2928/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2928/</guid><description>class Solution: def distributeCandies(self, n: int, limit: int) -&amp;gt; int: if n &amp;gt; 3 * limit: return 0 res = comb(n + 2, 2) if n &amp;gt; limit: res -= 3 * comb(n - limit + 1, 2) if n - 2 &amp;gt;= 2 * limit: res += 3 * comb(n - 2 * limit, 2) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2932/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2932/</guid><description>class Trie: __slots__ = (&amp;#34;children&amp;#34;, &amp;#34;cnt&amp;#34;) def __init__(self): self.children: List[Trie | None] = [None, None] self.cnt = 0 def insert(self, x: int): node = self for i in range(7, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v] is None: node.children[v] = Trie() node = node.children[v] node.cnt += 1 def search(self, x: int) -&amp;gt; int: node = self res = 0 for i in range(7, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v ^ 1] and node.</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2937/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2937/</guid><description>class Solution: def findMinimumOperations(self, s1: str, s2: str, s3: str) -&amp;gt; int: s = len(s1) + len(s2) + len(s3) n = min(len(s1), len(s2), len(s3)) for i in range(n): if not s1[i] == s2[i] == s3[i]: return -1 if i == 0 else s - 3 * i return s - 3 * n</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2942/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2942/</guid><description>class Solution: def findWordsContaining(self, words: List[str], x: str) -&amp;gt; List[int]: return [i for i, w in enumerate(words) if x in w]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2946/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2946/</guid><description>class Solution: def areSimilar(self, mat: List[List[int]], k: int) -&amp;gt; bool: n = len(mat[0]) for i, row in enumerate(mat): for j, x in enumerate(row): if i % 2 == 1 and x != mat[i][(j + k) % n]: return False if i % 2 == 0 and x != mat[i][(j - k + n) % n]: return False return True</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2951/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2951/</guid><description>class Solution: def findPeaks(self, mountain: List[int]) -&amp;gt; List[int]: return [ i for i in range(1, len(mountain) - 1) if mountain[i - 1] &amp;lt; mountain[i] &amp;gt; mountain[i + 1] ]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2956/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2956/</guid><description>class Solution: def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]: s1, s2 = set(nums1), set(nums2) return [sum(x in s2 for x in nums1), sum(x in s1 for x in nums2)]</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2960/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2960/</guid><description>class Solution: def countTestedDevices(self, batteryPercentages: List[int]) -&amp;gt; int: res = 0 for x in batteryPercentages: x -= res res += x &amp;gt; 0 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2965/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2965/</guid><description>class Solution: def findMissingAndRepeatedValues(self, grid: List[List[int]]) -&amp;gt; List[int]: n = len(grid) cnt = [0] * (n * n + 1) for row in grid: for v in row: cnt[v] += 1 res = [0] * 2 for i in range(1, n * n + 1): if cnt[i] == 2: res[0] = i if cnt[i] == 0: res[1] = i return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2970/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2970/</guid><description>class Solution: def incremovableSubarrayCount(self, nums: List[int]) -&amp;gt; int: i, n = 0, len(nums) while i + 1 &amp;lt; n and nums[i] &amp;lt; nums[i + 1]: i += 1 if i == n - 1: return n * (n + 1) // 2 res = i + 2 j = n - 1 while j: while i &amp;gt;= 0 and nums[i] &amp;gt;= nums[j]: i -= 1 res += i + 2 if nums[j - 1] &amp;gt;= nums[j]: break j -= 1 return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2974/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2974/</guid><description>class Solution: def numberGame(self, nums: List[int]) -&amp;gt; List[int]: nums.sort() for i in range(0, len(nums), 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2980/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2980/</guid><description>class Solution: def hasTrailingZeros(self, nums: List[int]) -&amp;gt; bool: return sum(x &amp;amp; 1 ^ 1 for x in nums) &amp;gt;= 2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2996/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/2996/</guid><description>class Solution: def missingInteger(self, nums: List[int]) -&amp;gt; int: s, j = nums[0], 1 while j &amp;lt; len(nums) and nums[j] == nums[j - 1] + 1: s += nums[j] j += 1 vis = set(nums) for x in count(s): if x not in vis: return x</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3000/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3000/</guid><description>class Solution: def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -&amp;gt; int: res = mx = 0 for l, w in dimensions: t = l**2 + w**2 if mx &amp;lt; t: mx = t res = l * w elif mx == t: res = max(res, l * w) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3005/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3005/</guid><description>class Solution: def maxFrequencyElements(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) mx = max(cnt.values()) return sum(x for x in cnt.values() if x == mx)</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3010/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3010/</guid><description>class Solution: def minimumCost(self, nums: List[int]) -&amp;gt; int: a, b, c = nums[0], inf, inf for x in nums[1:]: if x &amp;lt; b: c, b = b, x elif x &amp;lt; c: c = x return a + b + c</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3014/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3014/</guid><description>class Solution: def minimumPushes(self, word: str) -&amp;gt; int: n = len(word) res, k = 0, 1 for _ in range(n // 8): res += k * 8 k += 1 res += k * (n % 8) return res</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3019/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3019/</guid><description>class Solution: def countKeyChanges(self, s: str) -&amp;gt; int: return sum(a.lower() != b.lower() for a, b in pairwise(s))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3024/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3024/</guid><description>class Solution: def triangleType(self, nums: List[int]) -&amp;gt; str: nums.sort() if nums[0] + nums[1] &amp;lt;= nums[2]: return &amp;#34;none&amp;#34; if nums[0] == nums[2]: return &amp;#34;equilateral&amp;#34; if nums[0] == nums[1] or nums[1] == nums[2]: return &amp;#34;isosceles&amp;#34; return &amp;#34;scalene&amp;#34;</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3028/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3028/</guid><description>class Solution: def returnToBoundaryCount(self, nums: List[int]) -&amp;gt; int: return sum(s == 0 for s in accumulate(nums))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3032/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3032/</guid><description>class Solution: def numberCount(self, a: int, b: int) -&amp;gt; int: return sum(len(set(str(num))) == len(str(num)) for num in range(a, b + 1))</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3033/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3033/</guid><description>class Solution: def modifiedMatrix(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(matrix), len(matrix[0]) for j in range(n): mx = max(matrix[i][j] for i in range(m)) for i in range(m): if matrix[i][j] == -1: matrix[i][j] = mx return matrix</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3069/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/3069/</guid><description>class Solution: def resultArray(self, nums: List[int]) -&amp;gt; List[int]: ar1 = [nums[0]] ar2 = [nums[1]] for x in nums[2:]: if ar1[-1] &amp;gt; ar2[-1]: ar1.append(x) else: ar2.append(x) return ar1 + ar2</description></item><item><title/><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/543/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/easy/543/</guid><description># Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -&amp;gt; int: diameter = [0] def dfs(root): if not root: return (0, 0) left = max(dfs(root.left)) right = max(dfs(root.right)) diameter[0] = max(diameter[0], left + right) return (left + 1, right + 1) dfs(root) return diameter[0]</description></item></channel></rss>