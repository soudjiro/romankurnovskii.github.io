<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hard on Roman Kurnovskii</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/</link><description>Recent content in Hard on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/index.xml" rel="self" type="application/rss+xml"/><item><title>4. Median of Two Sorted Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/4/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/4/</guid><description>LeetCode задача 4
Задача Даны два отсортированных массива nums1 и nums2 размера m и n соответственно. Найти медиану двух отсортированных массивов.
Подсказки Чтобы найти медиану, нужно сначала объединить два массива и отсортировать их. После этого медиана будет либо средним элементом, если общее количество элементов нечетное, либо средним значением двух центральных элементов, если общее количество элементов четное.
Подход Мы можем объединить два массива в один большой отсортированный массив и найти медиану этого массива. Этот подход не самый эффективный, но он прост и понятен.</description></item><item><title>42. Trapping Rain Water</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/42/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/42/</guid><description>LeetCode задача 42
Задача Дан массив неотрицательных целых чисел, представляющих собой карту высот, где ширина каждой стойки равна 1. Вычислите, сколько воды может удерживать этот массив после дождя.
Подсказки Мы можем решить эту задачу, двигаясь от краев массива к его центру, отслеживая текущую максимальную высоту с обеих сторон.
Подход Простой и понятный способ решения этой задачи - пройтись по массиву и для каждого элемента вычислить, сколько воды он может удержать.
Алгоритм Инициализируем переменную для хранения общего объема воды, который может быть удержан.</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2402/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2402/</guid><description>LeetCode problem 240
class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: m, n = len(matrix), len(matrix[0]) i, j = m - 1, 0 while i &amp;gt;= 0 and j &amp;lt; n: if matrix[i][j] == target: return True if matrix[i][j] &amp;gt; target: i -= 1 else: j += 1 return False</description></item><item><title>332. Reconstruct Itinerary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/332/</guid><description>LeetCode problem
Problem Statement Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from &amp;ldquo;JFK&amp;rdquo;, thus, the itinerary must begin with &amp;ldquo;JFK&amp;rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
Naive Solution One naive solution would be to use backtracking and try all possible combinations of tickets to form a valid itinerary.</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1359/</guid><description>LeetCode problem 1359
Problem Statement You&amp;rsquo;re tasked with finding all valid sequences of pickup and delivery events for n orders such that for every order, the delivery always comes after its respective pickup. Because the answer can be immense, you&amp;rsquo;re to return the result modulo (10^9 + 7).
Naive Solution A straightforward approach might be to generate all potential permutations of pickup and delivery actions and then exclude the unsuitable ones. However, this method would be exceedingly inefficient and would not scale for larger n values.</description></item><item><title>1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1420/</link><pubDate>Thu, 21 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1420/</guid><description>LeetCode Problem 1420
Problem Statement In this problem, we have three integers, n, m, and k. We need to construct an array arr having the following properties:
It consists of exactly n integers. Each integer in the array is between 1 and m inclusive. After executing a certain algorithm on arr, we get a value known as search_cost. Our goal is to ensure search_cost is equal to k. The main challenge is determining how many ways we can construct such an array arr.</description></item><item><title>1585. Check If String Is Transformable With Substring Sort Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1585/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1585/</guid><description>LeetCode problem 1585
class Solution: def isTransformable(self, s: str, t: str) -&amp;gt; bool: pos = defaultdict(deque) for i, c in enumerate(s): pos[int(c)].append(i) for c in t: x = int(c) if not pos[x] or any(pos[i] and pos[i][0] &amp;lt; pos[x][0] for i in range(x)): return False pos[x].popleft() return True</description></item><item><title>1595. Minimum Cost to Connect Two Groups of Points</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1595/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1595/</guid><description>LeetCode problem 1595
class Solution: def connectTwoGroups(self, cost: List[List[int]]) -&amp;gt; int: m, n = len(cost), len(cost[0]) f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 g = f[:] for i in range(1, m + 1): for j in range(1 &amp;lt;&amp;lt; n): g[j] = inf for k in range(n): if (j &amp;gt;&amp;gt; k &amp;amp; 1) == 0: continue c = cost[i - 1][k] x = min(g[j ^ (1 &amp;lt;&amp;lt; k)], f[j], f[j ^ (1 &amp;lt;&amp;lt; k)]) + c g[j] = min(g[j], x) f = g[:] return f[-1]</description></item><item><title>1601. Maximum Number of Achievable Transfer Requests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1601/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1601/</guid><description>LeetCode problem 1601
class Solution: def maximumRequests(self, n: int, requests: List[List[int]]) -&amp;gt; int: def check(mask: int) -&amp;gt; bool: cnt = [0] * n for i, (f, t) in enumerate(requests): if mask &amp;gt;&amp;gt; i &amp;amp; 1: cnt[f] -= 1 cnt[t] += 1 return all(v == 0 for v in cnt) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(requests)): cnt = mask.bit_count() if res &amp;lt; cnt and check(mask): res = cnt return res</description></item><item><title>1606. Find Servers That Handled Most Number of Requests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1606/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1606/</guid><description>LeetCode problem 1606
from sortedcontainers import SortedList class Solution: def busiestServers(self, k: int, arrival: List[int], load: List[int]) -&amp;gt; List[int]: free = SortedList(range(k)) busy = [] cnt = [0] * k for i, (start, t) in enumerate(zip(arrival, load)): while busy and busy[0][0] &amp;lt;= start: free.add(busy[0][1]) heappop(busy) if not free: continue j = free.bisect_left(i % k) if j == len(free): j = 0 server = free[j] cnt[server] += 1 heappush(busy, (start + t, server)) free.remove(server) mx = max(cnt) return [i for i, v in enumerate(cnt) if v == mx]</description></item><item><title>1610. Maximum Number of Visible Points</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1610/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1610/</guid><description>LeetCode problem 1610
class Solution: def visiblePoints( self, points: List[List[int]], angle: int, location: List[int] ) -&amp;gt; int: v = [] x, y = location same = 0 for xi, yi in points: if xi == x and yi == y: same += 1 else: v.append(atan2(yi - y, xi - x)) v.sort() n = len(v) v += [deg + 2 * pi for deg in v] t = angle * pi / 180 mx = max((bisect_right(v, v[i] + t) - i for i in range(n)), default=0) return mx + same</description></item><item><title>1611. Minimum One Bit Operations to Make Integers Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1611/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1611/</guid><description>LeetCode problem 1611
class Solution: def minimumOneBitOperations(self, n: int) -&amp;gt; int: if n == 0: return 0 return n ^ self.minimumOneBitOperations(n &amp;gt;&amp;gt; 1)</description></item><item><title>1617. Count Subtrees With Max Distance Between Cities</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1617/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1617/</guid><description>LeetCode problem 1617
class Solution: def countSubgraphsForEachDiameter( self, n: int, edges: List[List[int]] ) -&amp;gt; List[int]: def bfs(u: int) -&amp;gt; int: d = -1 q = deque([u]) nonlocal msk, nxt msk ^= 1 &amp;lt;&amp;lt; u while q: d += 1 for _ in range(len(q)): nxt = u = q.popleft() for v in g[u]: if msk &amp;gt;&amp;gt; v &amp;amp; 1: msk ^= 1 &amp;lt;&amp;lt; v q.append(v) return d g = defaultdict(list) for u, v in edges: u, v = u - 1, v - 1 g[u].</description></item><item><title>1622. Fancy Sequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1622/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1622/</guid><description>LeetCode problem 1622
MOD = int(1e9 + 7) class Node: def __init__(self, l, r): self.left = None self.right = None self.l = l self.r = r self.mid = (l + r) &amp;gt;&amp;gt; 1 self.v = 0 self.add = 0 self.mul = 1 class SegmentTree: def __init__(self): self.root = Node(1, int(1e5 + 1)) def modifyAdd(self, l, r, inc, node=None): if l &amp;gt; r: return if node is None: node = self.root if node.l &amp;gt;= l and node.r &amp;lt;= r: node.</description></item><item><title>1627. Graph Connectivity With Threshold</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1627/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1627/</guid><description>LeetCode problem 1627
class UnionFind: def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a, b): pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def areConnected( self, n: int, threshold: int, queries: List[List[int]] ) -&amp;gt; List[bool]: uf = UnionFind(n + 1) for a in range(threshold + 1, n + 1): for b in range(a + a, n + 1, a): uf.</description></item><item><title>1632. Rank Transform of a Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1632/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1632/</guid><description>LeetCode problem 1632
class UnionFind: def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a, b): pa, pb = self.find(a), self.find(b) if pa != pb: if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] def reset(self, x): self.p[x] = x self.size[x] = 1 class Solution: def matrixRankTransform(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(matrix), len(matrix[0]) d = defaultdict(list) for i, row in enumerate(matrix): for j, v in enumerate(row): d[v].</description></item><item><title>1639. Number of Ways to Form a Target String Given a Dictionary</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1639/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1639/</guid><description>LeetCode problem 1639
class Solution: def numWays(self, words: List[str], target: str) -&amp;gt; int: m, n = len(target), len(words[0]) cnt = [[0] * 26 for _ in range(n)] for w in words: for j, c in enumerate(w): cnt[j][ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 mod = 10**9 + 7 f = [[0] * (n + 1) for _ in range(m + 1)] f[0] = [1] * (n + 1) for i in range(1, m + 1): for j in range(1, n + 1): f[i][j] = ( f[i][j - 1] + f[i - 1][j - 1] * cnt[j - 1][ord(target[i - 1]) - ord(&amp;#39;a&amp;#39;)] ) f[i][j] %= mod return f[m][n]</description></item><item><title>1643. Kth Smallest Instructions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1643/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1643/</guid><description>LeetCode problem 1643
class Solution: def kthSmallestPath(self, destination: List[int], k: int) -&amp;gt; str: v, h = destination res = [] for _ in range(h + v): if h == 0: res.append(&amp;#34;V&amp;#34;) else: x = comb(h + v - 1, h - 1) if k &amp;gt; x: res.append(&amp;#34;V&amp;#34;) v -= 1 k -= x else: res.append(&amp;#34;H&amp;#34;) h -= 1 return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1649. Create Sorted Array through Instructions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1649/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1649/</guid><description>LeetCode problem 1649
class Node: def __init__(self): self.l = 0 self.r = 0 self.v = 0 class SegmentTree: def __init__(self, n): self.tr = [Node() for _ in range(4 * n)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l = l self.tr[u].r = r if l == r: return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) def modify(self, u, x, v): if self.tr[u].l == x and self.</description></item><item><title>1655. Distribute Repeating Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1655/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1655/</guid><description>LeetCode problem 1655
class Solution: def canDistribute(self, nums: List[int], quantity: List[int]) -&amp;gt; bool: m = len(quantity) s = [0] * (1 &amp;lt;&amp;lt; m) for i in range(1, 1 &amp;lt;&amp;lt; m): for j in range(m): if i &amp;gt;&amp;gt; j &amp;amp; 1: s[i] = s[i ^ (1 &amp;lt;&amp;lt; j)] + quantity[j] break cnt = Counter(nums) arr = list(cnt.values()) n = len(arr) f = [[False] * (1 &amp;lt;&amp;lt; m) for _ in range(n)] for i in range(n): f[i][0] = True for i, x in enumerate(arr): for j in range(1, 1 &amp;lt;&amp;lt; m): if i and f[i - 1][j]: f[i][j] = True continue k = j while k: ok1 = j == k if i == 0 else f[i - 1][j ^ k] ok2 = s[k] &amp;lt;= x if ok1 and ok2: f[i][j] = True break k = (k - 1) &amp;amp; j return f[-1][-1]</description></item><item><title>1659. Maximize Grid Happiness</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1659/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1659/</guid><description>LeetCode problem 1659
class Solution: def getMaxGridHappiness( self, m: int, n: int, introvertsCount: int, extrovertsCount: int ) -&amp;gt; int: @cache def dfs(pos: int, pre: int, ic: int, ec: int) -&amp;gt; int: if pos == m * n or (ic == 0 and ec == 0): return 0 res = 0 up = pre // p left = 0 if pos % n == 0 else pre % 3 for i in range(3): if (i == 1 and ic == 0) or (i == 2 and ec == 0): continue cur = pre % p * 3 + i a = h[up][i] + h[left][i] b = dfs(pos + 1, cur, ic - (i == 1), ec - (i == 2)) c = 0 if i == 1: c = 120 elif i == 2: c = 40 res = max(res, a + b + c) return res p = pow(3, n - 1) h = [[0, 0, 0], [0, -60, -10], [0, -10, 40]] return dfs(0, 0, introvertsCount, extrovertsCount)</description></item><item><title>1665. Minimum Initial Energy to Finish Tasks</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1665/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1665/</guid><description>LeetCode problem 1665
class Solution: def minimumEffort(self, tasks: List[List[int]]) -&amp;gt; int: res = cur = 0 for a, m in sorted(tasks, key=lambda x: x[0] - x[1]): if cur &amp;lt; m: res += m - cur cur = m cur -= a return res</description></item><item><title>1671. Minimum Number of Removals to Make Mountain Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1671/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1671/</guid><description>LeetCode problem 1671
class Solution: def minimumMountainRemovals(self, nums: List[int]) -&amp;gt; int: n = len(nums) left = [1] * n right = [1] * n for i in range(1, n): for j in range(i): if nums[i] &amp;gt; nums[j]: left[i] = max(left[i], left[j] + 1) for i in range(n - 2, -1, -1): for j in range(i + 1, n): if nums[i] &amp;gt; nums[j]: right[i] = max(right[i], right[j] + 1) return n - max(a + b - 1 for a, b in zip(left, right) if a &amp;gt; 1 and b &amp;gt; 1)</description></item><item><title>1675. Minimize Deviation in Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1675/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1675/</guid><description>LeetCode problem 1675
class Solution: def minimumDeviation(self, nums: List[int]) -&amp;gt; int: h = [] mi = inf for v in nums: if v &amp;amp; 1: v &amp;lt;&amp;lt;= 1 h.append(-v) mi = min(mi, v) heapify(h) res = -h[0] - mi while h[0] % 2 == 0: x = heappop(h) // 2 heappush(h, x) mi = min(mi, -x) res = min(res, -h[0] - mi) return res</description></item><item><title>1681. Minimum Incompatibility</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1681/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1681/</guid><description>LeetCode problem 1681
class Solution: def minimumIncompatibility(self, nums: List[int], k: int) -&amp;gt; int: @cache def dfs(mask): if mask == (1 &amp;lt;&amp;lt; n) - 1: return 0 d = {v: i for i, v in enumerate(nums) if (mask &amp;gt;&amp;gt; i &amp;amp; 1) == 0} res = inf if len(d) &amp;lt; m: return res for vs in combinations(d.keys(), m): nxt = mask for v in vs: nxt |= 1 &amp;lt;&amp;lt; d[v] res = min(res, max(vs) - min(vs) + dfs(nxt)) return res n = len(nums) m = n // k res = dfs(0) dfs.</description></item><item><title>1687. Delivering Boxes from Storage to Ports</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1687/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1687/</guid><description>LeetCode problem 1687
class Solution: def boxDelivering( self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int ) -&amp;gt; int: n = len(boxes) ws = list(accumulate((box[1] for box in boxes), initial=0)) c = [int(a != b) for a, b in pairwise(box[0] for box in boxes)] cs = list(accumulate(c, initial=0)) f = [0] * (n + 1) q = deque([0]) for i in range(1, n + 1): while q and (i - q[0] &amp;gt; maxBoxes or ws[i] - ws[q[0]] &amp;gt; maxWeight): q.</description></item><item><title>1691. Maximum Height by Stacking Cuboids</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1691/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1691/</guid><description>LeetCode problem 1691
class Solution: def maxHeight(self, cuboids: List[List[int]]) -&amp;gt; int: for c in cuboids: c.sort() cuboids.sort() n = len(cuboids) f = [0] * n for i in range(n): for j in range(i): if cuboids[j][1] &amp;lt;= cuboids[i][1] and cuboids[j][2] &amp;lt;= cuboids[i][2]: f[i] = max(f[i], f[j]) f[i] += cuboids[i][2] return max(f)</description></item><item><title>1692. Count Ways to Distribute Candies</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1692/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1692/</guid><description>LeetCode problem 1692
class Solution: def waysToDistribute(self, n: int, k: int) -&amp;gt; int: mod = 10**9 + 7 f = [[0] * (k + 1) for _ in range(n + 1)] f[0][0] = 1 for i in range(1, n + 1): for j in range(1, k + 1): f[i][j] = (f[i - 1][j] * j + f[i - 1][j - 1]) % mod return f[n][k]</description></item><item><title>1697. Checking Existence of Edge Length Limited Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1697/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1697/</guid><description>LeetCode problem 1697
class Solution: def distanceLimitedPathsExist( self, n: int, edgeList: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[bool]: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(n)) edgeList.sort(key=lambda x: x[2]) j = 0 res = [False] * len(queries) for i, (a, b, limit) in sorted(enumerate(queries), key=lambda x: x[1][2]): while j &amp;lt; len(edgeList) and edgeList[j][2] &amp;lt; limit: u, v, _ = edgeList[j] p[find(u)] = find(v) j += 1 res[i] = find(a) == find(b) return res</description></item><item><title>1703. Minimum Adjacent Swaps for K Consecutive Ones</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1703/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1703/</guid><description>LeetCode problem 1703
class Solution: def minMoves(self, nums: List[int], k: int) -&amp;gt; int: arr = [i for i, x in enumerate(nums) if x] s = list(accumulate(arr, initial=0)) res = inf x = (k + 1) // 2 y = k - x for i in range(x - 1, len(arr) - y): j = arr[i] ls = s[i + 1] - s[i + 1 - x] rs = s[i + 1 + y] - s[i + 1] a = (j + j - x + 1) * x // 2 - ls b = rs - (j + 1 + j + y) * y // 2 res = min(res, a + b) return res</description></item><item><title>1707. Maximum XOR With an Element From Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1707/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1707/</guid><description>LeetCode problem 1707
class Trie: __slots__ = [&amp;#34;children&amp;#34;] def __init__(self): self.children = [None] * 2 def insert(self, x: int): node = self for i in range(30, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v] is None: node.children[v] = Trie() node = node.children[v] def search(self, x: int) -&amp;gt; int: node = self res = 0 for i in range(30, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v ^ 1]: res |= 1 &amp;lt;&amp;lt; i node = node.</description></item><item><title>1713. Minimum Operations to Make a Subsequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1713/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1713/</guid><description>LeetCode problem 1713
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) @staticmethod def lowbit(x): return x &amp;amp; -x def update(self, x, val): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], val) x += BinaryIndexedTree.lowbit(x) def query(self, x): s = 0 while x: s = max(s, self.c[x]) x -= BinaryIndexedTree.lowbit(x) return s class Solution: def minOperations(self, target: List[int], arr: List[int]) -&amp;gt; int: d = {v: i for i, v in enumerate(target)} nums = [d[v] for v in arr if v in d] return len(target) - self.</description></item><item><title>1714. Sum Of Special Evenly-Spaced Elements In Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1714/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1714/</guid><description>LeetCode problem 1714
class Solution: def solve(self, nums: List[int], queries: List[List[int]]) -&amp;gt; List[int]: mod = 10**9 + 7 n = len(nums) m = int(sqrt(n)) suf = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(n - 1, -1, -1): suf[i][j] = suf[i][min(n, j + i)] + nums[j] res = [] for x, y in queries: if y &amp;lt;= m: res.append(suf[y][x] % mod) else: res.append(sum(nums[x::y]) % mod) return res</description></item><item><title>1719. Number Of Ways To Reconstruct A Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1719/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1719/</guid><description>LeetCode problem 1719
class Solution: def checkWays(self, pairs: List[List[int]]) -&amp;gt; int: g = [[False] * 510 for _ in range(510)] v = defaultdict(list) for x, y in pairs: g[x][y] = g[y][x] = True v[x].append(y) v[y].append(x) nodes = [] for i in range(510): if v[i]: nodes.append(i) g[i][i] = True nodes.sort(key=lambda x: len(v[x])) equal = False root = 0 for i, x in enumerate(nodes): j = i + 1 while j &amp;lt; len(nodes) and not g[x][nodes[j]]: j += 1 if j &amp;lt; len(nodes): y = nodes[j] if len(v[x]) == len(v[y]): equal = True for z in v[x]: if not g[y][z]: return 0 else: root += 1 if root &amp;gt; 1: return 0 return 2 if equal else 1</description></item><item><title>1723. Find Minimum Time to Finish All Jobs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1723/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1723/</guid><description>LeetCode problem 1723
class Solution: def minimumTimeRequired(self, jobs: List[int], k: int) -&amp;gt; int: def dfs(i): nonlocal res if i == len(jobs): res = min(res, max(cnt)) return for j in range(k): if cnt[j] + jobs[i] &amp;gt;= res: continue cnt[j] += jobs[i] dfs(i + 1) cnt[j] -= jobs[i] if cnt[j] == 0: break cnt = [0] * k jobs.sort(reverse=True) res = inf dfs(0) return res</description></item><item><title>1724. Checking Existence of Edge Length Limited Paths II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1724/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1724/</guid><description>LeetCode problem 1724
class PersistentUnionFind: def __init__(self, n): self.rank = [0] * n self.p = list(range(n)) self.version = [inf] * n def find(self, x, t=inf): if self.p[x] == x or self.version[x] &amp;gt;= t: return x return self.find(self.p[x], t) def union(self, a, b, t): pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.rank[pa] &amp;gt; self.rank[pb]: self.version[pb] = t self.p[pb] = pa else: self.version[pa] = t self.p[pa] = pb if self.rank[pa] == self.rank[pb]: self.rank[pb] += 1 return True class DistanceLimitedPathsExist: def __init__(self, n: int, edgeList: List[List[int]]): self.</description></item><item><title>1728. Cat and Mouse II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1728/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1728/</guid><description>LeetCode problem 1728
class Solution: def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -&amp;gt; bool: dirs = [0, 1, 0, -1, 0] m = len(grid) n = len(grid[0]) nFloors = 0 cat = 0 # cat&amp;#39;s position mouse = 0 # mouse&amp;#39;s position def hash(i: int, j: int) -&amp;gt; int: return i * n + j for i in range(m): for j in range(n): if grid[i][j] != &amp;#34;#&amp;#34;: nFloors += 1 if grid[i][j] == &amp;#34;C&amp;#34;: cat = hash(i, j) elif grid[i][j] == &amp;#34;M&amp;#34;: mouse = hash(i, j) # dp(i, j, k) := True if mouse can win w// # Cat on (i // 8, i % 8), mouse on (j // 8, j % 8), and turns = k @functools.</description></item><item><title>1735. Count Ways to Make Array With Product</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1735/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1735/</guid><description>LeetCode problem 1735
N = 10020 MOD = 10**9 + 7 f = [1] * N g = [1] * N p = defaultdict(list) for i in range(1, N): f[i] = f[i - 1] * i % MOD g[i] = pow(f[i], MOD - 2, MOD) x = i j = 2 while j &amp;lt;= x // j: if x % j == 0: cnt = 0 while x % j == 0: cnt += 1 x //= j p[i].</description></item><item><title>1739. Building Boxes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1739/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1739/</guid><description>LeetCode problem 1739
class Solution: def minimumBoxes(self, n: int) -&amp;gt; int: s, k = 0, 1 while s + k * (k + 1) // 2 &amp;lt;= n: s += k * (k + 1) // 2 k += 1 k -= 1 res = k * (k + 1) // 2 k = 1 while s &amp;lt; n: res += 1 s += k k += 1 return res</description></item><item><title>1745. Palindrome Partitioning IV</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1745/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1745/</guid><description>LeetCode problem 1745
class Solution: def checkPartitioning(self, s: str) -&amp;gt; bool: n = len(s) g = [[True] * n for _ in range(n)] for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][j] = s[i] == s[j] and (i + 1 == j or g[i + 1][j - 1]) for i in range(n - 2): for j in range(i + 1, n - 1): if g[0][i] and g[i + 1][j] and g[j + 1][-1]: return True return False</description></item><item><title>1751. Maximum Number of Events That Can Be Attended II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1751/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1751/</guid><description>LeetCode problem 1751
class Solution: def maxValue(self, events: List[List[int]], k: int) -&amp;gt; int: events.sort(key=lambda x: x[1]) n = len(events) f = [[0] * (k + 1) for _ in range(n + 1)] for i, (st, _, val) in enumerate(events, 1): p = bisect_left(events, st, hi=i - 1, key=lambda x: x[1]) for j in range(1, k + 1): f[i][j] = max(f[i - 1][j], f[p][j - 1] + val) return f[n][k]</description></item><item><title>1755. Closest Subsequence Sum</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1755/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1755/</guid><description>LeetCode problem 1755
class Solution: def minAbsDifference(self, nums: List[int], goal: int) -&amp;gt; int: def dfs(arr, res, i, s): if i == len(arr): res.add(s) return dfs(arr, res, i + 1, s) dfs(arr, res, i + 1, s + arr[i]) n = len(nums) left, right = set(), set() dfs(nums[: n &amp;gt;&amp;gt; 1], left, 0, 0) dfs(nums[n &amp;gt;&amp;gt; 1 :], right, 0, 0) right = sorted(right) res = inf for l in left: x = goal - l i = bisect_left(right, x) if i &amp;lt; len(right): res = min(res, abs(x - right[i])) if i: res = min(res, abs(x - right[i - 1])) return res</description></item><item><title>1761. Minimum Degree of a Connected Trio in a Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1761/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1761/</guid><description>LeetCode problem 1761
class Solution: def minTrioDegree(self, n: int, edges: List[List[int]]) -&amp;gt; int: g = [[False] * n for _ in range(n)] deg = [0] * n for u, v in edges: u, v = u - 1, v - 1 g[u][v] = g[v][u] = True deg[u] += 1 deg[v] += 1 res = inf for i in range(n): for j in range(i + 1, n): if g[i][j]: for k in range(j + 1, n): if g[i][k] and g[j][k]: res = min(res, deg[i] + deg[j] + deg[k] - 6) return -1 if res == inf else res</description></item><item><title>1766. Tree of Coprimes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1766/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1766/</guid><description>LeetCode problem 1766
class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -&amp;gt; List[int]: def dfs(i, fa, depth): t = k = -1 for v in f[nums[i]]: stk = stks[v] if stk and stk[-1][1] &amp;gt; k: t, k = stk[-1] res[i] = t for j in g[i]: if j != fa: stks[nums[i]].append((i, depth)) dfs(j, i, depth + 1) stks[nums[i]].pop() g = defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) f = defaultdict(list) for i in range(1, 51): for j in range(1, 51): if gcd(i, j) == 1: f[i].</description></item><item><title>1770. Maximum Score from Performing Multiplication Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1770/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1770/</guid><description>LeetCode problem 1770
class Solution: def maximumScore(self, nums: List[int], multipliers: List[int]) -&amp;gt; int: n, m = len(nums), len(multipliers) f = [[-inf] * (m + 1) for _ in range(m + 1)] f[0][0] = 0 res = -inf for i in range(m + 1): for j in range(m - i + 1): k = i + j - 1 if i &amp;gt; 0: f[i][j] = max(f[i][j], f[i - 1][j] + multipliers[k] * nums[i - 1]) if j &amp;gt; 0: f[i][j] = max(f[i][j], f[i][j - 1] + multipliers[k] * nums[n - j]) if i + j == m: res = max(res, f[i][j]) return res</description></item><item><title>1771. Maximize Palindrome Length From Subsequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1771/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1771/</guid><description>LeetCode problem 1771
class Solution: def longestPalindrome(self, word1: str, word2: str) -&amp;gt; int: s = word1 + word2 n = len(s) f = [[0] * n for _ in range(n)] for i in range(n): f[i][i] = 1 res = 0 for i in range(n - 2, -1, -1): for j in range(i + 1, n): if s[i] == s[j]: f[i][j] = f[i + 1][j - 1] + 2 if i &amp;lt; len(word1) &amp;lt;= j: res = max(res, f[i][j]) else: f[i][j] = max(f[i + 1][j], f[i][j - 1]) return res</description></item><item><title>1776. Car Fleet II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1776/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1776/</guid><description>LeetCode problem 1776
class Solution: def getCollisionTimes(self, cars: List[List[int]]) -&amp;gt; List[float]: stk = [] n = len(cars) res = [-1] * n for i in range(n - 1, -1, -1): while stk: j = stk[-1] if cars[i][1] &amp;gt; cars[j][1]: t = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]) if res[j] == -1 or t &amp;lt;= res[j]: res[i] = t break stk.pop() stk.append(i) return res</description></item><item><title>1782. Count Pairs Of Nodes</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1782/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1782/</guid><description>LeetCode problem 1782
class Solution: def countPairs( self, n: int, edges: List[List[int]], queries: List[int] ) -&amp;gt; List[int]: cnt = [0] * n g = defaultdict(int) for a, b in edges: a, b = a - 1, b - 1 a, b = min(a, b), max(a, b) cnt[a] += 1 cnt[b] += 1 g[(a, b)] += 1 s = sorted(cnt) res = [0] * len(queries) for i, t in enumerate(queries): for j, x in enumerate(s): k = bisect_right(s, t - x, lo=j + 1) res[i] += n - k for (a, b), v in g.</description></item><item><title>1787. Make the XOR of All Segments Equal to Zero</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1787/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1787/</guid><description>LeetCode problem 1787
class Solution: def minChanges(self, nums: List[int], k: int) -&amp;gt; int: n = 1 &amp;lt;&amp;lt; 10 cnt = [Counter() for _ in range(k)] size = [0] * k for i, v in enumerate(nums): cnt[i % k][v] += 1 size[i % k] += 1 f = [inf] * n f[0] = 0 for i in range(k): g = [min(f) + size[i]] * n for j in range(n): for v, c in cnt[i].items(): g[j] = min(g[j], f[j ^ v] + size[i] - c) f = g return f[0]</description></item><item><title>1788. Maximize the Beauty of the Garden</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1788/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1788/</guid><description>LeetCode problem 1788
class Solution: def maximumBeauty(self, flowers: List[int]) -&amp;gt; int: s = [0] * (len(flowers) + 1) d = {} res = -inf for i, v in enumerate(flowers): if v in d: res = max(res, s[i] - s[d[v] + 1] + v * 2) else: d[v] = i s[i + 1] = s[i] + max(v, 0) return res</description></item><item><title>1793. Maximum Score of a Good Subarray</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1793/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1793/</guid><description>LeetCode problem 1793
class Solution: def maximumScore(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): v = nums[i] while stk and nums[stk[-1]] &amp;gt; v: stk.pop() if stk: right[i] = stk[-1] stk.append(i) res = 0 for i, v in enumerate(nums): if left[i] + 1 &amp;lt;= k &amp;lt;= right[i] - 1: res = max(res, v * (right[i] - left[i] - 1)) return res</description></item><item><title>1799. Maximize Score After N Operations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1799/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1799/</guid><description>LeetCode problem 1799
class Solution: def maxScore(self, nums: List[int]) -&amp;gt; int: m = len(nums) f = [0] * (1 &amp;lt;&amp;lt; m) g = [[0] * m for _ in range(m)] for i in range(m): for j in range(i + 1, m): g[i][j] = gcd(nums[i], nums[j]) for k in range(1 &amp;lt;&amp;lt; m): if (cnt := k.bit_count()) % 2 == 0: for i in range(m): if k &amp;gt;&amp;gt; i &amp;amp; 1: for j in range(i + 1, m): if k &amp;gt;&amp;gt; j &amp;amp; 1: f[k] = max( f[k], f[k ^ (1 &amp;lt;&amp;lt; i) ^ (1 &amp;lt;&amp;lt; j)] + cnt // 2 * g[i][j], ) return f[-1]</description></item><item><title>1803. Count Pairs With XOR in a Range</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1803/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1803/</guid><description>LeetCode problem 1803
class Trie: def __init__(self): self.children = [None] * 2 self.cnt = 0 def insert(self, x): node = self for i in range(15, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v] is None: node.children[v] = Trie() node = node.children[v] node.cnt += 1 def search(self, x, limit): node = self res = 0 for i in range(15, -1, -1): if node is None: return res v = x &amp;gt;&amp;gt; i &amp;amp; 1 if limit &amp;gt;&amp;gt; i &amp;amp; 1: if node.</description></item><item><title>1808. Maximize Number of Nice Divisors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1808/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1808/</guid><description>LeetCode problem 1808
class Solution: def maxNiceDivisors(self, primeFactors: int) -&amp;gt; int: mod = 10**9 + 7 if primeFactors &amp;lt; 4: return primeFactors if primeFactors % 3 == 0: return pow(3, primeFactors // 3, mod) % mod if primeFactors % 3 == 1: return 4 * pow(3, primeFactors // 3 - 1, mod) % mod return 2 * pow(3, primeFactors // 3, mod) % mod</description></item><item><title>1815. Maximum Number of Groups Getting Fresh Donuts</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1815/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1815/</guid><description>LeetCode problem 1815
class Solution: def maxHappyGroups(self, batchSize: int, groups: List[int]) -&amp;gt; int: @cache def dfs(state, x): if state == mask: return 0 vis = [False] * batchSize res = 0 for i, v in enumerate(g): if state &amp;gt;&amp;gt; i &amp;amp; 1 == 0 and not vis[v]: vis[v] = True y = (x + v) % batchSize res = max(res, dfs(state | 1 &amp;lt;&amp;lt; i, y)) return res + (x == 0) g = [v % batchSize for v in groups if v % batchSize] mask = (1 &amp;lt;&amp;lt; len(g)) - 1 return len(groups) - len(g) + dfs(0, 0)</description></item><item><title>1819. Number of Different Subsequences GCDs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1819/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1819/</guid><description>LeetCode problem 1819
class Solution: def countDifferentSubsequenceGCDs(self, nums: List[int]) -&amp;gt; int: mx = max(nums) vis = set(nums) res = 0 for x in range(1, mx + 1): g = 0 for y in range(x, mx + 1, x): if y in vis: g = gcd(g, y) if g == x: res += 1 break return res</description></item><item><title>1825. Finding MK Average</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1825/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1825/</guid><description>LeetCode problem 1825
from sortedcontainers import SortedList class MKAverage: def __init__(self, m: int, k: int): self.m = m self.k = k self.sl = SortedList() self.q = deque() self.s = 0 def addElement(self, num: int) -&amp;gt; None: self.q.append(num) if len(self.q) == self.m: self.sl = SortedList(self.q) self.s = sum(self.sl[self.k : -self.k]) elif len(self.q) &amp;gt; self.m: i = self.sl.bisect_left(num) if i &amp;lt; self.k: self.s += self.sl[self.k - 1] elif self.k &amp;lt;= i &amp;lt;= self.m - self.k: self.s += num else: self.s += self.</description></item><item><title>1830. Minimum Number of Operations to Make String Sorted</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1830/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1830/</guid><description>LeetCode problem 1830
n = 3010 mod = 10**9 + 7 f = [1] + [0] * n g = [1] + [0] * n for i in range(1, n): f[i] = f[i - 1] * i % mod g[i] = pow(f[i], mod - 2, mod) class Solution: def makeStringSorted(self, s: str) -&amp;gt; int: cnt = Counter(s) res, n = 0, len(s) for i, c in enumerate(s): m = sum(v for a, v in cnt.items() if a &amp;lt; c) t = f[n - i - 1] * m for v in cnt.</description></item><item><title>1835. Find XOR Sum of All Pairs Bitwise AND</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1835/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1835/</guid><description>LeetCode problem 1835
class Solution: def getXORSum(self, arr1: List[int], arr2: List[int]) -&amp;gt; int: a = reduce(xor, arr1) b = reduce(xor, arr2) return a &amp;amp; b</description></item><item><title>1840. Maximum Building Height</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1840/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1840/</guid><description>LeetCode problem 1840
class Solution: def maxBuilding(self, n: int, restrictions: List[List[int]]) -&amp;gt; int: r = restrictions r.append([1, 0]) r.sort() if r[-1][0] != n: r.append([n, n - 1]) m = len(r) for i in range(1, m): r[i][1] = min(r[i][1], r[i - 1][1] + r[i][0] - r[i - 1][0]) for i in range(m - 2, 0, -1): r[i][1] = min(r[i][1], r[i + 1][1] + r[i + 1][0] - r[i][0]) res = 0 for i in range(m - 1): t = (r[i][1] + r[i + 1][1] + r[i + 1][0] - r[i][0]) // 2 res = max(res, t) return res</description></item><item><title>1842. Next Palindrome Using Same Digits</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1842/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1842/</guid><description>LeetCode problem 1842
class Solution: def nextPalindrome(self, num: str) -&amp;gt; str: def next_permutation(nums: List[str]) -&amp;gt; bool: n = len(nums) // 2 i = n - 2 while i &amp;gt;= 0 and nums[i] &amp;gt;= nums[i + 1]: i -= 1 if i &amp;lt; 0: return False j = n - 1 while j &amp;gt;= 0 and nums[j] &amp;lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1 : n] = nums[i + 1 : n][::-1] return True nums = list(num) if not next_permutation(nums): return &amp;#34;&amp;#34; n = len(nums) for i in range(n // 2): nums[n - i - 1] = nums[i] return &amp;#34;&amp;#34;.</description></item><item><title>1847. Closest Room</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1847/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1847/</guid><description>LeetCode problem 1847
from sortedcontainers import SortedList class Solution: def closestRoom( self, rooms: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: rooms.sort(key=lambda x: x[1]) k = len(queries) idx = sorted(range(k), key=lambda i: queries[i][1]) res = [-1] * k i, n = 0, len(rooms) sl = SortedList(x[0] for x in rooms) for j in idx: prefer, minSize = queries[j] while i &amp;lt; n and rooms[i][1] &amp;lt; minSize: sl.remove(rooms[i][0]) i += 1 if i == n: break p = sl.bisect_left(prefer) if p &amp;lt; len(sl): res[j] = sl[p] if p and (res[j] == -1 or res[j] - prefer &amp;gt;= prefer - sl[p - 1]): res[j] = sl[p - 1] return res</description></item><item><title>1851. Minimum Interval to Include Each Query</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1851/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1851/</guid><description>LeetCode problem 1851
class Solution: def minInterval(self, intervals: List[List[int]], queries: List[int]) -&amp;gt; List[int]: n, m = len(intervals), len(queries) intervals.sort() queries = sorted((x, i) for i, x in enumerate(queries)) res = [-1] * m pq = [] i = 0 for x, j in queries: while i &amp;lt; n and intervals[i][0] &amp;lt;= x: a, b = intervals[i] heappush(pq, (b - a + 1, b)) i += 1 while pq and pq[0][1] &amp;lt; x: heappop(pq) if pq: res[j] = pq[0][0] return res</description></item><item><title>1857. Largest Color Value in a Directed Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1857/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1857/</guid><description>LeetCode problem 1857
class Solution: def largestPathValue(self, colors: str, edges: List[List[int]]) -&amp;gt; int: n = len(colors) indeg = [0] * n g = defaultdict(list) for a, b in edges: g[a].append(b) indeg[b] += 1 q = deque() dp = [[0] * 26 for _ in range(n)] for i, v in enumerate(indeg): if v == 0: q.append(i) c = ord(colors[i]) - ord(&amp;#39;a&amp;#39;) dp[i][c] += 1 cnt = 0 res = 1 while q: i = q.popleft() cnt += 1 for j in g[i]: indeg[j] -= 1 if indeg[j] == 0: q.</description></item><item><title>1862. Sum of Floored Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1862/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1862/</guid><description>LeetCode problem 1862
class Solution: def sumOfFlooredPairs(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 cnt = Counter(nums) mx = max(nums) s = [0] * (mx + 1) for i in range(1, mx + 1): s[i] = s[i - 1] + cnt[i] res = 0 for y in range(1, mx + 1): if cnt[y]: d = 1 while d * y &amp;lt;= mx: res += cnt[y] * d * (s[min(mx, d * y + y - 1)] - s[d * y - 1]) res %= mod d += 1 return res</description></item><item><title>1866. Number of Ways to Rearrange Sticks With K Sticks Visible</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1866/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1866/</guid><description>LeetCode problem 1866
class Solution: def rearrangeSticks(self, n: int, k: int) -&amp;gt; int: mod = 10**9 + 7 f = [1] + [0] * k for i in range(1, n + 1): for j in range(k, 0, -1): f[j] = (f[j] * (i - 1) + f[j - 1]) % mod f[0] = 0 return f[k]</description></item><item><title>1872. Stone Game VIII</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1872/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1872/</guid><description>LeetCode problem 1872
class Solution: def stoneGameVIII(self, stones: List[int]) -&amp;gt; int: s = list(accumulate(stones)) f = s[-1] for i in range(len(s) - 2, 0, -1): f = max(f, s[i] - f) return f</description></item><item><title>1879. Minimum XOR Sum of Two Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1879/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1879/</guid><description>LeetCode problem 1879
class Solution: def minimumXORSum(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums2) f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): k = i.bit_count() - 1 for j in range(n): if i &amp;gt;&amp;gt; j &amp;amp; 1: f[i] = min(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + (nums1[k] ^ nums2[j])) return f[-1]</description></item><item><title>1883. Minimum Skips to Arrive at Meeting On Time</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1883/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1883/</guid><description>LeetCode problem 1883
class Solution: def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -&amp;gt; int: n = len(dist) f = [[inf] * (n + 1) for _ in range(n + 1)] f[0][0] = 0 for i, x in enumerate(dist, 1): for j in range(i + 1): if j &amp;lt; i: f[i][j] = min(f[i][j], ((f[i - 1][j] + x - 1) // speed + 1) * speed) if j: f[i][j] = min(f[i][j], f[i - 1][j - 1] + x) for j in range(n + 1): if f[n][j] &amp;lt;= hoursBefore * speed: return j return -1</description></item><item><title>1889. Minimum Space Wasted From Packaging</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1889/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1889/</guid><description>LeetCode problem 1889
class Solution: def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -&amp;gt; int: mod = 10**9 + 7 res = inf packages.sort() for box in boxes: box.sort() if packages[-1] &amp;gt; box[-1]: continue s = i = 0 for b in box: j = bisect_right(packages, b, lo=i) s += (j - i) * b i = j res = min(res, s) if res == inf: return -1 return (res - sum(packages)) % mod</description></item><item><title>1900. The Earliest and Latest Rounds Where Players Compete</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1900/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1900/</guid><description>LeetCode problem 1900
class Solution: def earliestAndLatest( self, n: int, firstPlayer: int, secondPlayer: int ) -&amp;gt; List[int]: # dp[i][j][k] := (earliest, latest) pair w/ firstPlayer is i-th player from # Front, secondPlayer is j-th player from end, and there&amp;#39;re k people @functools.lru_cache(None) def dp(l: int, r: int, k: int) -&amp;gt; List[int]: if l == r: return [1, 1] if l &amp;gt; r: return dp(r, l, k) a = math.inf b = -math.inf # Enumerate all possible positions for i in range(1, l + 1): for j in range(l - i + 1, r - i + 1): if not l + r - k // 2 &amp;lt;= i + j &amp;lt;= (k + 1) // 2: continue x, y = dp(i, j, (k + 1) // 2) a = min(a, x + 1) b = max(b, y + 1) return [a, b] return dp(firstPlayer, n - secondPlayer + 1, n)</description></item><item><title>1912. Design Movie Rental System</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1912/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1912/</guid><description>LeetCode problem 1912
from sortedcontainers import SortedList class MovieRentingSystem: def __init__(self, n: int, entries: List[List[int]]): self.unrented = collections.defaultdict(SortedList) # {movie: (price, shop)} self.shopAndMovieToPrice = {} # {(shop, movie): price} self.rented = SortedList() # (price, shop, movie) for shop, movie, price in entries: self.unrented[movie].add((price, shop)) self.shopAndMovieToPrice[(shop, movie)] = price def search(self, movie: int) -&amp;gt; List[int]: return [shop for _, shop in self.unrented[movie][:5]] def rent(self, shop: int, movie: int) -&amp;gt; None: price = self.shopAndMovieToPrice[(shop, movie)] self.unrented[movie].remove((price, shop)) self.rented.add((price, shop, movie)) def drop(self, shop: int, movie: int) -&amp;gt; None: price = self.</description></item><item><title>1923. Longest Common Subpath</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1923/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1923/</guid><description>LeetCode problem 1923
class Solution: def longestCommonSubpath(self, n: int, paths: List[List[int]]) -&amp;gt; int: def check(k: int) -&amp;gt; bool: cnt = Counter() for h in hh: vis = set() for i in range(1, len(h) - k + 1): j = i + k - 1 x = (h[j] - h[i - 1] * p[j - i + 1]) % mod if x not in vis: vis.add(x) cnt[x] += 1 return max(cnt.values()) == m m = len(paths) mx = max(len(path) for path in paths) base = 133331 mod = 2**64 + 1 p = [0] * (mx + 1) p[0] = 1 for i in range(1, len(p)): p[i] = p[i - 1] * base % mod hh = [] for path in paths: k = len(path) h = [0] * (k + 1) for i, x in enumerate(path, 1): h[i] = h[i - 1] * base % mod + x hh.</description></item><item><title>1931. Painting a Grid With Three Different Colors</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1931/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1931/</guid><description>LeetCode problem 1931
class Solution: def colorTheGrid(self, m: int, n: int) -&amp;gt; int: def f1(x: int) -&amp;gt; bool: last = -1 for _ in range(m): if x % 3 == last: return False last = x % 3 x //= 3 return True def f2(x: int, y: int) -&amp;gt; bool: for _ in range(m): if x % 3 == y % 3: return False x, y = x // 3, y // 3 return True mod = 10**9 + 7 mx = 3**m valid = {i for i in range(mx) if f1(i)} d = defaultdict(list) for x in valid: for y in valid: if f2(x, y): d[x].</description></item><item><title>1944. Number of Visible People in a Queue</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1944/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1944/</guid><description>LeetCode problem 1944
class Solution: def canSeePersonsCount(self, heights: List[int]) -&amp;gt; List[int]: n = len(heights) res = [0] * n stk = [] for i in range(n - 1, -1, -1): while stk and stk[-1] &amp;lt; heights[i]: res[i] += 1 stk.pop() if stk: res[i] += 1 stk.append(heights[i]) return res</description></item><item><title>1955. Count Number of Special Subsequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1955/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1955/</guid><description>LeetCode problem 1955
class Solution: def countSpecialSubsequences(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 n = len(nums) f = [0] * 3 f[0] = nums[0] == 0 for i in range(1, n): if nums[i] == 0: f[0] = (2 * f[0] + 1) % mod elif nums[i] == 1: f[1] = (f[0] + 2 * f[1]) % mod else: f[2] = (f[1] + 2 * f[2]) % mod return f[2]</description></item><item><title>1964. Find the Longest Valid Obstacle Course at Each Position</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1964/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1964/</guid><description>LeetCode problem 1964
class BinaryIndexedTree: __slots__ = [&amp;#34;n&amp;#34;, &amp;#34;c&amp;#34;] def __init__(self, n: int): self.n = n self.c = [0] * (n + 1) def update(self, x: int, v: int): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], v) x += x &amp;amp; -x def query(self, x: int) -&amp;gt; int: s = 0 while x: s = max(s, self.c[x]) x -= x &amp;amp; -x return s class Solution: def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -&amp;gt; List[int]: nums = sorted(set(obstacles)) n = len(nums) tree = BinaryIndexedTree(n) res = [] for x in obstacles: i = bisect_left(nums, x) + 1 res.</description></item><item><title>1970. Last Day Where You Can Still Cross</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1970/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1970/</guid><description>LeetCode problem 1970
class Solution: def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -&amp;gt; int: n = row * col p = list(range(n + 2)) grid = [[False] * col for _ in range(row)] top, bottom = n, n + 1 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def check(i, j): return 0 &amp;lt;= i &amp;lt; row and 0 &amp;lt;= j &amp;lt; col and grid[i][j] for k in range(len(cells) - 1, -1, -1): i, j = cells[k][0] - 1, cells[k][1] - 1 grid[i][j] = True for x, y in [[0, 1], [0, -1], [1, 0], [-1, 0]]: if check(i + x, j + y): p[find(i * col + j)] = find((i + x) * col + j + y) if i == 0: p[find(i * col + j)] = find(top) if i == row - 1: p[find(i * col + j)] = find(bottom) if find(top) == find(bottom): return k return 0</description></item><item><title>1977. Number of Ways to Separate Numbers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1977/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1977/</guid><description>LeetCode problem 1977
class Solution: def numberOfCombinations(self, num: str) -&amp;gt; int: def cmp(i, j, k): x = lcp[i][j] return x &amp;gt;= k or num[i + x] &amp;gt;= num[j + x] mod = 10**9 + 7 n = len(num) lcp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n - 1, -1, -1): for j in range(n - 1, -1, -1): if num[i] == num[j]: lcp[i][j] = 1 + lcp[i + 1][j + 1] dp = [[0] * (n + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(1, i + 1): v = 0 if num[i - j] !</description></item><item><title>1982. Find Array Given Subset Sums</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1982/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1982/</guid><description>LeetCode problem 1982
class Solution: def recoverArray(self, n: int, sums: List[int]) -&amp;gt; List[int]: sums.sort() res = [] for i in range(n, 0, -1): k = 1 &amp;lt;&amp;lt; i d = sums[k - 1] - sums[k - 2] cnt = Counter(sums[:k]) sums1, sums2 = [], [] sign = 1 for s in sums[:k]: if not cnt[s]: continue cnt[s] -= 1 cnt[s + d] -= 1 sums1.append(s) sums2.append(s + d) if s + d == 0: sign = -1 res.append(sign * d) sums = sums1 if sign == 1 else sums2 return res</description></item><item><title>1987. Number of Unique Good Subsequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1987/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1987/</guid><description>LeetCode problem 1987
class Solution: def numberOfUniqueGoodSubsequences(self, binary: str) -&amp;gt; int: f = g = 0 res = 0 mod = 10**9 + 7 for c in binary: if c == &amp;#34;0&amp;#34;: g = (g + f) % mod res = 1 else: f = (f + g + 1) % mod res = (res + f + g) % mod return res</description></item><item><title>1994. The Number of Good Subsets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1994/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1994/</guid><description>LeetCode problem 1994
class Solution: def numberOfGoodSubsets(self, nums: List[int]) -&amp;gt; int: primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] cnt = Counter(nums) mod = 10**9 + 7 n = len(primes) f = [0] * (1 &amp;lt;&amp;lt; n) f[0] = pow(2, cnt[1]) for x in range(2, 31): if cnt[x] == 0 or x % 4 == 0 or x % 9 == 0 or x % 25 == 0: continue mask = 0 for i, p in enumerate(primes): if x % p == 0: mask |= 1 &amp;lt;&amp;lt; i for state in range((1 &amp;lt;&amp;lt; n) - 1, 0, -1): if state &amp;amp; mask == mask: f[state] = (f[state] + cnt[x] * f[state ^ mask]) % mod return sum(f[i] for i in range(1, 1 &amp;lt;&amp;lt; n)) % mod</description></item><item><title>1998. GCD Sort of an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1998/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/1998/</guid><description>LeetCode problem 1998
class Solution: def gcdSort(self, nums: List[int]) -&amp;gt; bool: n = 10**5 + 10 p = list(range(n)) f = defaultdict(list) mx = max(nums) for i in range(2, mx + 1): if f[i]: continue for j in range(i, mx + 1, i): f[j].append(i) def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] for i in nums: for j in f[i]: p[find(i)] = find(j) s = sorted(nums) for i, num in enumerate(nums): if s[i] != num and find(num) !</description></item><item><title>2003. Smallest Missing Genetic Value in Each Subtree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2003/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2003/</guid><description>LeetCode problem 2003
class Solution: def smallestMissingValueSubtree( self, parents: List[int], nums: List[int] ) -&amp;gt; List[int]: def dfs(i: int): if vis[i]: return vis[i] = True if nums[i] &amp;lt; len(has): has[nums[i]] = True for j in g[i]: dfs(j) n = len(nums) res = [1] * n g = [[] for _ in range(n)] idx = -1 for i, p in enumerate(parents): if i: g[p].append(i) if nums[i] == 1: idx = i if idx == -1: return res vis = [False] * n has = [False] * (n + 2) i = 2 while idx !</description></item><item><title>2009. Minimum Number of Operations to Make Array Continuous</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2009/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2009/</guid><description>LeetCode problem 2009
class Solution: def minOperations(self, nums: List[int]) -&amp;gt; int: n = len(nums) nums = sorted(set(nums)) res, j = n, 0 for i, v in enumerate(nums): while j &amp;lt; len(nums) and nums[j] - v &amp;lt;= n - 1: j += 1 res = min(res, n - (j - i)) return res</description></item><item><title>2019. The Score of Students Solving Math Expression</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2019/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2019/</guid><description>LeetCode problem 2019
class Solution: def scoreOfStudents(self, s: str, answers: List[int]) -&amp;gt; int: def cal(s: str) -&amp;gt; int: res, pre = 0, int(s[0]) for i in range(1, n, 2): if s[i] == &amp;#34;*&amp;#34;: pre *= int(s[i + 1]) else: res += pre pre = int(s[i + 1]) res += pre return res n = len(s) x = cal(s) m = (n + 1) &amp;gt;&amp;gt; 1 f = [[set() for _ in range(m)] for _ in range(m)] for i in range(m): f[i][i] = {int(s[i &amp;lt;&amp;lt; 1])} for i in range(m - 1, -1, -1): for j in range(i, m): for k in range(i, j): for l in f[i][k]: for r in f[k + 1][j]: if s[k &amp;lt;&amp;lt; 1 | 1] == &amp;#34;+&amp;#34; and l + r &amp;lt;= 1000: f[i][j].</description></item><item><title>2025. Maximum Number of Ways to Partition an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2025/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2025/</guid><description>LeetCode problem 2025
class Solution: def waysToPartition(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) s = [nums[0]] * n right = defaultdict(int) for i in range(1, n): s[i] = s[i - 1] + nums[i] right[s[i - 1]] += 1 res = 0 if s[-1] % 2 == 0: res = right[s[-1] // 2] left = defaultdict(int) for v, x in zip(s, nums): d = k - x if (s[-1] + d) % 2 == 0: t = left[(s[-1] + d) // 2] + right[(s[-1] - d) // 2] if res &amp;lt; t: res = t left[v] += 1 right[v] -= 1 return res</description></item><item><title>2035. Partition Array Into Two Arrays to Minimize Sum Difference</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2035/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2035/</guid><description>LeetCode problem 2035
class Solution: def minimumDifference(self, nums: List[int]) -&amp;gt; int: n = len(nums) &amp;gt;&amp;gt; 1 f = defaultdict(set) g = defaultdict(set) for i in range(1 &amp;lt;&amp;lt; n): s = cnt = 0 s1 = cnt1 = 0 for j in range(n): if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) != 0: s += nums[j] cnt += 1 s1 += nums[n + j] cnt1 += 1 else: s -= nums[j] s1 -= nums[n + j] f[cnt].add(s) g[cnt1].add(s1) res = inf for i in range(n + 1): fi, gi = sorted(list(f[i])), sorted(list(g[n - i])) # min(abs(f[i] + g[n - i])) for a in fi: left, right = 0, len(gi) - 1 b = -a while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if gi[mid] &amp;gt;= b: right = mid else: left = mid + 1 res = min(res, abs(a + gi[left])) if left &amp;gt; 0: res = min(res, abs(a + gi[left - 1])) return res</description></item><item><title>2045. Second Minimum Time to Reach Destination</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2045/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2045/</guid><description>LeetCode problem 2045
class Solution: def secondMinimum( self, n: int, edges: List[List[int]], time: int, change: int ) -&amp;gt; int: g = defaultdict(set) for u, v in edges: g[u].add(v) g[v].add(u) q = deque([(1, 0)]) dist = [[inf] * 2 for _ in range(n + 1)] dist[1][1] = 0 while q: u, d = q.popleft() for v in g[u]: if d + 1 &amp;lt; dist[v][0]: dist[v][0] = d + 1 q.append((v, d + 1)) elif dist[v][0] &amp;lt; d + 1 &amp;lt; dist[v][1]: dist[v][1] = d + 1 if v == n: break q.</description></item><item><title>2050. Parallel Courses III</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2050/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2050/</guid><description>LeetCode problem 2050
class Solution: def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -&amp;gt; int: g = defaultdict(list) indeg = [0] * n for a, b in relations: g[a - 1].append(b - 1) indeg[b - 1] += 1 q = deque() f = [0] * n res = 0 for i, (v, t) in enumerate(zip(indeg, time)): if v == 0: q.append(i) f[i] = t res = max(res, t) while q: i = q.popleft() for j in g[i]: f[j] = max(f[j], f[i] + time[j]) res = max(res, f[j]) indeg[j] -= 1 if indeg[j] == 0: q.</description></item><item><title>2071. Maximum Number of Tasks You Can Assign</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2071/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2071/</guid><description>LeetCode problem 2071
class Solution: def maxTaskAssign( self, tasks: List[int], workers: List[int], pills: int, strength: int ) -&amp;gt; int: def check(x): i = 0 q = deque() p = pills for j in range(m - x, m): while i &amp;lt; x and tasks[i] &amp;lt;= workers[j] + strength: q.append(tasks[i]) i += 1 if not q: return False if q[0] &amp;lt;= workers[j]: q.popleft() elif p == 0: return False else: p -= 1 q.pop() return True n, m = len(tasks), len(workers) tasks.</description></item><item><title>2076. Process Restricted Friend Requests</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2076/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2076/</guid><description>LeetCode problem 2076
class Solution: def friendRequests( self, n: int, restrictions: List[List[int]], requests: List[List[int]] ) -&amp;gt; List[bool]: p = list(range(n)) def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] res = [] i = 0 for u, v in requests: if find(u) == find(v): res.append(True) else: valid = True for x, y in restrictions: if (find(u) == find(x) and find(v) == find(y)) or ( find(u) == find(y) and find(v) == find(x) ): valid = False break res.</description></item><item><title>2088. Count Fertile Pyramids in a Land</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2088/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2088/</guid><description>LeetCode problem 2088
class Solution: def countPyramids(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) f = [[0] * n for _ in range(m)] res = 0 for i in range(m - 1, -1, -1): for j in range(n): if grid[i][j] == 0: f[i][j] = -1 elif not (i == m - 1 or j == 0 or j == n - 1): f[i][j] = min(f[i + 1][j - 1], f[i + 1][j], f[i + 1][j + 1]) + 1 res += f[i][j] for i in range(m): for j in range(n): if grid[i][j] == 0: f[i][j] = -1 elif i == 0 or j == 0 or j == n - 1: f[i][j] = 0 else: f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i - 1][j + 1]) + 1 res += f[i][j] return res</description></item><item><title>2092. Find All People With Secret</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2092/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2092/</guid><description>LeetCode problem 2092
class Solution: def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -&amp;gt; List[int]: vis = [False] * n vis[0] = vis[firstPerson] = True meetings.sort(key=lambda x: x[2]) i, m = 0, len(meetings) while i &amp;lt; m: j = i while j + 1 &amp;lt; m and meetings[j + 1][2] == meetings[i][2]: j += 1 s = set() g = defaultdict(list) for x, y, _ in meetings[i : j + 1]: g[x].append(y) g[y].append(x) s.update([x, y]) q = deque([u for u in s if vis[u]]) while q: u = q.</description></item><item><title>2106. Maximum Fruits Harvested After at Most K Steps</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2106/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2106/</guid><description>LeetCode problem 2106
class Solution: def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -&amp;gt; int: res = i = s = 0 for j, (pj, fj) in enumerate(fruits): s += fj while ( i &amp;lt;= j and pj - fruits[i][0] + min(abs(startPos - fruits[i][0]), abs(startPos - fruits[j][0])) &amp;gt; k ): s -= fruits[i][1] i += 1 res = max(res, s) return res</description></item><item><title>2111. Minimum Operations to Make the Array K-Increasing</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2111/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2111/</guid><description>LeetCode problem 2111
class Solution: def kIncreasing(self, arr: List[int], k: int) -&amp;gt; int: def lis(arr): t = [] for x in arr: idx = bisect_right(t, x) if idx == len(t): t.append(x) else: t[idx] = x return len(arr) - len(t) return sum(lis(arr[i::k]) for i in range(k))</description></item><item><title>2117. Abbreviating the Product of a Range</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2117/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2117/</guid><description>LeetCode problem 2117
class Solution: def abbreviateProduct(self, left: int, right: int) -&amp;gt; str: cnt2 = cnt5 = 0 for x in range(left, right + 1): while x % 2 == 0: cnt2 += 1 x //= 2 while x % 5 == 0: cnt5 += 1 x //= 5 c = cnt2 = cnt5 = min(cnt2, cnt5) pre = suf = 1 gt = False for x in range(left, right + 1): suf *= x while cnt2 and suf % 2 == 0: suf //= 2 cnt2 -= 1 while cnt5 and suf % 5 == 0: suf //= 5 cnt5 -= 1 if suf &amp;gt;= 1e10: gt = True suf %= int(1e10) pre *= x while pre &amp;gt; 1e5: pre /= 10 if gt: return str(int(pre)) + &amp;#34;.</description></item><item><title>2122. Recover the Original Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2122/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2122/</guid><description>LeetCode problem 2122
class Solution: def recoverArray(self, nums: List[int]) -&amp;gt; List[int]: nums.sort() n = len(nums) for i in range(1, n): d = nums[i] - nums[0] if d == 0 or d % 2 == 1: continue vis = [False] * n vis[i] = True res = [(nums[0] + nums[i]) &amp;gt;&amp;gt; 1] l, r = 1, i + 1 while r &amp;lt; n: while l &amp;lt; n and vis[l]: l += 1 while r &amp;lt; n and nums[r] - nums[l] &amp;lt; d: r += 1 if r == n or nums[r] - nums[l] &amp;gt; d: break vis[r] = True res.</description></item><item><title>2123. Minimum Operations to Remove Adjacent Ones in Matrix</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2123/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2123/</guid><description>LeetCode problem 2123
class Solution: def minimumOperations(self, grid: List[List[int]]) -&amp;gt; int: def find(i: int) -&amp;gt; int: for j in g[i]: if j not in vis: vis.add(j) if match[j] == -1 or find(match[j]): match[j] = i return 1 return 0 g = defaultdict(list) m, n = len(grid), len(grid[0]) for i, row in enumerate(grid): for j, v in enumerate(row): if (i + j) % 2 and v: x = i * n + j if i &amp;lt; m - 1 and grid[i + 1][j]: g[x].</description></item><item><title>2127. Maximum Employees to Be Invited to a Meeting</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2127/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2127/</guid><description>LeetCode problem 2127
class Solution: def maximumInvitations(self, favorite: List[int]) -&amp;gt; int: def max_cycle(fa: List[int]) -&amp;gt; int: n = len(fa) vis = [False] * n res = 0 for i in range(n): if vis[i]: continue cycle = [] j = i while not vis[j]: cycle.append(j) vis[j] = True j = fa[j] for k, v in enumerate(cycle): if v == j: res = max(res, len(cycle) - k) break return res def topological_sort(fa: List[int]) -&amp;gt; int: n = len(fa) indeg = [0] * n dist = [1] * n for v in fa: indeg[v] += 1 q = deque(i for i, v in enumerate(indeg) if v == 0) while q: i = q.</description></item><item><title>2132. Stamping the Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2132/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2132/</guid><description>LeetCode problem 2132
class Solution: def possibleToStamp( self, grid: List[List[int]], stampHeight: int, stampWidth: int ) -&amp;gt; bool: m, n = len(grid), len(grid[0]) s = [[0] * (n + 1) for _ in range(m + 1)] for i, row in enumerate(grid, 1): for j, v in enumerate(row, 1): s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + v d = [[0] * (n + 2) for _ in range(m + 2)] for i in range(1, m - stampHeight + 2): for j in range(1, n - stampWidth + 2): x, y = i + stampHeight - 1, j + stampWidth - 1 if s[x][y] - s[x][j - 1] - s[i - 1][y] + s[i - 1][j - 1] == 0: d[i][j] += 1 d[i][y + 1] -= 1 d[x + 1][j] -= 1 d[x + 1][y + 1] += 1 for i, row in enumerate(grid, 1): for j, v in enumerate(row, 1): d[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1] if v == 0 and d[i][j] == 0: return False return True</description></item><item><title>2136. Earliest Possible Day of Full Bloom</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2136/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2136/</guid><description>LeetCode problem 2136
class Solution: def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -&amp;gt; int: res = t = 0 for pt, gt in sorted(zip(plantTime, growTime), key=lambda x: -x[1]): t += pt res = max(res, t + gt) return res</description></item><item><title>2141. Maximum Running Time of N Computers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2141/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2141/</guid><description>LeetCode problem 2141
class Solution: def maxRunTime(self, n: int, batteries: List[int]) -&amp;gt; int: l, r = 0, sum(batteries) while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 if sum(min(x, mid) for x in batteries) &amp;gt;= n * mid: l = mid else: r = mid - 1 return l</description></item><item><title>2143. Choose Numbers From Two Arrays in Range</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2143/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2143/</guid><description>LeetCode problem 2143
class Solution: def countSubranges(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) s1, s2 = sum(nums1), sum(nums2) f = [[0] * (s1 + s2 + 1) for _ in range(n)] res = 0 mod = 10**9 + 7 for i, (a, b) in enumerate(zip(nums1, nums2)): f[i][a + s2] += 1 f[i][-b + s2] += 1 if i: for j in range(s1 + s2 + 1): if j &amp;gt;= a: f[i][j] = (f[i][j] + f[i - 1][j - a]) % mod if j + b &amp;lt; s1 + s2 + 1: f[i][j] = (f[i][j] + f[i - 1][j + b]) % mod res = (res + f[i][s2]) % mod return res</description></item><item><title>2147. Number of Ways to Divide a Long Corridor</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2147/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2147/</guid><description>LeetCode problem 2147
class Solution: def numberOfWays(self, corridor: str) -&amp;gt; int: @cache def dfs(i, cnt): if i == n: return int(cnt == 2) cnt += corridor[i] == &amp;#39;S&amp;#39; if cnt &amp;gt; 2: return 0 res = dfs(i + 1, cnt) if cnt == 2: res += dfs(i + 1, 0) res %= mod return res n = len(corridor) mod = 10**9 + 7 res = dfs(0, 0) dfs.cache_clear() return res</description></item><item><title>2151. Maximum Good People Based on Statements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2151/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2151/</guid><description>LeetCode problem 2151
class Solution: def maximumGood(self, statements: List[List[int]]) -&amp;gt; int: def check(mask): cnt = 0 for i, s in enumerate(statements): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: for j, v in enumerate(s): if v &amp;lt; 2 and ((mask &amp;gt;&amp;gt; j) &amp;amp; 1) != v: return 0 cnt += 1 return cnt return max(check(mask) for mask in range(1, 1 &amp;lt;&amp;lt; len(statements)))</description></item><item><title>2157. Groups of Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2157/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2157/</guid><description>LeetCode problem 2157
class Solution: def groupStrings(self, words: List[str]) -&amp;gt; List[int]: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def union(a, b): nonlocal mx, n if b not in p: return pa, pb = find(a), find(b) if pa == pb: return p[pa] = pb size[pb] += size[pa] mx = max(mx, size[pb]) n -= 1 p = {} size = Counter() n = len(words) mx = 0 for word in words: x = 0 for c in word: x |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) p[x] = x size[x] += 1 mx = max(mx, size[x]) if size[x] &amp;gt; 1: n -= 1 for x in p.</description></item><item><title>2158. Amount of New Area Painted Each Day</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2158/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2158/</guid><description>LeetCode problem 2158
class Node: def __init__(self, l, r): self.left = None self.right = None self.l = l self.r = r self.mid = (l + r) &amp;gt;&amp;gt; 1 self.v = 0 self.add = 0 class SegmentTree: def __init__(self): self.root = Node(1, 10**5 + 10) def modify(self, l, r, v, node=None): if l &amp;gt; r: return if node is None: node = self.root if node.l &amp;gt;= l and node.r &amp;lt;= r: node.v = node.r - node.l + 1 node.add = v return self.</description></item><item><title>2163. Minimum Difference in Sums After Removal of Elements</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2163/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2163/</guid><description>LeetCode problem 2163
class Solution: def minimumDifference(self, nums: List[int]) -&amp;gt; int: m = len(nums) n = m // 3 s = 0 pre = [0] * (m + 1) q1 = [] for i, x in enumerate(nums[: n * 2], 1): s += x heappush(q1, -x) if len(q1) &amp;gt; n: s -= -heappop(q1) pre[i] = s s = 0 suf = [0] * (m + 1) q2 = [] for i in range(m, n, -1): x = nums[i - 1] s += x heappush(q2, x) if len(q2) &amp;gt; n: s -= heappop(q2) suf[i] = s return min(pre[i] - suf[i + 1] for i in range(n, n * 2 + 1))</description></item><item><title>2167. Minimum Time to Remove All Cars Containing Illegal Goods</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2167/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2167/</guid><description>LeetCode problem 2167
class Solution: def minimumTime(self, s: str) -&amp;gt; int: n = len(s) pre = [0] * (n + 1) suf = [0] * (n + 1) for i, c in enumerate(s): pre[i + 1] = pre[i] if c == &amp;#39;0&amp;#39; else min(pre[i] + 2, i + 1) for i in range(n - 1, -1, -1): suf[i] = suf[i + 1] if s[i] == &amp;#39;0&amp;#39; else min(suf[i + 1] + 2, n - i) return min(a + b for a, b in zip(pre[1:], suf[1:]))</description></item><item><title>2172. Maximum AND Sum of Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2172/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2172/</guid><description>LeetCode problem 2172
class Solution: def maximumANDSum(self, nums: List[int], numSlots: int) -&amp;gt; int: n = len(nums) m = numSlots &amp;lt;&amp;lt; 1 f = [0] * (1 &amp;lt;&amp;lt; m) for i in range(1 &amp;lt;&amp;lt; m): cnt = i.bit_count() if cnt &amp;gt; n: continue for j in range(m): if i &amp;gt;&amp;gt; j &amp;amp; 1: f[i] = max(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + (nums[cnt - 1] &amp;amp; (j // 2 + 1))) return max(f)</description></item><item><title>2179. Count Good Triplets in an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2179/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2179/</guid><description>LeetCode problem 2179
class Node: def __init__(self): self.l = 0 self.r = 0 self.v = 0 class SegmentTree: def __init__(self, n): self.tr = [Node() for _ in range(4 * n)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l = l self.tr[u].r = r if l == r: return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) def modify(self, u, x, v): if self.tr[u].l == x and self.</description></item><item><title>2188. Minimum Time to Finish the Race</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2188/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2188/</guid><description>LeetCode problem 2188
class Solution: def minimumFinishTime( self, tires: List[List[int]], changeTime: int, numLaps: int ) -&amp;gt; int: cost = [inf] * 18 for f, r in tires: i, s, t = 1, 0, f while t &amp;lt;= changeTime + f: s += t cost[i] = min(cost[i], s) t *= r i += 1 f = [inf] * (numLaps + 1) f[0] = -changeTime for i in range(1, numLaps + 1): for j in range(1, min(18, i + 1)): f[i] = min(f[i], f[i - j] + cost[j]) f[i] += changeTime return f[numLaps]</description></item><item><title>2193. Minimum Number of Moves to Make Palindrome</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2193/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2193/</guid><description>LeetCode problem 2193
class Solution: def minMovesToMakePalindrome(self, s: str) -&amp;gt; int: cs = list(s) res, n = 0, len(s) i, j = 0, n - 1 while i &amp;lt; j: even = False for k in range(j, i, -1): if cs[i] == cs[k]: even = True while k &amp;lt; j: cs[k], cs[k + 1] = cs[k + 1], cs[k] k += 1 res += 1 j -= 1 break if not even: res += n // 2 - i i += 1 return res</description></item><item><title>2203. Minimum Weighted Subgraph With the Required Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2203/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2203/</guid><description>LeetCode problem 2203
class Solution: def minimumWeight( self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int ) -&amp;gt; int: def dijkstra(g, u): dist = [inf] * n dist[u] = 0 q = [(0, u)] while q: d, u = heappop(q) if d &amp;gt; dist[u]: continue for v, w in g[u]: if dist[v] &amp;gt; dist[u] + w: dist[v] = dist[u] + w heappush(q, (dist[v], v)) return dist g = defaultdict(list) rg = defaultdict(list) for f, t, w in edges: g[f].</description></item><item><title>2204. Distance to a Cycle in Undirected Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2204/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2204/</guid><description>LeetCode problem 2204
class Solution: def distanceToCycle(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: g = defaultdict(set) for a, b in edges: g[a].add(b) g[b].add(a) q = deque(i for i in range(n) if len(g[i]) == 1) f = [0] * n seq = [] while q: i = q.popleft() seq.append(i) for j in g[i]: g[j].remove(i) f[i] = j if len(g[j]) == 1: q.append(j) g[i].clear() res = [0] * n for i in seq[::-1]: res[i] = res[f[i]] + 1 return res</description></item><item><title>2209. Minimum White Tiles After Covering With Carpets</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2209/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2209/</guid><description>LeetCode problem 2209
class Solution: def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -&amp;gt; int: @cache def dfs(i, j): if i &amp;gt;= n: return 0 if floor[i] == &amp;#39;0&amp;#39;: return dfs(i + 1, j) if j == 0: return s[-1] - s[i] return min(1 + dfs(i + 1, j), dfs(i + carpetLen, j - 1)) n = len(floor) s = [0] * (n + 1) for i, c in enumerate(floor): s[i + 1] = s[i] + int(c == &amp;#39;1&amp;#39;) res = dfs(0, numCarpets) dfs.</description></item><item><title>2213. Longest Substring of One Repeating Character</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2213/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2213/</guid><description>LeetCode problem 2213
class Node: def __init__(self): self.l = 0 self.r = 0 self.lmx = 0 self.rmx = 0 self.mx = 0 self.size = 0 self.lc = None self.rc = None N = 100010 tr = [Node() for _ in range(N &amp;lt;&amp;lt; 2)] class SegmentTree: def __init__(self, s): n = len(s) self.s = s self.build(1, 1, n) def build(self, u, l, r): tr[u].l = l tr[u].r = r if l == r: tr[u].lmx = tr[u].rmx = tr[u].mx = tr[u].</description></item><item><title>2218. Maximum Value of K Coins From Piles</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2218/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2218/</guid><description>LeetCode problem 2218
class Solution: def maxValueOfCoins(self, piles: List[List[int]], k: int) -&amp;gt; int: presum = [list(accumulate(p, initial=0)) for p in piles] dp = [0] * (k + 1) for s in presum: for j in range(k, -1, -1): for idx, v in enumerate(s): if j &amp;gt;= idx: dp[j] = max(dp[j], dp[j - idx] + v) return dp[-1]</description></item><item><title>2227. Encrypt and Decrypt Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2227/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2227/</guid><description>LeetCode problem 2227
class Encrypter: def __init__(self, keys: List[str], values: List[str], dictionary: List[str]): self.mp = dict(zip(keys, values)) self.cnt = Counter(self.encrypt(v) for v in dictionary) def encrypt(self, word1: str) -&amp;gt; str: res = [] for c in word1: if c not in self.mp: return &amp;#39;&amp;#39; res.append(self.mp[c]) return &amp;#39;&amp;#39;.join(res) def decrypt(self, word2: str) -&amp;gt; int: return self.cnt[word2] # Your Encrypter object will be instantiated and called as such: # obj = Encrypter(keys, values, dictionary) # param_1 = obj.encrypt(word1) # param_2 = obj.</description></item><item><title>2234. Maximum Total Beauty of the Gardens</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2234/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2234/</guid><description>LeetCode problem 2234
class Solution: def maximumBeauty( self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int ) -&amp;gt; int: flowers.sort() n = len(flowers) s = list(accumulate(flowers, initial=0)) res, i = 0, n - bisect_left(flowers, target) for x in range(i, n + 1): newFlowers -= 0 if x == 0 else max(target - flowers[n - x], 0) if newFlowers &amp;lt; 0: break l, r = 0, n - x - 1 while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 if flowers[mid] * (mid + 1) - s[mid + 1] &amp;lt;= newFlowers: l = mid else: r = mid - 1 y = 0 if r !</description></item><item><title>2242. Maximum Score of a Node Sequence</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2242/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2242/</guid><description>LeetCode problem 2242
class Solution: def maximumScore(self, scores: List[int], edges: List[List[int]]) -&amp;gt; int: g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) for k in g.keys(): g[k] = nlargest(3, g[k], key=lambda x: scores[x]) res = -1 for a, b in edges: for c in g[a]: for d in g[b]: if b != c != d != a: t = scores[a] + scores[b] + scores[c] + scores[d] res = max(res, t) return res</description></item><item><title>2246. Longest Path With Different Adjacent Characters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2246/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2246/</guid><description>LeetCode problem 2246
class Solution: def longestPath(self, parent: List[int], s: str) -&amp;gt; int: def dfs(i: int) -&amp;gt; int: mx = 0 nonlocal res for j in g[i]: x = dfs(j) + 1 if s[i] != s[j]: res = max(res, mx + x) mx = max(mx, x) return mx g = defaultdict(list) for i in range(1, len(parent)): g[parent[i]].append(i) res = 0 dfs(0) return res + 1</description></item><item><title>2247. Maximum Cost of Trip With K Highways</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2247/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2247/</guid><description>LeetCode problem 2247
class Solution: def maximumCost(self, n: int, highways: List[List[int]], k: int) -&amp;gt; int: if k &amp;gt;= n: return -1 g = defaultdict(list) for a, b, cost in highways: g[a].append((b, cost)) g[b].append((a, cost)) f = [[-inf] * n for _ in range(1 &amp;lt;&amp;lt; n)] for i in range(n): f[1 &amp;lt;&amp;lt; i][i] = 0 res = -1 for i in range(1 &amp;lt;&amp;lt; n): for j in range(n): if i &amp;gt;&amp;gt; j &amp;amp; 1: for h, cost in g[j]: if i &amp;gt;&amp;gt; h &amp;amp; 1: f[i][j] = max(f[i][j], f[i ^ (1 &amp;lt;&amp;lt; j)][h] + cost) if i.</description></item><item><title>2251. Number of Flowers in Full Bloom</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2251/</guid><description>LeetCode Problem 2251
Problem Statement In the given problem, we are presented with two arrays. The first, flowers, represents when each flower starts and stops being in full bloom. The second, people, indicates when each person arrives to see the flowers. Our task is to determine, for each person, how many flowers they will see in full bloom upon their arrival.
Naive Solution A straightforward approach might involve iterating over each person&amp;rsquo;s arrival time. For each time, we could iterate over the flowers list to count how many flowers are in full bloom.</description></item><item><title>2258. Escape the Spreading Fire</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2258/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2258/</guid><description>LeetCode problem 2258
class Solution: def maximumMinutes(self, grid: List[List[int]]) -&amp;gt; int: def spread(q: Deque[int]) -&amp;gt; Deque[int]: nq = deque() while q: i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and not fire[x][y] and grid[x][y] == 0: fire[x][y] = True nq.append((x, y)) return nq def check(t: int) -&amp;gt; bool: for i in range(m): for j in range(n): fire[i][j] = False q1 = deque() for i, row in enumerate(grid): for j, x in enumerate(row): if x == 1: fire[i][j] = True q1.</description></item><item><title>2262. Total Appeal of A String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2262/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2262/</guid><description>LeetCode problem 2262
class Solution: def appealSum(self, s: str) -&amp;gt; int: res = t = 0 pos = [-1] * 26 for i, c in enumerate(s): c = ord(c) - ord(&amp;#39;a&amp;#39;) t += i - pos[c] res += t pos[c] = i return res</description></item><item><title>2263. Make Array Non-decreasing or Non-increasing</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2263/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2263/</guid><description>LeetCode problem 2263
class Solution: def convertArray(self, nums: List[int]) -&amp;gt; int: def solve(nums): n = len(nums) f = [[0] * 1001 for _ in range(n + 1)] for i, x in enumerate(nums, 1): mi = inf for j in range(1001): if mi &amp;gt; f[i - 1][j]: mi = f[i - 1][j] f[i][j] = mi + abs(x - j) return min(f[n]) return min(solve(nums), solve(nums[::-1]))</description></item><item><title>2267. Check if There Is a Valid Parentheses String Path</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2267/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2267/</guid><description>LeetCode problem 2267
class Solution: def hasValidPath(self, grid: List[List[str]]) -&amp;gt; bool: @cache def dfs(i, j, t): if grid[i][j] == &amp;#39;(&amp;#39;: t += 1 else: t -= 1 if t &amp;lt; 0: return False if i == m - 1 and j == n - 1: return t == 0 for x, y in [(i + 1, j), (i, j + 1)]: if x &amp;lt; m and y &amp;lt; n and dfs(x, y, t): return True return False m, n = len(grid), len(grid[0]) return dfs(0, 0, 0)</description></item><item><title>2272. Substring With Largest Variance</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2272/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2272/</guid><description>LeetCode problem 2272
class Solution: def largestVariance(self, s: str) -&amp;gt; int: res = 0 for a, b in permutations(ascii_lowercase, 2): if a == b: continue f = [0, -inf] for c in s: if c == a: f[0], f[1] = f[0] + 1, f[1] + 1 elif c == b: f[1] = max(f[1] - 1, f[0] - 1) f[0] = 0 if res &amp;lt; f[1]: res = f[1] return res</description></item><item><title>2276. Count Integers in Intervals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2276/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2276/</guid><description>LeetCode problem 2276
class Node: __slots__ = (&amp;#34;left&amp;#34;, &amp;#34;right&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;r&amp;#34;, &amp;#34;mid&amp;#34;, &amp;#34;v&amp;#34;, &amp;#34;add&amp;#34;) def __init__(self, l, r): self.left = None self.right = None self.l = l self.r = r self.mid = (l + r) // 2 self.v = 0 self.add = 0 class SegmentTree: def __init__(self): self.root = Node(1, int(1e9) + 1) def modify(self, l, r, v, node=None): if node is None: node = self.root if l &amp;gt; r: return if node.l &amp;gt;= l and node.r &amp;lt;= r: node.</description></item><item><title>2281. Sum of Total Strength of Wizards</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2281/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2281/</guid><description>LeetCode problem 2281
class Solution: def totalStrength(self, strength: List[int]) -&amp;gt; int: n = len(strength) left = [-1] * n right = [n] * n stk = [] for i, v in enumerate(strength): while stk and strength[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and strength[stk[-1]] &amp;gt; strength[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) ss = list(accumulate(list(accumulate(strength, initial=0)), initial=0)) mod = int(1e9) + 7 res = 0 for i, v in enumerate(strength): l, r = left[i] + 1, right[i] - 1 a = (ss[r + 2] - ss[i + 1]) * (i - l + 1) b = (ss[i + 1] - ss[l]) * (r - i + 1) res = (res + (a - b) * v) % mod return res</description></item><item><title>2286. Booking Concert Tickets in Groups</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2286/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2286/</guid><description>LeetCode problem 2286
class Node: def __init__(self): self.l = self.r = 0 self.s = self.mx = 0 class SegmentTree: def __init__(self, n, m): self.m = m self.tr = [Node() for _ in range(n &amp;lt;&amp;lt; 2)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l, self.tr[u].r = l, r if l == r: self.tr[u].s = self.tr[u].mx = self.m return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) self.</description></item><item><title>2290. Minimum Obstacle Removal to Reach Corner</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2290/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2290/</guid><description>LeetCode problem 2290
class Solution: def minimumObstacles(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) q = deque([(0, 0, 0)]) vis = set() dirs = (-1, 0, 1, 0, -1) while 1: i, j, k = q.popleft() if i == m - 1 and j == n - 1: return k if (i, j) in vis: continue vis.add((i, j)) for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n: if grid[x][y] == 0: q.</description></item><item><title>2296. Design a Text Editor</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2296/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2296/</guid><description>LeetCode problem 2296
class TextEditor: def __init__(self): self.left = [] self.right = [] def addText(self, text: str) -&amp;gt; None: self.left.extend(list(text)) def deleteText(self, k: int) -&amp;gt; int: k = min(k, len(self.left)) for _ in range(k): self.left.pop() return k def cursorLeft(self, k: int) -&amp;gt; str: k = min(k, len(self.left)) for _ in range(k): self.right.append(self.left.pop()) return &amp;#39;&amp;#39;.join(self.left[-10:]) def cursorRight(self, k: int) -&amp;gt; str: k = min(k, len(self.right)) for _ in range(k): self.left.append(self.right.pop()) return &amp;#39;&amp;#39;.join(self.left[-10:]) # Your TextEditor object will be instantiated and called as such: # obj = TextEditor() # obj.</description></item><item><title>2301. Match Substring After Replacement</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2301/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2301/</guid><description>LeetCode problem 2301
class Solution: def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -&amp;gt; bool: d = [[False] * 128 for _ in range(128)] for a, b in mappings: d[ord(a)][ord(b)] = True for i in range(len(s) - len(sub) + 1): if all( a == b or d[ord(b)][ord(a)] for a, b in zip(s[i : i + len(sub)], sub) ): return True return False</description></item><item><title>2302. Count Subarrays With Score Less Than K</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2302/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2302/</guid><description>LeetCode problem 2302
class Solution: def countSubarrays(self, nums: List[int], k: int) -&amp;gt; int: res = s = j = 0 for i, v in enumerate(nums): s += v while s * (i - j + 1) &amp;gt;= k: s -= nums[j] j += 1 res += i - j + 1 return res</description></item><item><title>2306. Naming a Company</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2306/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2306/</guid><description>LeetCode problem 2306
class Solution: def distinctNames(self, ideas: List[str]) -&amp;gt; int: s = set(ideas) f = [[0] * 26 for _ in range(26)] for v in ideas: i = ord(v[0]) - ord(&amp;#39;a&amp;#39;) t = list(v) for j in range(26): t[0] = chr(ord(&amp;#39;a&amp;#39;) + j) if &amp;#39;&amp;#39;.join(t) not in s: f[i][j] += 1 res = 0 for v in ideas: i = ord(v[0]) - ord(&amp;#39;a&amp;#39;) t = list(v) for j in range(26): t[0] = chr(ord(&amp;#39;a&amp;#39;) + j) if &amp;#39;&amp;#39;.join(t) not in s: res += f[j][i] return res</description></item><item><title>2307. Check for Contradictions in Equations</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2307/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2307/</guid><description>LeetCode problem 2307
class Solution: def checkContradictions( self, equations: List[List[str]], values: List[float] ) -&amp;gt; bool: def find(x: int) -&amp;gt; int: if p[x] != x: root = find(p[x]) w[x] *= w[p[x]] p[x] = root return p[x] d = defaultdict(int) n = 0 for e in equations: for s in e: if s not in d: d[s] = n n += 1 p = list(range(n)) w = [1.0] * n eps = 1e-5 for (a, b), v in zip(equations, values): a, b = d[a], d[b] pa, pb = find(a), find(b) if pa !</description></item><item><title>2312. Selling Pieces of Wood</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2312/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2312/</guid><description>LeetCode problem 2312
class Solution: def sellingWood(self, m: int, n: int, prices: List[List[int]]) -&amp;gt; int: d = defaultdict(dict) for h, w, p in prices: d[h][w] = p dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): dp[i][j] = d[i].get(j, 0) for k in range(1, i): dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]) for k in range(1, j): dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]) return dp[-1][-1]</description></item><item><title>2313. Minimum Flips in Binary Tree to Get Result</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2313/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2313/</guid><description>LeetCode problem 2313
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minimumFlips(self, root: Optional[TreeNode], result: bool) -&amp;gt; int: def dfs(root: Optional[TreeNode]) -&amp;gt; (int, int): if root is None: return inf, inf x = root.val if x in (0, 1): return x, x ^ 1 l, r = dfs(root.left), dfs(root.right) if x == 2: return l[0] + r[0], min(l[0] + r[1], l[1] + r[0], l[1] + r[1]) if x == 3: return min(l[0] + r[0], l[0] + r[1], l[1] + r[0]), l[1] + r[1] if x == 4: return min(l[0] + r[0], l[1] + r[1]), min(l[0] + r[1], l[1] + r[0]) return min(l[1], r[1]), min(l[0], r[0]) return dfs(root)[int(result)]</description></item><item><title>2318. Number of Distinct Roll Sequences</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2318/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2318/</guid><description>LeetCode problem 2318
class Solution: def distinctSequences(self, n: int) -&amp;gt; int: if n == 1: return 6 mod = 10**9 + 7 dp = [[[0] * 6 for _ in range(6)] for _ in range(n + 1)] for i in range(6): for j in range(6): if gcd(i + 1, j + 1) == 1 and i != j: dp[2][i][j] = 1 for k in range(3, n + 1): for i in range(6): for j in range(6): if gcd(i + 1, j + 1) == 1 and i !</description></item><item><title>2321. Maximum Score Of Spliced Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2321/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2321/</guid><description>LeetCode problem 2321
class Solution: def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: def f(nums1, nums2): d = [a - b for a, b in zip(nums1, nums2)] t = mx = d[0] for v in d[1:]: if t &amp;gt; 0: t += v else: t = v mx = max(mx, t) return mx s1, s2 = sum(nums1), sum(nums2) return max(s2 + f(nums1, nums2), s1 + f(nums2, nums1))</description></item><item><title>2322. Minimum Score After Removals on a Tree</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2322/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2322/</guid><description>LeetCode problem 2322
class Solution: def minimumScore(self, nums: List[int], edges: List[List[int]]) -&amp;gt; int: def dfs(i, fa, x): res = nums[i] for j in g[i]: if j != fa and j != x: res ^= dfs(j, i, x) return res def dfs2(i, fa, x): nonlocal s, s1, res res = nums[i] for j in g[i]: if j != fa and j != x: a = dfs2(j, i, x) res ^= a b = s1 ^ a c = s ^ s1 t = max(a, b, c) - min(a, b, c) res = min(res, t) return res g = defaultdict(list) for a, b in edges: g[a].</description></item><item><title>2328. Number of Increasing Paths in a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2328/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2328/</guid><description>LeetCode problem 2328
class Solution: def countPaths(self, grid: List[List[int]]) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: res = 1 for a, b in pairwise((-1, 0, 1, 0, -1)): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and grid[i][j] &amp;lt; grid[x][y]: res = (res + dfs(x, y)) % mod return res mod = 10**9 + 7 m, n = len(grid), len(grid[0]) return sum(dfs(i, j) for i in range(m) for j in range(n)) % mod</description></item><item><title>2334. Subarray With Elements Greater Than Varying Threshold</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2334/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2334/</guid><description>LeetCode problem 2334
class Solution: def validSubarraySize(self, nums: List[int], threshold: int) -&amp;gt; int: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt;= nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) for i, v in enumerate(nums): k = right[i] - left[i] - 1 if v &amp;gt; threshold // k: return k return -1</description></item><item><title>2338. Count the Number of Ideal Arrays</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2338/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2338/</guid><description>LeetCode problem 2338
class Solution: def idealArrays(self, n: int, maxValue: int) -&amp;gt; int: c = [[0] * 16 for _ in range(n)] mod = 10**9 + 7 for i in range(n): for j in range(min(16, i + 1)): c[i][j] = 1 if j == 0 else (c[i - 1][j] + c[i - 1][j - 1]) % mod dp = [[0] * 16 for _ in range(maxValue + 1)] for i in range(1, maxValue + 1): dp[i][1] = 1 for j in range(1, 15): for i in range(1, maxValue + 1): k = 2 while k * i &amp;lt;= maxValue: dp[k * i][j + 1] = (dp[k * i][j + 1] + dp[i][j]) % mod k += 1 res = 0 for i in range(1, maxValue + 1): for j in range(1, 16): res = (res + dp[i][j] * c[-1][j - 1]) % mod return res</description></item><item><title>2344. Minimum Deletions to Make Array Divisible</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2344/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2344/</guid><description>LeetCode problem 2344
class Solution: def minOperations(self, nums: List[int], numsDivide: List[int]) -&amp;gt; int: x = gcd(*numsDivide) y = min((v for v in nums if x % v == 0), default=0) return sum(v &amp;lt; y for v in nums) if y else -1</description></item><item><title>2350. Shortest Impossible Sequence of Rolls</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2350/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2350/</guid><description>LeetCode problem 2350
class Solution: def shortestSequence(self, rolls: List[int], k: int) -&amp;gt; int: res = 1 s = set() for v in rolls: s.add(v) if len(s) == k: res += 1 s.clear() return res</description></item><item><title>2354. Number of Excellent Pairs</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2354/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2354/</guid><description>LeetCode problem 2354
class Solution: def countExcellentPairs(self, nums: List[int], k: int) -&amp;gt; int: s = set(nums) res = 0 cnt = Counter() for v in s: cnt[v.bit_count()] += 1 for v in s: t = v.bit_count() for i, x in cnt.items(): if t + i &amp;gt;= k: res += x return res</description></item><item><title>2355. Maximum Number of Books You Can Take</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2355/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2355/</guid><description>LeetCode problem 2355
class Solution: def maximumBooks(self, books: List[int]) -&amp;gt; int: nums = [v - i for i, v in enumerate(books)] n = len(nums) left = [-1] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) res = 0 dp = [0] * n dp[0] = books[0] for i, v in enumerate(books): j = left[i] cnt = min(v, i - j) u = v - cnt + 1 s = (u + v) * cnt // 2 dp[i] = s + (0 if j == -1 else dp[j]) res = max(res, dp[i]) return res</description></item><item><title>2360. Longest Cycle in a Graph</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2360/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2360/</guid><description>LeetCode problem 2360
class Solution: def longestCycle(self, edges: List[int]) -&amp;gt; int: n = len(edges) vis = [False] * n res = -1 for i in range(n): if vis[i]: continue j = i cycle = [] while j != -1 and not vis[j]: vis[j] = True cycle.append(j) j = edges[j] if j == -1: continue m = len(cycle) k = next((k for k in range(m) if cycle[k] == j), inf) res = max(res, m - k) return res</description></item><item><title>2361. Minimum Costs Using the Train Line</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2361/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2361/</guid><description>LeetCode problem 2361
class Solution: def minimumCosts( self, regular: List[int], express: List[int], expressCost: int ) -&amp;gt; List[int]: n = len(regular) f, g = 0, inf cost = [0] * n for i, (a, b) in enumerate(zip(regular, express), 1): ff = min(f + a, g + a) gg = min(f + expressCost + b, g + b) f, g = ff, gg cost[i - 1] = min(f, g) return cost</description></item><item><title>2366. Minimum Replacements to Sort the Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2366/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2366/</guid><description>LeetCode problem 2366
class Solution: def minimumReplacement(self, nums: List[int]) -&amp;gt; int: res = 0 n = len(nums) mx = nums[-1] for i in range(n - 2, -1, -1): if nums[i] &amp;lt;= mx: mx = nums[i] continue k = (nums[i] + mx - 1) // mx res += k - 1 mx = nums[i] // k return res</description></item><item><title>2371. Minimize Maximum Value in a Grid</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2371/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2371/</guid><description>LeetCode problem 2371
class Solution: def minScore(self, grid: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(grid), len(grid[0]) nums = [(v, i, j) for i, row in enumerate(grid) for j, v in enumerate(row)] nums.sort() row_max = [0] * m col_max = [0] * n res = [[0] * n for _ in range(m)] for _, i, j in nums: res[i][j] = max(row_max[i], col_max[j]) + 1 row_max[i] = col_max[j] = res[i][j] return res</description></item><item><title>2376. Count Special Integers</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2376/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2376/</guid><description>LeetCode problem 2376
class Solution: def countSpecialNumbers(self, n: int) -&amp;gt; int: return self.f(n) def f(self, n): @cache def dfs(pos, mask, lead, limit): if pos &amp;lt;= 0: return lead ^ 1 up = a[pos] if limit else 9 res = 0 for i in range(up + 1): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: continue if i == 0 and lead: res += dfs(pos - 1, mask, lead, limit and i == up) else: res += dfs(pos - 1, mask | 1 &amp;lt;&amp;lt; i, False, limit and i == up) return res a = [0] * 11 l = 0 while n: l += 1 a[l] = n % 10 n //= 10 return dfs(l, 0, True, True)</description></item><item><title>2382. Maximum Segment Sum After Removals</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2382/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2382/</guid><description>LeetCode problem 2382
class Solution: def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -&amp;gt; List[int]: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def merge(a, b): pa, pb = find(a), find(b) p[pa] = pb s[pb] += s[pa] n = len(nums) p = list(range(n)) s = [0] * n res = [0] * n mx = 0 for j in range(n - 1, 0, -1): i = removeQueries[j] s[i] = nums[i] if i and s[find(i - 1)]: merge(i, i - 1) if i &amp;lt; n - 1 and s[find(i + 1)]: merge(i, i + 1) mx = max(mx, s[find(i)]) res[j - 1] = mx return res</description></item><item><title>2386. Find the K-Sum of an Array</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2386/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2386/</guid><description>LeetCode problem 2386
class Solution: def kSum(self, nums: List[int], k: int) -&amp;gt; int: mx = 0 for i, v in enumerate(nums): if v &amp;gt; 0: mx += v else: nums[i] = -v nums.sort() h = [(0, 0)] for _ in range(k - 1): s, i = heappop(h) if i &amp;lt; len(nums): heappush(h, (s + nums[i], i + 1)) if i: heappush(h, (s + nums[i] - nums[i - 1], i + 1)) return mx - h[0][0]</description></item><item><title>2392. Build a Matrix With Conditions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2392/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2392/</guid><description>LeetCode problem 2392
class Solution: def buildMatrix( self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]] ) -&amp;gt; List[List[int]]: def f(cond): g = defaultdict(list) indeg = [0] * (k + 1) for a, b in cond: g[a].append(b) indeg[b] += 1 q = deque([i for i, v in enumerate(indeg[1:], 1) if v == 0]) res = [] while q: for _ in range(len(q)): i = q.popleft() res.append(i) for j in g[i]: indeg[j] -= 1 if indeg[j] == 0: q.append(j) return None if len(res) !</description></item><item><title>2398. Maximum Number of Robots Within Budget</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2398/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2398/</guid><description>LeetCode problem 2398
class Solution: def maximumRobots( self, chargeTimes: List[int], runningCosts: List[int], budget: int ) -&amp;gt; int: q = deque() res = j = s = 0 for i, (a, b) in enumerate(zip(chargeTimes, runningCosts)): while q and chargeTimes[q[-1]] &amp;lt;= a: q.pop() q.append(i) s += b while q and chargeTimes[q[0]] + (i - j + 1) * s &amp;gt; budget: if q[0] == j: q.popleft() s -= runningCosts[j] j += 1 res = max(res, i - j + 1) return res</description></item><item><title>2403. Minimum Time to Kill All Monsters</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2403/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2403/</guid><description>LeetCode problem 2403
class Solution: def minimumTime(self, power: List[int]) -&amp;gt; int: n = len(power) dp = [inf] * (1 &amp;lt;&amp;lt; n) dp[0] = 0 for mask in range(1, 1 &amp;lt;&amp;lt; n): cnt = mask.bit_count() for i, v in enumerate(power): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: dp[mask] = min(dp[mask], dp[mask ^ (1 &amp;lt;&amp;lt; i)] + (v + cnt - 1) // cnt) return dp[-1]</description></item><item><title>2407. Longest Increasing Subsequence II</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2407/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2407/</guid><description>LeetCode problem 2407
class Node: def __init__(self): self.l = 0 self.r = 0 self.v = 0 class SegmentTree: def __init__(self, n): self.tr = [Node() for _ in range(4 * n)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l = l self.tr[u].r = r if l == r: return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) def modify(self, u, x, v): if self.tr[u].l == x and self.</description></item><item><title>2412. Minimum Money Required Before Transactions</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2412/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2412/</guid><description>LeetCode problem 2412
class Solution: def minimumMoney(self, transactions: List[List[int]]) -&amp;gt; int: s = sum(max(0, a - b) for a, b in transactions) res = 0 for a, b in transactions: if a &amp;gt; b: res = max(res, s + b) else: res = max(res, s + a) return res</description></item><item><title>2416. Sum of Prefix Scores of Strings</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2416/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2416/</guid><description>LeetCode problem 2416
class Trie: def __init__(self): self.children = [None] * 26 self.cnt = 0 def insert(self, w): node = self for c in w: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: node.children[idx] = Trie() node = node.children[idx] node.cnt += 1 def search(self, w): node = self res = 0 for c in w: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: return res node = node.children[idx] res += node.cnt return res class Solution: def sumPrefixScores(self, words: List[str]) -&amp;gt; List[int]: trie = Trie() for w in words: trie.</description></item><item><title>2421. Number of Good Paths</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2421/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2421/</guid><description>LeetCode problem 2421
class Solution: def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -&amp;gt; int: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) n = len(vals) p = list(range(n)) size = defaultdict(Counter) for i, v in enumerate(vals): size[i][v] = 1 res = n for v, a in sorted(zip(vals, range(n))): for b in g[a]: if vals[b] &amp;gt; v: continue pa, pb = find(a), find(b) if pa != pb: res += size[pa][v] * size[pb][v] p[pa] = pb size[pb][v] += size[pa][v] return res</description></item><item><title>2426. Number of Pairs Satisfying Inequality</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2426/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2426/</guid><description>LeetCode problem 2426
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) @staticmethod def lowbit(x): return x &amp;amp; -x def update(self, x, delta): while x &amp;lt;= self.n: self.c[x] += delta x += BinaryIndexedTree.lowbit(x) def query(self, x): s = 0 while x: s += self.c[x] x -= BinaryIndexedTree.lowbit(x) return s class Solution: def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -&amp;gt; int: tree = BinaryIndexedTree(10**5) res = 0 for a, b in zip(nums1, nums2): v = a - b res += tree.</description></item><item><title>2430. Maximum Deletions on a String</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2430/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2430/</guid><description>LeetCode problem 2430
class Solution: def deleteString(self, s: str) -&amp;gt; int: n = len(s) g = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n - 1, -1, -1): for j in range(i + 1, n): if s[i] == s[j]: g[i][j] = g[i + 1][j + 1] + 1 f = [1] * n for i in range(n - 1, -1, -1): for j in range(1, (n - i) // 2 + 1): if g[i][i + j] &amp;gt;= j: f[i] = max(f[i], f[i + j] + 1) return f[0]</description></item><item><title>2709. Greatest Common Divisor Traversal</title><link>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2709/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/en/tracks/algorithms-101/leetcode/hard/2709/</guid><description>LeetCode problem 2709
from collections import defaultdict from typing import List class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.clusterSize = [1] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1, root2 = self.find(node1), self.find(node2) if root1 == root2: return False # No union made since they are already in the same set if self.clusterSize[root1] &amp;gt; self.clusterSize[root2]: self.parent[root2] = root1 self.clusterSize[root1] += self.clusterSize[root2] else: self.parent[root1] = root2 self.clusterSize[root2] += self.</description></item></channel></rss>