<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Roman Kurnovskii</title><link>https://romankurnovskii.com/ru/categories/leetcode/</link><description>Recent content in LeetCode on Roman Kurnovskii</description><generator>Hugo -- gohugo.io</generator><language>ru</language><copyright>&amp;copy; 2023 Personal page</copyright><lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://romankurnovskii.com/ru/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Легкие</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/</guid><description/></item><item><title>Средние</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/</guid><description/></item><item><title>Тяжелые</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/</guid><description/></item><item><title>4. Median of Two Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/4/</guid><description>LeetCode задача 4
Задача Даны два отсортированных массива nums1 и nums2 размера m и n соответственно. Найти медиану двух отсортированных массивов.
Подсказки Чтобы найти медиану, нужно сначала объединить два массива и отсортировать их. После этого медиана будет либо средним элементом, если общее количество элементов нечетное, либо средним значением двух центральных элементов, если общее количество элементов четное.
Подход Мы можем объединить два массива в один большой отсортированный массив и найти медиану этого массива. Этот подход не самый эффективный, но он прост и понятен.</description></item><item><title>LeetCode</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/</guid><description> Получай решения LeetCode на email: Подписаться</description></item><item><title>42. Trapping Rain Water</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/42/</guid><description>LeetCode задача 42
Задача Дан массив неотрицательных целых чисел, представляющих собой карту высот, где ширина каждой стойки равна 1. Вычислите, сколько воды может удерживать этот массив после дождя.
Подсказки Мы можем решить эту задачу, двигаясь от краев массива к его центру, отслеживая текущую максимальную высоту с обеих сторон.
Подход Простой и понятный способ решения этой задачи - пройтись по массиву и для каждого элемента вычислить, сколько воды он может удержать.
Алгоритм Инициализируем переменную для хранения общего объема воды, который может быть удержан.</description></item><item><title>92. Reverse Linked List II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/92/</guid><description>LeetCode задача 92
Задача Дан односвязный список и два целых числа left и right, где left &amp;lt;= right. Задача заключается в том, чтобы перевернуть узлы списка с позиции left до right
Т.е. если список 1-2-3-4-5-6-7-8-9, left=2, right=7, то итоговый список будет 1-7-6-5-4-3-2-8-9.
Подсказки Для решения задачи удобно использовать два указателя: один для сохранения начальной позиции участка, который нужно перевернуть, и второй для выполнения самого разворота.
Подход Основная идея решения заключается в использовании двух указателей: одного для начала подсписка, который нужно перевернуть, и второго для его конца.</description></item><item><title>118. Pascal's Triangle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</link><pubDate>Fri, 08 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/118/</guid><description>LeetCode задача 118
Задача Дано целое число numRows. Верните первые numRows строк Треугольника Паскаля.
В Треугольнике Паскаля каждое число является суммой двух чисел, находящихся непосредственно над ним.
Подсказки Для построения каждой следующей строки можно использовать последнюю строку в текущей итерации. Например, если есть строка [1, 2, 1], то следующая строка начнется и закончится с 1, а числа внутри будут получены путем сложения пар чисел: 1+2 и 2+1.
Подход Для того чтобы построить Треугольник Паскаля, начнем с первой строки, состоящей только из числа 1.</description></item><item><title>136. Single Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/136/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/136/</guid><description>LeetCode problem 136
class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: d = {} for i in nums: if i in d: del d[i] else: d[i]=1 return d.popitem()[0] Consider using a bit manipulation technique, specifically XOR, to solve this problem efficiently.
The concept of XOR (exclusive OR) operation can be used cleverly here. XOR of a number with itself is 0, and the XOR of a number with 0 is the number itself. Also, XOR operation is commutative and associative, which means the order of operations does not change the result.</description></item><item><title>138. Copy List with Random Pointer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/138/</guid><description>LeetCode задача 138
Задача Дан односвязный список, каждый узел которого содержит дополнительный &amp;ldquo;произвольный&amp;rdquo; указатель, который может указывать на любой узел в списке или быть null. Задача состоит в том, чтобы создать глубокую копию этого списка.
Подсказки Простое копирование значений не сработает. Нам нужно создать новые узлы и корректно установить как основные, так и &amp;ldquo;произвольные&amp;rdquo; указатели.
Подход / Идея решения Идея решения заключается в двухпроходном методе. В первом проходе мы создаем копии всех узлов исходного списка и сохраняем их в словаре, где ключом будет оригинальный узел, а значением — его копия.</description></item><item><title>210. Course Schedule II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/210/</guid><description>LeetCode задача 210
Задача Вам дано ( n ) курсов для изучения, пронумерованных от ( 0 ) до ( n-1 ), и массив ( prerequisites ), где ( prerequisites[i] = [a, b] ) означает, что для изучения курса ( a ) предварительно необходимо пройти курс ( b ).
Напишите функцию для нахождения порядка, в котором можно пройти курсы. Если это невозможно, верните пустой массив.
Подсказки Топологическая сортировка может быть использована для решения этой задачи.
Подход Создадим граф, представляющий предварительные требования для каждого курса.</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/215/</guid><description>LeetCode задача 215
Задача Найти k-тый по величине элемент в неотсортированном массиве. Примечание: это k-тый по величине элемент в отсортированном порядке, а не k-тый различный элемент.
Подсказки Можно отсортировать массив и просто взять k-тый элемент с конца. Для более эффективного решения можно использовать алгоритм быстрой выборки. Подход В самом простом случае мы можем отсортировать массив и взять k-тый элемент с конца.
Алгоритм Сортируем массив. Возвращаем k-тый элемент с конца. Решение def findKthLargest(nums, k): nums.sort() return nums[-k]</description></item><item><title>229. Majority Element II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/229/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/229/</guid><description>LeetCode problem 229
Problem Statement Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Naive Solution The immediate solution would involve using a hashmap or dictionary to track the occurrence of each number in the array. After which, we can iterate over the dictionary to find numbers whose occurrences are greater than n/3.
Hints &amp;amp; Tips There can be at most one or two majority elements which appear more than n/3 times in the array.</description></item><item><title>236. Lowest Common Ancestor of a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/236/</guid><description>LeetCode задача 236
Задача Найдите наименьшего общего предка (LCA) двух заданных узлов в бинарном дереве.
Подсказки Используйте метод обхода в глубину (DFS) для решения этой задачи.
Подход Обход в глубину (DFS): Используйте рекурсивный метод для обхода дерева. Поиск узлов: При обходе дерева ищите заданные узлы p и q. Возврат значения: Если найден один из узлов, верните его как потенциального предка. Сравнение результатов: Если оба поддерева возвращают узлы, текущий узел является LCA. Пропуск пустых узлов: Если узел пуст, верните None.</description></item><item><title>237. Delete Node in a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/237/</guid><description>LeetCode задача 237
Задача Написать функцию для удаления узла (за исключением хвостового) в односвязном списке, дан только доступ к этому узлу.
Подсказки Обычно, для удаления узла из односвязного списка, нам нужен доступ к предыдущему узлу. В этом случае, у нас такого доступа нет. Как это обойти? Подход Поскольку доступа к предыдущему узлу нет, мы не можем просто &amp;ldquo;вырезать&amp;rdquo; текущий узел. Однако мы можем переписать значение текущего узла значением следующего узла и затем удалить следующий узел.
Алгоритм Перезаписываем значение текущего узла значением следующего узла.</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2402/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2402/</guid><description>LeetCode problem 240
class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: m, n = len(matrix), len(matrix[0]) i, j = m - 1, 0 while i &amp;gt;= 0 and j &amp;lt; n: if matrix[i][j] == target: return True if matrix[i][j] &amp;gt; target: i -= 1 else: j += 1 return False</description></item><item><title>240. Search a 2D Matrix II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/240/</guid><description>LeetCode задача 240
Задача Вам дана двумерная матрица размера m x n, представляющая прямоугольник, и целое число target. Отсортированные строки матрицы по неубыванию с лева направо и столбцы отсортированы по неубыванию сверху вниз.
Найдите элемент target в матрице. Верните True, если элемент target есть в матрице, и False, если его нет.
Подсказки Попробуйте использовать двоичный поиск для каждого ряда.
Подход Самый простой подход - использовать двоичный поиск для каждого ряда. Хотя это не самый эффективный метод, он достаточно прост для понимания.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2512/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2512/</guid><description>LeetCode problem 251
class Vector2D: def __init__(self, vec: List[List[int]]): self.i = 0 self.j = 0 self.vec = vec def next(self) -&amp;gt; int: self.forward() res = self.vec[self.i][self.j] self.j += 1 return res def hasNext(self) -&amp;gt; bool: self.forward() return self.i &amp;lt; len(self.vec) def forward(self): while self.i &amp;lt; len(self.vec) and self.j &amp;gt;= len(self.vec[self.i]): self.i += 1 self.j = 0 # Your Vector2D object will be instantiated and called as such: # obj = Vector2D(vec) # param_1 = obj.next() # param_2 = obj.</description></item><item><title>251. Flatten 2D Vector</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/251/</guid><description>LeetCode задача 251
Задача Дизайн и реализация итератора для 2D вектора. Итератор должен быть инициализирован 2D вектором (vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;) и должен поддерживать следующие операции:
next(): Возвращает следующий элемент из 2D вектора. Если нет больше элементов, возвращает 0. hasNext(): Возвращает True, если в 2D векторе есть следующий элемент, и False в противном случае. Подход Мы можем использовать две переменные: одну для текущего индекса строки и одну для текущего индекса столбца, чтобы навигироваться по 2D вектору.
Алгоритм Инициализируем переменные row и col в конструкторе.</description></item><item><title>277. Find the Celebrity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/277/</guid><description>LeetCode задача 277
Задача Предположим, у вас есть n человек и их отношения между собой неизвестны. Существует ли такая персона (знаменитость), что все знают её, но она никого не знает?
Имплементируйте функцию int findCelebrity(n), которая вернет знаменитость если она есть, иначе вернёт -1.
Вам дана функция bool knows(a, b), которая скажет вам, знает ли a человека b.
Подход Чтобы найти знаменитость, можно использовать двухпроходный алгоритм. В первом проходе идентифицируем возможную знаменитость. Во втором проходе проверяем эту кандидатуру.
Алгоритм Инициализируем переменную candidate значением 0.</description></item><item><title>287. Find the Duplicate Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/287/</guid><description>LeetCode задача 287
Задача Дан массив nums размера n + 1, в котором каждый элемент принимает значение от 1 до n, что означает, что как минимум одно число будет дублироваться.
Найдите это дублирующееся число.
Подход Один из способов решения задачи — использование двух указателей (tortoise и hare), что известно как &amp;ldquo;алгоритм зайца и черепахи&amp;rdquo; для нахождения цикла в связанном списке.
Алгоритм Инициализируем два указателя: tortoise и hare. Используем их для прохода по массиву: tortoise двигается на один шаг, а hare — на два.</description></item><item><title>300. Longest Increasing Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/300/</guid><description>LeetCode задача 300
Задача Дан массив чисел, ваша задача — найти длину наибольшей возрастающей подпоследовательности.
Подсказки Для решения этой задачи вы можете использовать динамическое программирование.
Подход Инициализация: Инициализируйте массив, который будет хранить длины наибольших возрастающих подпоследовательностей для каждого элемента массива. Обход массива: Обойдите массив, и для каждого элемента обновите массив длин наибольших возрастающих подпоследовательностей. Максимум: По окончании обхода найдите максимальное значение в массиве длин. Простейший способ решения — это использовать двойной цикл для обхода массива и поиска наибольшей возрастающей подпоследовательности для каждого элемента.</description></item><item><title>328. Odd Even Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/328/</guid><description>LeetCode задача 328
Задача Дан односвязный список и задача переставить его узлы таким образом, чтобы все узлы с нечетными индексами шли перед всеми узлами с четными индексами.
Вариант решения 1 Рассмотрим вариант решения более простой для понимания и реализации.
Подсказки Использовать два связных списка.
Подход Во время прохода по связному списку указатель для чётных узлов добавлять связанный список с четными, то же самое делать с нечетными.
В конце прохода список с четными узлами добавить в конец списка с нечетными узлами.</description></item><item><title>341. Flatten Nested List Iterator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</link><pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/341/</guid><description>Задача Дан вложенный список целых чисел. Реализуйте итератор, который &amp;ldquo;разворачивает&amp;rdquo; этот вложенный список.
Подход Задача состоит в реализации итератора, который будет последовательно возвращать все элементы из вложенного списка. Вложенный список может содержать как обычные числа, так и другие вложенные списки. Наивное решение заключается в том, чтобы сначала полностью &amp;ldquo;развернуть&amp;rdquo; весь вложенный список в одномерный список, а затем реализовать итератор для этого одномерного списка.
Алгоритм Инициализация: Создать одномерный список и заполнить его элементами из вложенного списка. next(): Возвращает следующий элемент одномерного списка.</description></item><item><title>343. Integer Break</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/343/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/343/</guid><description>LeetCode problem 343
Problem Statement Given a positive integer n, our task is to divide it into the sum of k positive integers, where $k \geq 2$, in such a way that the product of these integers is maximized. Our goal is to determine the maximum possible product.
Naive Solution A straightforward or naive way to solve this would be to consider all potential combinations to divide the number n and calculate the product for each division. This method, while comprehensive, would be inefficient and impractical for larger values of n.</description></item><item><title>377. Combination Sum IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/377/</guid><description>LeetCode задача 377
Задача Дан массив различных целых чисел nums и целевое целое число target от 1 до 1000. Нужно вернуть количество возможных комбинаций, которые в сумме дают target.
Подсказки Построить дерево решений Задачу можно решить путем разложения ее на меньшие подзадачи с помощью динамического программирования. Нахождение целевого значения в дереве решений
Your browser does not support the video tag. LeetCode 377 Решение Подход Если целевое значение - target=7 и nums=[2, 3, 4], то в дереве решений может быть несколько путей до этого числа.</description></item><item><title>384. Shuffle an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/384/</guid><description>LeetCode задача 384
Задача Реализуйте класс, который принимает массив чисел в конструкторе и предоставляет метод для их случайного перемешивания, а также метод для возвращения исходного массива.
Подсказки Для создания случайного порядка элементов можно использовать алгоритм Фишера-Йетса или другие методы перемешивания.
Подход Инициализация: Сохранить исходный массив в переменной класса для дальнейшего использования. reset(): Вернуть исходный массив. shuffle(): Вернуть перемешанный массив. Из всех возможных подходов к решению этой задачи, наиболее простым является использование встроенного метода random.shuffle() из Python стандартной библиотеки для перемешивания массива.</description></item><item><title>387. First Unique Character in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/387/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/387/</guid><description>LeetCode задача 387
Задача Дана строка s. Найдите первый уникальный символ в строке и верните его индекс. Если такого символа нет, верните -1.
Подсказки Использование хеш-таблицы может ускорить процесс поиска уникальных символов.
Подход Инициализация: Создайте хеш-таблицу для хранения частоты каждого символа в строке. Первый проход: Пройдите по строке и заполните хеш-таблицу. Второй проход: Пройдите по строке второй раз и проверьте частоту каждого символа в хеш-таблице. Первый символ с частотой 1 будет ответом. Этот подход прост для понимания и реализации.</description></item><item><title>389. Find the Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/389/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/389/</guid><description>LeetCode problem 389
Problem Statement Given two strings s and t, the string t is generated by shuffling the characters of s and adding one additional character at a random position. The task is to identify and return that extra character.
Naive Solution A naive solution would involve comparing the characters in both strings one by one to detect the extra character in t. This method is not efficient as it could take a linear amount of time for strings of considerable lengths.</description></item><item><title>454. 4Sum II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/454/</guid><description>LeetCode задача 454
Задача Даны четыре списка A, B, C, D целых чисел. Вычислите, сколько существует таких кортежей (i, j, k, l), что ( A[i] + B[j] + C[k] + D[l] = 0 ).
Подсказки Используйте хэш-таблицу для ускорения решения.
Подход Создание хэш-таблицы: Сначала создайте хэш-таблицу, которая будет хранить суммы пар чисел из массивов A и B. Подсчет сумм: Для каждой пары (i, j) из A и B, увеличьте соответствующий элемент хэш-таблицы на 1. Поиск в хэш-таблице: Для каждой пары (k, l) из C и D, проверьте, существует ли -(C[k] + D[l]) в хэш-таблице.</description></item><item><title>725. Split Linked List in Parts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/725/</guid><description>LeetCode задача 725
Задача Дан односвязный список и целое число k. Задача заключается в том, чтобы разделить односвязный список на k последовательных частей.
Длина каждой части должна быть максимально равномерной: любые две части не должны отличаться по размеру более чем на одну единицу. Это может привести к тому, что некоторые части будут пустыми (null).
Части должны идти в том порядке, в котором они встречаются в исходном списке, и ранее встречающиеся части всегда должны иметь размер больше или равный позднее встречающимся.</description></item><item><title>791. Custom Sort String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/791/</guid><description>LeetCode problem 791
class Solution: def customSortString(self, order: str, s: str) -&amp;gt; str: cnt = Counter(s) res = [] for c in order: res.append(c * cnt[c]) cnt[c] = 0 for c, v in cnt.items(): res.append(c * v) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>799. Champagne Tower</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/799/</guid><description>LeetCode problem 799
Problem Statement You are tasked with modeling a champagne tower. Glasses are stacked in a pyramid, with each row having one more glass than the previous. When champagne is poured into the top glass and it overflows, the overflowed champagne is split equally between the two glasses below. The objective is to determine how full a specified glass will be after pouring a given amount of champagne.
Naive Solution One could imagine a simulation, where we pour champagne into the top glass and then, glass-by-glass, simulate the overflow until we reach the desired glass.</description></item><item><title>847. Shortest Path Visiting All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</link><pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/847/</guid><description>LeetCode problem 847
Problem Statement Given an undirected, connected graph of n nodes labeled from 0 to n - 1. An array graph is provided where graph[i] is a list of all the nodes connected with node i by an edge. The objective is to determine the length of the shortest path that visits every node.
It&amp;rsquo;s permissible to start and stop at any node, revisit nodes multiple times, and reuse edges.
Naive Solution A naive approach would be to attempt all possible paths (brute force) until all nodes are visited.</description></item><item><title>880. Decoded String at Index</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/880/</link><pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/880/</guid><description>LeetCode problem 880
Problem Statement Given an encoded string s, the encoded string is transformed into a tape based on the following criteria:
When a letter is encountered, it&amp;rsquo;s written on the tape. When a digit d is encountered, the current content of the tape is repeated d - 1 more times. You are required to find and return the kth letter (1-indexed) on the decoded tape.
Naive Solution A straightforward solution would involve constructing the entire decoded tape and then simply accessing the kth character.</description></item><item><title>948. Bag of Tokens</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/948/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/948/</guid><description>LeetCode problem 948
class Solution: def bagOfTokensScore(self, tokens: List[int], power: int) -&amp;gt; int: tokens.sort() i, j = 0, len(tokens) - 1 res = t = 0 while i &amp;lt;= j: if power &amp;gt;= tokens[i]: power -= tokens[i] i, t = i + 1, t + 1 res = max(res, t) elif t: power += tokens[j] j, t = j - 1, t - 1 else: break return res</description></item><item><title>949. Largest Time for Given Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/949/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/949/</guid><description>LeetCode problem 949
class Solution: def largestTimeFromDigits(self, arr: List[int]) -&amp;gt; str: res = -1 for i in range(4): for j in range(4): for k in range(4): if i != j and i != k and j != k: h = arr[i] * 10 + arr[j] m = arr[k] * 10 + arr[6 - i - j - k] if h &amp;lt; 24 and m &amp;lt; 60: res = max(res, h * 60 + m) return &amp;#39;&amp;#39; if res &amp;lt; 0 else f&amp;#39;{res // 60:02}:{res % 60:02}&amp;#39;</description></item><item><title>950. Reveal Cards In Increasing Order</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/950/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/950/</guid><description>LeetCode problem 950
class Solution: def deckRevealedIncreasing(self, deck: List[int]) -&amp;gt; List[int]: q = deque() for v in sorted(deck, reverse=True): if q: q.appendleft(q.pop()) q.appendleft(v) return list(q)</description></item><item><title>951. Flip Equivalent Binary Trees</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/951/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/951/</guid><description>LeetCode problem 951
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&amp;gt; bool: def dfs(root1, root2): if root1 == root2 or (root1 is None and root2 is None): return True if root1 is None or root2 is None or root1.val != root2.val: return False return (dfs(root1.left, root2.left) and dfs(root1.right, root2.right)) or ( dfs(root1.</description></item><item><title>954. Array of Doubled Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/954/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/954/</guid><description>LeetCode problem 954
class Solution: def canReorderDoubled(self, arr: List[int]) -&amp;gt; bool: freq = Counter(arr) if freq[0] &amp;amp; 1: return False for x in sorted(freq, key=abs): if freq[x &amp;lt;&amp;lt; 1] &amp;lt; freq[x]: return False freq[x &amp;lt;&amp;lt; 1] -= freq[x] return True</description></item><item><title>958. Check Completeness of a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/958/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/958/</guid><description>LeetCode problem 958
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isCompleteTree(self, root: TreeNode) -&amp;gt; bool: q = deque([root]) while q: node = q.popleft() if node is None: break q.append(node.left) q.append(node.right) return all(node is None for node in q)</description></item><item><title>959. Regions Cut By Slashes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/959/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/959/</guid><description>LeetCode problem 959
class Solution: def regionsBySlashes(self, grid: List[str]) -&amp;gt; int: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def union(a, b): pa = find(a) pb = find(b) if pa != pb: p[pa] = pb nonlocal size size -= 1 n = len(grid) size = n * n * 4 p = list(range(size)) for i, row in enumerate(grid): for j, v in enumerate(row): k = i * n + j if i &amp;lt; n - 1: union(4 * k + 2, (k + n) * 4) if j &amp;lt; n - 1: union(4 * k + 1, (k + 1) * 4 + 3) if v == &amp;#39;/&amp;#39;: union(4 * k, 4 * k + 3) union(4 * k + 1, 4 * k + 2) elif v == &amp;#39;\\&amp;#39;: union(4 * k, 4 * k + 1) union(4 * k + 2, 4 * k + 3) else: union(4 * k, 4 * k + 1) union(4 * k + 1, 4 * k + 2) union(4 * k + 2, 4 * k + 3) return size</description></item><item><title>962. Maximum Width Ramp</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/962/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/962/</guid><description>LeetCode problem 962
class Solution: def maxWidthRamp(self, nums: List[int]) -&amp;gt; int: stk = [] for i, v in enumerate(nums): if not stk or nums[stk[-1]] &amp;gt; v: stk.append(i) res = 0 for i in range(len(nums) - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt;= nums[i]: res = max(res, i - stk.pop()) if not stk: break return res</description></item><item><title>963. Minimum Area Rectangle II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/963/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/963/</guid><description>LeetCode problem 963
class Solution: def minAreaFreeRect(self, points: List[List[int]]) -&amp;gt; float: s = {(x, y) for x, y in points} n = len(points) res = inf for i in range(n): x1, y1 = points[i] for j in range(n): if j != i: x2, y2 = points[j] for k in range(j + 1, n): if k != i: x3, y3 = points[k] x4 = x2 - x1 + x3 y4 = y2 - y1 + y3 if (x4, y4) in s: v21 = (x2 - x1, y2 - y1) v31 = (x3 - x1, y3 - y1) if v21[0] * v31[0] + v21[1] * v31[1] == 0: w = sqrt(v21[0] ** 2 + v21[1] ** 2) h = sqrt(v31[0] ** 2 + v31[1] ** 2) res = min(res, w * h) return 0 if res == inf else res</description></item><item><title>966. Vowel Spellchecker</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/966/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/966/</guid><description>LeetCode problem 966
class Solution: def spellchecker(self, wordlist: List[str], queries: List[str]) -&amp;gt; List[str]: def f(w): t = [] for c in w: t.append(&amp;#34;*&amp;#34; if c in &amp;#34;aeiou&amp;#34; else c) return &amp;#34;&amp;#34;.join(t) s = set(wordlist) low, pat = {}, {} for w in wordlist: t = w.lower() low.setdefault(t, w) pat.setdefault(f(t), w) res = [] for q in queries: if q in s: res.append(q) continue q = q.lower() if q in low: res.append(low[q]) continue q = f(q) if q in pat: res.</description></item><item><title>967. Numbers With Same Consecutive Differences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/967/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/967/</guid><description>LeetCode problem 967
class Solution: def numsSameConsecDiff(self, n: int, k: int) -&amp;gt; List[int]: res = [] def dfs(n, k, t): if n == 0: res.append(t) return last = t % 10 if last + k &amp;lt;= 9: dfs(n - 1, k, t * 10 + last + k) if last - k &amp;gt;= 0 and k != 0: dfs(n - 1, k, t * 10 + last - k) for i in range(1, 10): dfs(n - 1, k, i) return res</description></item><item><title>969. Pancake Sorting</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/969/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/969/</guid><description>LeetCode problem 969
class Solution: def pancakeSort(self, arr: List[int]) -&amp;gt; List[int]: def reverse(arr, j): i = 0 while i &amp;lt; j: arr[i], arr[j] = arr[j], arr[i] i, j = i + 1, j - 1 n = len(arr) res = [] for i in range(n - 1, 0, -1): j = i while j &amp;gt; 0 and arr[j] != i + 1: j -= 1 if j &amp;lt; i: if j &amp;gt; 0: res.append(j + 1) reverse(arr, j) res.</description></item><item><title>970. Powerful Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/970/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/970/</guid><description>LeetCode problem 970
class Solution: def powerfulIntegers(self, x: int, y: int, bound: int) -&amp;gt; List[int]: res = set() a = 1 while a &amp;lt;= bound: b = 1 while a + b &amp;lt;= bound: res.add(a + b) b *= y if y == 1: break if x == 1: break a *= x return list(res)</description></item><item><title>1004. Max Consecutive Ones III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1004/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1004/</guid><description>LeetCode задача 1004
Задача Дан массив A состоящий из 0 и 1, и число K. Найти максимальную длину подпоследовательности единиц, которую можно получить, преобразовав не более K нулей в единицы.
Подсказки Использование скользящего окна может значительно ускорить решение задачи.
Подход Инициализация: Создайте переменные для хранения начала и конца &amp;ldquo;окна&amp;rdquo; и максимальной длины подпоследовательности. Проход по массиву: Перемещайте &amp;ldquo;окно&amp;rdquo; по массиву, подсчитывая количество нулей внутри. Сдвиг окна: Если количество нулей превышает K, сдвигайте левый край окна, пока это не станет истиной.</description></item><item><title>1046. Last Stone Weight</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1046/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1046/</guid><description>LeetCode problem 1046
class Solution: def lastStoneWeight(self, stones: List[int]) -&amp;gt; int: h = [-x for x in stones] heapify(h) while len(h) &amp;gt; 1: y, x = -heappop(h), -heappop(h) if x != y: heappush(h, x - y) return 0 if not h else -h[0]</description></item><item><title>1047. Remove All Adjacent Duplicates In String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1047/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1047/</guid><description>LeetCode problem 1047
class Solution: def removeDuplicates(self, s: str) -&amp;gt; str: stk = [] for c in s: if stk and stk[-1] == c: stk.pop() else: stk.append(c) return &amp;#39;&amp;#39;.join(stk)</description></item><item><title>1048. Longest String Chain</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1048/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1048/</guid><description>LeetCode problem 1048
Problem Statement You are given an array of words where each word consists of lowercase English letters. Your task is to determine the longest string chain you can form given this list. A word A can be a predecessor of word B if by adding exactly one letter to A (at any position), B is formed. The objective is to find the longest sequence where each word is a predecessor of the next.
Naive Solution The straightforward brute-force way would be to try all possible combinations of word chains.</description></item><item><title>1051. Height Checker</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1051/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1051/</guid><description>LeetCode problem 1051
class Solution: def heightChecker(self, heights: List[int]) -&amp;gt; int: cnt = [0] * 101 for h in heights: cnt[h] += 1 res = i = 0 for j in range(1, 101): while cnt[j]: cnt[j] -= 1 if heights[i] != j: res += 1 i += 1 return res</description></item><item><title>1056. Confusing Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1056/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1056/</guid><description>LeetCode problem 1056
class Solution: def confusingNumber(self, n: int) -&amp;gt; bool: x, y = n, 0 d = [0, 1, -1, -1, -1, -1, 9, -1, 8, 6] while x: x, v = divmod(x, 10) if d[v] &amp;lt; 0: return False y = y * 10 + d[v] return y != n</description></item><item><title>1064. Fixed Point</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1064/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1064/</guid><description>LeetCode problem 1064
class Solution: def fixedPoint(self, arr: List[int]) -&amp;gt; int: left, right = 0, len(arr) - 1 while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if arr[mid] &amp;gt;= mid: right = mid else: left = mid + 1 return left if arr[left] == left else -1</description></item><item><title>1065. Index Pairs of a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1065/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1065/</guid><description>LeetCode problem 1065
class Trie: def __init__(self): self.children = [None] * 26 self.is_end = False def insert(self, word): node = self for c in word: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: node.children[idx] = Trie() node = node.children[idx] node.is_end = True class Solution: def indexPairs(self, text: str, words: List[str]) -&amp;gt; List[List[int]]: trie = Trie() for w in words: trie.insert(w) n = len(text) res = [] for i in range(n): node = trie for j in range(i, n): idx = ord(text[j]) - ord(&amp;#39;a&amp;#39;) if node.</description></item><item><title>1078. Occurrences After Bigram</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1078/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1078/</guid><description>LeetCode problem 1078
class Solution: def findOcurrences(self, text: str, first: str, second: str) -&amp;gt; List[str]: words = text.split() res = [] for i in range(len(words) - 2): a, b, c = words[i : i + 3] if a == first and b == second: res.append(c) return res</description></item><item><title>1085. Sum of Digits in the Minimum Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1085/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1085/</guid><description>LeetCode problem 1085
class Solution: def sumOfDigits(self, nums: List[int]) -&amp;gt; int: x = min(nums) s = 0 while x: s += x % 10 x //= 10 return s &amp;amp; 1 ^ 1</description></item><item><title>1086. High Five</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1086/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1086/</guid><description>LeetCode problem 1086
class Solution: def highFive(self, items: List[List[int]]) -&amp;gt; List[List[int]]: d = defaultdict(list) m = 0 for i, x in items: d[i].append(x) m = max(m, i) res = [] for i in range(1, m + 1): if xs := d[i]: avg = sum(nlargest(5, xs)) // 5 res.append([i, avg]) return res</description></item><item><title>1089. Duplicate Zeros</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1089/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1089/</guid><description>LeetCode problem 1089
class Solution: def duplicateZeros(self, arr: List[int]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify arr in-place instead. &amp;#34;&amp;#34;&amp;#34; n = len(arr) i, k = -1, 0 while k &amp;lt; n: i += 1 k += 1 if arr[i] else 2 j = n - 1 if k == n + 1: arr[j] = 0 i, j = i - 1, j - 1 while ~j: if arr[i] == 0: arr[j] = arr[j - 1] = arr[i] j -= 1 else: arr[j] = arr[i] i, j = i - 1, j - 1</description></item><item><title>1099. Two Sum Less Than K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1099/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1099/</guid><description>LeetCode problem 1099
class Solution: def twoSumLessThanK(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() i, j = 0, len(nums) - 1 res = -1 while i &amp;lt; j: if (s := nums[i] + nums[j]) &amp;lt; k: res = max(res, s) i += 1 else: j -= 1 return res</description></item><item><title>1103. Distribute Candies to People</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1103/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1103/</guid><description>LeetCode problem 1103
class Solution: def distributeCandies(self, candies: int, num_people: int) -&amp;gt; List[int]: res = [0] * num_people i = 0 while candies: res[i % num_people] += min(candies, i + 1) candies -= min(candies, i + 1) i += 1 return res</description></item><item><title>1108. Defanging an IP Address</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1108/</guid><description>LeetCode problem 1108
class Solution: def defangIPaddr(self, address: str) -&amp;gt; str: return address.replace(&amp;#39;.&amp;#39;, &amp;#39;[.]&amp;#39;)</description></item><item><title>1114. Print in Order</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1114/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1114/</guid><description>LeetCode problem 1114
from threading import Semaphore class Foo: def __init__(self): self.a = Semaphore(1) self.b = Semaphore(0) self.c = Semaphore(0) def first(self, printFirst: &amp;#39;Callable[[], None]&amp;#39;) -&amp;gt; None: self.a.acquire() # printFirst() outputs &amp;#34;first&amp;#34;. Do not change or remove this line. printFirst() self.b.release() def second(self, printSecond: &amp;#39;Callable[[], None]&amp;#39;) -&amp;gt; None: self.b.acquire() # printSecond() outputs &amp;#34;second&amp;#34;. Do not change or remove this line. printSecond() self.c.release() def third(self, printThird: &amp;#39;Callable[[], None]&amp;#39;) -&amp;gt; None: self.c.acquire() # printThird() outputs &amp;#34;third&amp;#34;. Do not change or remove this line.</description></item><item><title>1118. Number of Days in a Month</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1118/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1118/</guid><description>LeetCode problem 1118
class Solution: def numberOfDays(self, year: int, month: int) -&amp;gt; int: leap = (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) days = [0, 31, 29 if leap else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] return days[month]</description></item><item><title>1119. Remove Vowels from a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1119/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1119/</guid><description>LeetCode problem 1119
class Solution: def removeVowels(self, s: str) -&amp;gt; str: return &amp;#34;&amp;#34;.join(c for c in s if c not in &amp;#34;aeiou&amp;#34;)</description></item><item><title>1122. Relative Sort Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1122/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1122/</guid><description>LeetCode problem 1122
class Solution: def relativeSortArray(self, arr1: List[int], arr2: List[int]) -&amp;gt; List[int]: pos = {x: i for i, x in enumerate(arr2)} return sorted(arr1, key=lambda x: pos.get(x, 1000 + x))</description></item><item><title>1128. Number of Equivalent Domino Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1128/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1128/</guid><description>LeetCode problem 1128
class Solution: def numEquivDominoPairs(self, dominoes: List[List[int]]) -&amp;gt; int: cnt = Counter() res = 0 for a, b in dominoes: x = a * 10 + b if a &amp;lt; b else b * 10 + a res += cnt[x] cnt[x] += 1 return res</description></item><item><title>1133. Largest Unique Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1133/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1133/</guid><description>LeetCode problem 1133
class Solution: def largestUniqueNumber(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) return max((x for x, v in cnt.items() if v == 1), default=-1)</description></item><item><title>1134. Armstrong Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1134/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1134/</guid><description>LeetCode problem 1134
class Solution: def isArmstrong(self, n: int) -&amp;gt; bool: k = len(str(n)) s, x = 0, n while x: s += (x % 10) ** k x //= 10 return s == n</description></item><item><title>1137. N-th Tribonacci Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1137/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1137/</guid><description>LeetCode problem 1137
import numpy as np class Solution: def tribonacci(self, n: int) -&amp;gt; int: if n == 0: return 0 if n &amp;lt; 3: return 1 factor = np.mat([(1, 1, 0), (1, 0, 1), (1, 0, 0)], np.dtype(&amp;#34;O&amp;#34;)) res = np.mat([(1, 1, 0)], np.dtype(&amp;#34;O&amp;#34;)) n -= 3 while n: if n &amp;amp; 1: res *= factor factor *= factor n &amp;gt;&amp;gt;= 1 return res.sum()</description></item><item><title>1138. Alphabet Board Path</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1138/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1138/</guid><description>LeetCode problem 1138
class Solution: def alphabetBoardPath(self, target: str) -&amp;gt; str: i = j = 0 res = [] for c in target: v = ord(c) - ord(&amp;#34;a&amp;#34;) x = v // 5 y = v % 5 while j &amp;gt; y: j -= 1 res.append(&amp;#34;L&amp;#34;) while i &amp;gt; x: i -= 1 res.append(&amp;#34;U&amp;#34;) while j &amp;lt; y: j += 1 res.append(&amp;#34;R&amp;#34;) while i &amp;lt; x: i += 1 res.append(&amp;#34;D&amp;#34;) res.append(&amp;#34;!&amp;#34;) return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1150. Check If a Number Is Majority Element in a Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1150/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1150/</guid><description>LeetCode problem 1150
class Solution: def isMajorityElement(self, nums: List[int], target: int) -&amp;gt; bool: left = bisect_left(nums, target) right = left + len(nums) // 2 return right &amp;lt; len(nums) and nums[right] == target</description></item><item><title>1152. Analyze User Website Visit Pattern</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1152/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1152/</guid><description>LeetCode problem 1152
class Solution: def mostVisitedPattern( self, username: List[str], timestamp: List[int], website: List[str]) -&amp;gt; List[str]: d = defaultdict(list) for user, _, site in sorted(zip(username, timestamp, website), key=lambda x: x[1]): d[user].append(site) cnt = Counter() for sites in d.values(): m = len(sites) s = set() if m &amp;gt; 2: for i in range(m - 2): for j in range(i + 1, m - 1): for k in range(j + 1, m): s.add((sites[i], sites[j], sites[k])) for t in s: cnt[t] += 1 return sorted(cnt.</description></item><item><title>1154. Day of the Year</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1154/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1154/</guid><description>LeetCode problem 1154
class Solution: def dayOfYear(self, date: str) -&amp;gt; int: y, m, d = (int(s) for s in date.split(&amp;#39;-&amp;#39;)) v = 29 if y % 400 == 0 or (y % 4 == 0 and y % 100) else 28 days = [31, v, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] return sum(days[: m - 1]) + d</description></item><item><title>1160. Find Words That Can Be Formed by Characters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1160/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1160/</guid><description>LeetCode problem 1160
class Solution: def countCharacters(self, words: List[str], chars: str) -&amp;gt; int: cnt = Counter(chars) res = 0 for w in words: wc = Counter(w) if all(cnt[c] &amp;gt;= v for c, v in wc.items()): res += len(w) return res</description></item><item><title>1162. As Far from Land as Possible</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1162/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1162/</guid><description>LeetCode problem 1162
class Solution: def maxDistance(self, grid: List[List[int]]) -&amp;gt; int: n = len(grid) q = deque((i, j) for i in range(n) for j in range(n) if grid[i][j]) res = -1 if len(q) in (0, n * n): return res dirs = (-1, 0, 1, 0, -1) while q: for _ in range(len(q)): i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; n and 0 &amp;lt;= y &amp;lt; n and grid[x][y] == 0: grid[x][y] = 1 q.</description></item><item><title>1165. Single-Row Keyboard</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1165/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1165/</guid><description>LeetCode problem 1165
class Solution: def calculateTime(self, keyboard: str, word: str) -&amp;gt; int: pos = {c: i for i, c in enumerate(keyboard)} res = i = 0 for c in word: res += abs(pos[c] - i) i = pos[c] return res</description></item><item><title>1171. Remove Zero Sum Consecutive Nodes from Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1171/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1171/</guid><description>LeetCode problem 1171
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeZeroSumSublists(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode(next=head) last = {} s = 0 cur = dummy while cur: s += cur.val last[s] = cur cur = cur.next s = 0 cur = dummy while cur: s += cur.val cur.next = last[s].next cur = cur.next return dummy.next</description></item><item><title>1175. Prime Arrangements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1175/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1175/</guid><description>LeetCode problem 1175
class Solution: def numPrimeArrangements(self, n: int) -&amp;gt; int: def count(n): cnt = 0 primes = [True] * (n + 1) for i in range(2, n + 1): if primes[i]: cnt += 1 for j in range(i + i, n + 1, i): primes[j] = False return cnt cnt = count(n) res = factorial(cnt) * factorial(n - cnt) return res % (10**9 + 7)</description></item><item><title>1176. Diet Plan Performance</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1176/</guid><description>LeetCode problem 1176
class Solution: def dietPlanPerformance( self, calories: List[int], k: int, lower: int, upper: int ) -&amp;gt; int: def check(s): if s &amp;lt; lower: return -1 if s &amp;gt; upper: return 1 return 0 s, n = sum(calories[:k]), len(calories) res = check(s) for i in range(k, n): s += calories[i] - calories[i - k] res += check(s) return res</description></item><item><title>1180. Count Substrings with Only One Distinct Letter</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1180/</guid><description>LeetCode problem 1180
class Solution: def countLetters(self, s: str) -&amp;gt; int: res = 0 i, n = 0, len(s) while i &amp;lt; n: j = i cnt = 0 while j &amp;lt; n and s[j] == s[i]: j += 1 cnt += 1 res += cnt i = j return res</description></item><item><title>1184. Distance Between Bus Stops</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1184/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1184/</guid><description>LeetCode problem 1184
class Solution: def distanceBetweenBusStops( self, distance: List[int], start: int, destination: int ) -&amp;gt; int: a, n = 0, len(distance) while start != destination: a += distance[start] start = (start + 1) % n return min(a, sum(distance) - a)</description></item><item><title>1185. Day of the Week</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1185/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1185/</guid><description>LeetCode problem 1185
class Solution: def dayOfTheWeek(self, d: int, m: int, y: int) -&amp;gt; str: if m &amp;lt; 3: m += 12 y -= 1 c = y // 100 y = y % 100 w = (c // 4 - 2 * c + y + y // 4 + 13 * (m + 1) // 5 + d - 1) % 7 return [ &amp;#34;Sunday&amp;#34;, &amp;#34;Monday&amp;#34;, &amp;#34;Tuesday&amp;#34;, &amp;#34;Wednesday&amp;#34;, &amp;#34;Thursday&amp;#34;, &amp;#34;Friday&amp;#34;, &amp;#34;Saturday&amp;#34;, ][w]</description></item><item><title>1189. Maximum Number of Balloons</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1189/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1189/</guid><description>LeetCode problem 1189
class Solution: def maxNumberOfBalloons(self, text: str) -&amp;gt; int: cnt = Counter(text) cnt[&amp;#39;o&amp;#39;] &amp;gt;&amp;gt;= 1 cnt[&amp;#39;l&amp;#39;] &amp;gt;&amp;gt;= 1 return min(cnt[c] for c in &amp;#39;balon&amp;#39;)</description></item><item><title>1196. How Many Apples Can You Put into the Basket</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1196/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1196/</guid><description>LeetCode problem 1196
class Solution: def maxNumberOfApples(self, weight: List[int]) -&amp;gt; int: weight.sort() s = 0 for i, x in enumerate(weight): s += x if s &amp;gt; 5000: return i return len(weight)</description></item><item><title>1200. Minimum Absolute Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1200/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1200/</guid><description>LeetCode problem 1200
class Solution: def minimumAbsDifference(self, arr: List[int]) -&amp;gt; List[List[int]]: arr.sort() mi = min(b - a for a, b in pairwise(arr)) return [[a, b] for a, b in pairwise(arr) if b - a == mi]</description></item><item><title>1213. Intersection of Three Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1213/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1213/</guid><description>LeetCode problem 1213
class Solution: def arraysIntersection( self, arr1: List[int], arr2: List[int], arr3: List[int] ) -&amp;gt; List[int]: res = [] for x in arr1: i = bisect_left(arr2, x) j = bisect_left(arr3, x) if i &amp;lt; len(arr2) and j &amp;lt; len(arr3) and arr2[i] == x and arr3[j] == x: res.append(x) return res</description></item><item><title>1217. Minimum Cost to Move Chips to The Same Position</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1217/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1217/</guid><description>LeetCode problem 1217
class Solution: def minCostToMoveChips(self, position: List[int]) -&amp;gt; int: a = sum(p % 2 for p in position) b = len(position) - a return min(a, b)</description></item><item><title>1221. Split a String in Balanced Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1221/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1221/</guid><description>LeetCode problem 1221
class Solution: def balancedStringSplit(self, s: str) -&amp;gt; int: res = l = 0 for c in s: if c == &amp;#39;L&amp;#39;: l += 1 else: l -= 1 if l == 0: res += 1 return res</description></item><item><title>1228. Missing Number In Arithmetic Progression</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1228/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1228/</guid><description>LeetCode problem 1228
class Solution: def missingNumber(self, arr: List[int]) -&amp;gt; int: n = len(arr) d = (arr[-1] - arr[0]) // n for i in range(1, n): if arr[i] != arr[i - 1] + d: return arr[i - 1] + d return arr[0]</description></item><item><title>1232. Check If It Is a Straight Line</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1232/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1232/</guid><description>LeetCode problem 1232
class Solution: def checkStraightLine(self, coordinates: List[List[int]]) -&amp;gt; bool: x1, y1 = coordinates[0] x2, y2 = coordinates[1] for x, y in coordinates[2:]: if (x - x1) * (y2 - y1) != (y - y1) * (x2 - x1): return False return True</description></item><item><title>1243. Array Transformation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1243/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1243/</guid><description>LeetCode problem 1243
class Solution: def transformArray(self, arr: List[int]) -&amp;gt; List[int]: f = True while f: f = False t = arr[:] for i in range(1, len(t) - 1): if t[i] &amp;gt; t[i - 1] and t[i] &amp;gt; t[i + 1]: arr[i] -= 1 f = True if t[i] &amp;lt; t[i - 1] and t[i] &amp;lt; t[i + 1]: arr[i] += 1 f = True return arr</description></item><item><title>1252. Cells with Odd Values in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1252/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1252/</guid><description>LeetCode problem 1252
class Solution: def oddCells(self, m: int, n: int, indices: List[List[int]]) -&amp;gt; int: row = [0] * m col = [0] * n for r, c in indices: row[r] += 1 col[c] += 1 cnt1 = sum(v % 2 for v in row) cnt2 = sum(v % 2 for v in col) return cnt1 * (n - cnt2) + cnt2 * (m - cnt1)</description></item><item><title>1266. Minimum Time Visiting All Points</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1266/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1266/</guid><description>LeetCode problem 1266
class Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -&amp;gt; int: return sum( max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) for p1, p2 in pairwise(points) )</description></item><item><title>1271. Hexspeak</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1271/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1271/</guid><description>LeetCode problem 1271
class Solution: def toHexspeak(self, num: str) -&amp;gt; str: s = set(&amp;#39;ABCDEFIO&amp;#39;) t = hex(int(num))[2:].upper().replace(&amp;#39;0&amp;#39;, &amp;#39;O&amp;#39;).replace(&amp;#39;1&amp;#39;, &amp;#39;I&amp;#39;) return t if all(c in s for c in t) else &amp;#39;ERROR&amp;#39;</description></item><item><title>1275. Find Winner on a Tic Tac Toe Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1275/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1275/</guid><description>LeetCode problem 1275
class Solution: def tictactoe(self, moves: List[List[int]]) -&amp;gt; str: n = len(moves) cnt = [0] * 8 for k in range(n - 1, -1, -2): i, j = moves[k] cnt[i] += 1 cnt[j + 3] += 1 if i == j: cnt[6] += 1 if i + j == 2: cnt[7] += 1 if any(v == 3 for v in cnt): return &amp;#34;B&amp;#34; if k &amp;amp; 1 else &amp;#34;A&amp;#34; return &amp;#34;Draw&amp;#34; if n == 9 else &amp;#34;Pending&amp;#34;</description></item><item><title>1279. Traffic Light Controlled Intersection</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1279/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1279/</guid><description>LeetCode problem 1279
from threading import Lock class TrafficLight: def __init__(self): self.lock = Lock() self.road = 1 def carArrived( self, carId: int, # ID of the car # ID of the road the car travels on. Can be 1 (road A) or 2 (road B) roadId: int, direction: int, # Direction of the car # Use turnGreen() to turn light to green on current road turnGreen: &amp;#39;Callable[[], None]&amp;#39;, # Use crossCar() to make car cross the intersection crossCar: &amp;#39;Callable[[], None]&amp;#39;, ) -&amp;gt; None: self.</description></item><item><title>1281. Subtract the Product and Sum of Digits of an Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1281/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1281/</guid><description>LeetCode problem 1281
class Solution: def subtractProductAndSum(self, n: int) -&amp;gt; int: nums = list(map(int, str(n))) return prod(nums) - sum(nums)</description></item><item><title>1282. Group the People Given the Group Size They Belong To</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1282/</guid><description>LeetCode задача 1282
Задача Есть n человек, которые разделены на неизвестное количество групп. Каждому человеку присвоен уникальный ID от 0 до n - 1.
Дан массив целых чисел groupSizes, где groupSizes[i] — это размер группы, в которой находится человек i. Задача заключается в том, чтобы вернуть список групп таким образом, чтобы каждый человек i был в группе размером groupSizes[i].
Подход Основная идея решения заключается в использовании словаря для хранения временных групп, пока их размер не достигнет необходимого. Как только размер временной группы достигнет необходимого, добавьте ее в результат и начните новую группу с этим размером.</description></item><item><title>1290. Convert Binary Number in a Linked List to Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1290/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1290/</guid><description>LeetCode problem 1290
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def getDecimalValue(self, head: ListNode) -&amp;gt; int: res = 0 while head: res = res &amp;lt;&amp;lt; 1 | head.val head = head.next return res</description></item><item><title>1295. Find Numbers with Even Number of Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1295/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1295/</guid><description>LeetCode problem 1295
class Solution: def findNumbers(self, nums: List[int]) -&amp;gt; int: return sum(len(str(v)) % 2 == 0 for v in nums)</description></item><item><title>1299. Replace Elements with Greatest Element on Right Side</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1299/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1299/</guid><description>LeetCode problem 1299
class Solution: def replaceElements(self, arr: List[int]) -&amp;gt; List[int]: m = -1 for i in range(len(arr) - 1, -1, -1): t = arr[i] arr[i] = m m = max(m, t) return arr</description></item><item><title>1304. Find N Unique Integers Sum up to Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1304/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1304/</guid><description>LeetCode problem 1304
class Solution: def sumZero(self, n: int) -&amp;gt; List[int]: res = list(range(1, n)) res.append(-sum(res)) return res</description></item><item><title>1309. Decrypt String from Alphabet to Integer Mapping</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1309/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1309/</guid><description>LeetCode problem 1309
class Solution: def freqAlphabets(self, s: str) -&amp;gt; str: def get(s): return chr(ord(&amp;#39;a&amp;#39;) + int(s) - 1) i, n = 0, len(s) res = [] while i &amp;lt; n: if i + 2 &amp;lt; n and s[i + 2] == &amp;#39;#&amp;#39;: res.append(get(s[i : i + 2])) i += 3 else: res.append(get(s[i])) i += 1 return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1313. Decompress Run-Length Encoded List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1313/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1313/</guid><description>LeetCode problem 1313
class Solution: def decompressRLElist(self, nums: List[int]) -&amp;gt; List[int]: res = [] for i in range(1, len(nums), 2): res.extend([nums[i]] * nums[i - 1]) return res</description></item><item><title>1317. Convert Integer to the Sum of Two No-Zero Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1317/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1317/</guid><description>LeetCode problem 1317
class Solution: def getNoZeroIntegers(self, n: int) -&amp;gt; List[int]: def f(x): while x: if x % 10 == 0: return False x //= 10 return True for a in range(1, n): b = n - a if f(a) and f(b): return [a, b]</description></item><item><title>1331. Rank Transform of an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1331/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1331/</guid><description>LeetCode problem 1331
class Solution: def arrayRankTransform(self, arr: List[int]) -&amp;gt; List[int]: t = sorted(set(arr)) return [bisect_right(t, x) for x in arr]</description></item><item><title>1332. Remove Palindromic Subsequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1332/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1332/</guid><description>LeetCode problem 1332
class Solution: def removePalindromeSub(self, s: str) -&amp;gt; int: return 1 if s[::-1] == s else 2</description></item><item><title>1337. The K Weakest Rows in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1337/</guid><description>LeetCode problem 1337
class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&amp;gt; List[int]: m, n = len(mat), len(mat[0]) res = [n - bisect_right(row[::-1], 0) for row in mat] idx = list(range(m)) idx.sort(key=lambda i: res[i]) return idx[:k]</description></item><item><title>1342. Number of Steps to Reduce a Number to Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1342/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1342/</guid><description>LeetCode problem 1342
class Solution: def numberOfSteps(self, num: int) -&amp;gt; int: if num == 0: return 0 return 1 + ( self.numberOfSteps(num // 2) if num % 2 == 0 else self.numberOfSteps(num - 1) )</description></item><item><title>1346. Check If N and Its Double Exist</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1346/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1346/</guid><description>LeetCode problem 1346
class Solution: def checkIfExist(self, arr: List[int]) -&amp;gt; bool: if arr.count(0) &amp;gt; 1: return True arr.sort() n = len(arr) for v in arr: idx = bisect_left(arr, v * 2) if v != 0 and idx != n and arr[idx] == v * 2: return True return False</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1351/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1351/</guid><description>LeetCode problem 1351
class Solution: def countNegatives(self, grid: List[List[int]]) -&amp;gt; int: return sum(bisect_left(row[::-1], 0) for row in grid)</description></item><item><title>1359. Count All Valid Pickup and Delivery Options</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</link><pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1359/</guid><description>LeetCode задача 1359
Задача Дано n заказов, каждый заказ состоит из услуг по приему и доставке.
Необходимо подсчитать все возможные последовательности приема/доставки так, чтобы доставка(i) всегда шла после приема(i).
Так как ответ может быть очень большим, верните его по модулю 10^9 + 7.
Подсказки Использовать комбинаторный подход.
Для каждого нового заказа у нас есть 2 * (2n-1) способов добавить его в текущую последовательность.
Мы используем данную формулу, так как:
Новый заказ может быть вставлен на любое место среди существующих заказов (2n-1 мест).</description></item><item><title>1360. Number of Days Between Two Dates</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1360/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1360/</guid><description>LeetCode problem 1360
class Solution: def daysBetweenDates(self, date1: str, date2: str) -&amp;gt; int: def isLeapYear(year: int) -&amp;gt; bool: return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) def daysInMonth(year: int, month: int) -&amp;gt; int: days = [ 31, 28 + int(isLeapYear(year)), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, ] return days[month - 1] def calcDays(date: str) -&amp;gt; int: year, month, day = map(int, date.split(&amp;#34;-&amp;#34;)) days = 0 for y in range(1971, year): days += 365 + int(isLeapYear(y)) for m in range(1, month): days += daysInMonth(year, m) days += day return days return abs(calcDays(date1) - calcDays(date2))</description></item><item><title>1365. How Many Numbers Are Smaller Than the Current Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1365/</guid><description>LeetCode problem 1365
class Solution: def smallerNumbersThanCurrent(self, nums: List[int]) -&amp;gt; List[int]: cnt = [0] * 102 for x in nums: cnt[x + 1] += 1 s = list(accumulate(cnt)) return [s[x] for x in nums]</description></item><item><title>1370. Increasing Decreasing String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1370/</guid><description>LeetCode problem 1370
class Solution: def sortString(self, s: str) -&amp;gt; str: cnt = Counter(s) cs = ascii_lowercase + ascii_lowercase[::-1] res = [] while len(res) &amp;lt; len(s): for c in cs: if cnt[c]: res.append(c) cnt[c] -= 1 return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1372. Longest ZigZag Path in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1372/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1372/</guid><description>LeetCode задача 1372
Задача Найти самый длинный &amp;ldquo;ZigZag&amp;rdquo; путь в бинарном дереве. Путь &amp;ldquo;ZigZag&amp;rdquo; означает альтернативное движение влево и вправо при переходе от одного узла к другому.
Подсказки Используйте Depth-First Search (DFS) для решения задачи.
Подход DFS с состоянием: Запустите DFS с дополнительным аргументом, который будет отслеживать, в какую сторону нужно двигаться следующим (влево или вправо). Обновление максимума: На каждом уровне рекурсии проверьте, не превышает ли текущая длина пути максимальную известную длину. Рекурсивный вызов: Продолжайте движение в обоих направлениях, но учитывайте, что направление должно изменяться.</description></item><item><title>1374. Generate a String With Characters That Have Odd Counts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1374/</guid><description>LeetCode problem 1374
class Solution: def generateTheString(self, n: int) -&amp;gt; str: return &amp;#39;a&amp;#39; * n if n &amp;amp; 1 else &amp;#39;a&amp;#39; * (n - 1) + &amp;#39;b&amp;#39;</description></item><item><title>1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1379/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1379/</guid><description>LeetCode problem 1379
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def getTargetCopy( self, original: TreeNode, cloned: TreeNode, target: TreeNode ) -&amp;gt; TreeNode: def dfs(root1: TreeNode, root2: TreeNode) -&amp;gt; TreeNode: if root1 is None: return None if root1 == target: return root2 return dfs(root1.left, root2.left) or dfs(root1.right, root2.right) return dfs(original, cloned)</description></item><item><title>1380. Lucky Numbers in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1380/</guid><description>LeetCode problem 1380
class Solution: def luckyNumbers(self, matrix: List[List[int]]) -&amp;gt; List[int]: rows = {min(row) for row in matrix} cols = {max(col) for col in zip(*matrix)} return list(rows &amp;amp; cols)</description></item><item><title>1385. Find the Distance Value Between Two Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1385/</guid><description>LeetCode problem 1385
class Solution: def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -&amp;gt; int: def check(a: int) -&amp;gt; bool: i = bisect_left(arr2, a - d) return i == len(arr2) or arr2[i] &amp;gt; a + d arr2.sort() return sum(check(a) for a in arr1)</description></item><item><title>1389. Create Target Array in the Given Order</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1389/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1389/</guid><description>LeetCode problem 1389
class Solution: def createTargetArray(self, nums: List[int], index: List[int]) -&amp;gt; List[int]: target = [] for x, i in zip(nums, index): target.insert(i, x) return target</description></item><item><title>1394. Find Lucky Integer in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1394/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1394/</guid><description>LeetCode problem 1394
class Solution: def findLucky(self, arr: List[int]) -&amp;gt; int: cnt = Counter(arr) res = -1 for x, v in cnt.items(): if x == v and res &amp;lt; x: res = x return res</description></item><item><title>1399. Count Largest Group</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1399/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1399/</guid><description>LeetCode problem 1399
class Solution: def countLargestGroup(self, n: int) -&amp;gt; int: cnt = Counter() res = mx = 0 for i in range(1, n + 1): s = 0 while i: s += i % 10 i //= 10 cnt[s] += 1 if mx &amp;lt; cnt[s]: mx = cnt[s] res = 1 elif mx == cnt[s]: res += 1 return res</description></item><item><title>1403. Minimum Subsequence in Non-Increasing Order</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1403/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1403/</guid><description>LeetCode problem 1403
class Solution: def minSubsequence(self, nums: List[int]) -&amp;gt; List[int]: res = [] s, t = sum(nums), 0 for x in sorted(nums, reverse=True): t += x res.append(x) if t &amp;gt; s - t: break return res</description></item><item><title>1408. String Matching in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1408/</guid><description>LeetCode problem 1408
class Solution: def stringMatching(self, words: List[str]) -&amp;gt; List[str]: res = [] for i, s in enumerate(words): if any(i != j and s in t for j, t in enumerate(words)): res.append(s) return res</description></item><item><title>1413. Minimum Value to Get Positive Step by Step Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1413/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1413/</guid><description>LeetCode problem 1413
class Solution: def minStartValue(self, nums: List[int]) -&amp;gt; int: s = list(accumulate(nums)) return 1 if min(s) &amp;gt;= 0 else abs(min(s)) + 1</description></item><item><title>1417. Reformat The String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1417/</guid><description>LeetCode problem 1417
class Solution: def reformat(self, s: str) -&amp;gt; str: a = [c for c in s if c.islower()] b = [c for c in s if c.isdigit()] if abs(len(a) - len(b)) &amp;gt; 1: return &amp;#39;&amp;#39; if len(a) &amp;lt; len(b): a, b = b, a res = [] for x, y in zip(a, b): res.append(x + y) if len(a) &amp;gt; len(b): res.append(a[-1]) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1422. Maximum Score After Splitting a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1422/</guid><description>LeetCode problem 1422
class Solution: def maxScore(self, s: str) -&amp;gt; int: res = t = (s[0] == &amp;#39;0&amp;#39;) + s[1:].count(&amp;#39;1&amp;#39;) for i in range(1, len(s) - 1): t += 1 if s[i] == &amp;#39;0&amp;#39; else -1 res = max(res, t) return res</description></item><item><title>1426. Counting Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1426/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1426/</guid><description>LeetCode problem 1426
class Solution: def countElements(self, arr: List[int]) -&amp;gt; int: cnt = Counter(arr) return sum(v for x, v in cnt.items() if cnt[x + 1])</description></item><item><title>1427. Perform String Shifts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1427/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1427/</guid><description>LeetCode problem 1427
class Solution: def stringShift(self, s: str, shift: List[List[int]]) -&amp;gt; str: x = sum((b if a else -b) for a, b in shift) x %= len(s) return s[-x:] + s[:-x]</description></item><item><title>1436. Destination City</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1436/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1436/</guid><description>LeetCode problem 1436
class Solution: def destCity(self, paths: List[List[str]]) -&amp;gt; str: s = {a for a, _ in paths} return next(b for _, b in paths if b not in s)</description></item><item><title>1446. Consecutive Characters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1446/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1446/</guid><description>LeetCode problem 1446
class Solution: def maxPower(self, s: str) -&amp;gt; int: res = t = 1 for a, b in pairwise(s): if a == b: t += 1 res = max(res, t) else: t = 1 return res</description></item><item><title>1448. Count Good Nodes in Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1448/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1448/</guid><description>LeetCode задача 1448
Задача Дано бинарное дерево. Задача подсчитать количество &amp;ldquo;хороших&amp;rdquo; узлов. Узел считается &amp;ldquo;хорошим&amp;rdquo;, если на пути от корня дерева до этого узла (включительно) не встречается узлов с большим значением.
Подсказки &amp;ldquo;Хороший&amp;rdquo; узел в дереве — это узел, для которого все узлы на пути от корня до этого узла имеют значение не больше, чем значение этого узла.
Использовать метод обхода в глубину (DFS) для решения этой задачи.
Подход Идея решения задачи заключается в рекурсивном обходе дерева с сохранением максимального значения на пути от корня к текущему узлу.</description></item><item><title>1450. Number of Students Doing Homework at a Given Time</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1450/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1450/</guid><description>LeetCode problem 1450
class Solution: def busyStudent( self, startTime: List[int], endTime: List[int], queryTime: int ) -&amp;gt; int: c = [0] * 1010 for a, b in zip(startTime, endTime): c[a] += 1 c[b + 1] -= 1 return sum(c[: queryTime + 1])</description></item><item><title>1451. Rearrange Words in a Sentence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1451/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1451/</guid><description>LeetCode problem 1451
class Solution: def arrangeWords(self, text: str) -&amp;gt; str: words = text.split() words[0] = words[0].lower() words.sort(key=len) words[0] = words[0].title() return &amp;#34; &amp;#34;.join(words)</description></item><item><title>1452. People Whose List of Favorite Companies Is Not a Subset of Another List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1452/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1452/</guid><description>LeetCode problem 1452
class Solution: def peopleIndexes(self, favoriteCompanies: List[List[str]]) -&amp;gt; List[int]: d = {} idx = 0 t = [] for v in favoriteCompanies: for c in v: if c not in d: d[c] = idx idx += 1 t.append({d[c] for c in v}) res = [] for i, nums1 in enumerate(t): ok = True for j, nums2 in enumerate(t): if i == j: continue if not (nums1 - nums2): ok = False break if ok: res.append(i) return res</description></item><item><title>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1455/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1455/</guid><description>LeetCode problem 1455
class Solution: def isPrefixOfWord(self, sentence: str, searchWord: str) -&amp;gt; int: for i, s in enumerate(sentence.split(), 1): if s.startswith(searchWord): return i return -1</description></item><item><title>1457. Pseudo-Palindromic Paths in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1457/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1457/</guid><description>LeetCode problem 1457
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def pseudoPalindromicPaths(self, root: Optional[TreeNode]) -&amp;gt; int: def dfs(root: Optional[TreeNode], mask: int): if root is None: return 0 mask ^= 1 &amp;lt;&amp;lt; root.val if root.left is None and root.right is None: return int((mask &amp;amp; (mask - 1)) == 0) return dfs(root.left, mask) + dfs(root.right, mask) return dfs(root, 0)</description></item><item><title>1460. Make Two Arrays Equal by Reversing Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1460/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1460/</guid><description>LeetCode problem 1460
class Solution: def canBeEqual(self, target: List[int], arr: List[int]) -&amp;gt; bool: cnt = [0] * 1001 for a, b in zip(target, arr): cnt[a] += 1 cnt[b] -= 1 return all(v == 0 for v in cnt)</description></item><item><title>1461. Check If a String Contains All Binary Codes of Size K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1461/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1461/</guid><description>LeetCode problem 1461
class Solution: def hasAllCodes(self, s: str, k: int) -&amp;gt; bool: if len(s) - k + 1 &amp;lt; (1 &amp;lt;&amp;lt; k): return False vis = [False] * (1 &amp;lt;&amp;lt; k) num = int(s[:k], 2) vis[num] = True for i in range(k, len(s)): a = (ord(s[i - k]) - ord(&amp;#39;0&amp;#39;)) &amp;lt;&amp;lt; (k - 1) b = ord(s[i]) - ord(&amp;#39;0&amp;#39;) num = ((num - a) &amp;lt;&amp;lt; 1) + b vis[num] = True return all(v for v in vis)</description></item><item><title>1462. Course Schedule IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1462/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1462/</guid><description>LeetCode problem 1462
class Solution: def checkIfPrerequisite( self, n: int, prerequisites: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[bool]: f = [[False] * n for _ in range(n)] g = [[] for _ in range(n)] indeg = [0] * n for a, b in prerequisites: g[a].append(b) indeg[b] += 1 q = deque(i for i, x in enumerate(indeg) if x == 0) while q: i = q.popleft() for j in g[i]: f[i][j] = True for h in range(n): f[h][j] = f[h][j] or f[h][i] indeg[j] -= 1 if indeg[j] == 0: q.</description></item><item><title>1464. Maximum Product of Two Elements in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1464/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1464/</guid><description>LeetCode problem 1464
class Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: a = b = 0 for v in nums: if v &amp;gt; a: a, b = v, a elif v &amp;gt; b: b = v return (a - 1) * (b - 1)</description></item><item><title>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1465/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1465/</guid><description>LeetCode problem 1465
class Solution: def maxArea( self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int] ) -&amp;gt; int: horizontalCuts.extend([0, h]) verticalCuts.extend([0, w]) horizontalCuts.sort() verticalCuts.sort() x = max(b - a for a, b in pairwise(horizontalCuts)) y = max(b - a for a, b in pairwise(verticalCuts)) return (x * y) % (10**9 + 7)</description></item><item><title>1466. Reorder Routes to Make All Paths Lead to the City Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1466/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1466/</guid><description>LeetCode problem 1466
class Solution: def minReorder(self, n: int, connections: List[List[int]]) -&amp;gt; int: def dfs(a: int, fa: int) -&amp;gt; int: return sum(c + dfs(b, a) for b, c in g[a] if b != fa) g = [[] for _ in range(n)] for a, b in connections: g[a].append((b, 1)) g[b].append((a, 0)) return dfs(0, -1)</description></item><item><title>1469. Find All The Lonely Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1469/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1469/</guid><description>LeetCode problem 1469
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getLonelyNodes(self, root: Optional[TreeNode]) -&amp;gt; List[int]: def dfs(root): if root is None or (root.left is None and root.right is None): return if root.left is None: res.append(root.right.val) if root.right is None: res.append(root.left.val) dfs(root.left) dfs(root.right) res = [] dfs(root) return res</description></item><item><title>1470. Shuffle the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1470/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1470/</guid><description>LeetCode problem 1470
class Solution: def shuffle(self, nums: List[int], n: int) -&amp;gt; List[int]: nums[::2], nums[1::2] = nums[:n], nums[n:] return nums</description></item><item><title>1471. The k Strongest Values in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1471/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1471/</guid><description>LeetCode problem 1471
class Solution: def getStrongest(self, arr: List[int], k: int) -&amp;gt; List[int]: arr.sort() m = arr[(len(arr) - 1) &amp;gt;&amp;gt; 1] arr.sort(key=lambda x: (-abs(x - m), -x)) return arr[:k]</description></item><item><title>1472. Design Browser History</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1472/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1472/</guid><description>LeetCode problem 1472
class BrowserHistory: def __init__(self, homepage: str): self.stk1 = [] self.stk2 = [] self.visit(homepage) def visit(self, url: str) -&amp;gt; None: self.stk1.append(url) self.stk2.clear() def back(self, steps: int) -&amp;gt; str: while steps and len(self.stk1) &amp;gt; 1: self.stk2.append(self.stk1.pop()) steps -= 1 return self.stk1[-1] def forward(self, steps: int) -&amp;gt; str: while steps and self.stk2: self.stk1.append(self.stk2.pop()) steps -= 1 return self.stk1[-1] # Your BrowserHistory object will be instantiated and called as such: # obj = BrowserHistory(homepage) # obj.visit(url) # param_2 = obj.</description></item><item><title>1474. Delete N Nodes After M Nodes of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1474/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1474/</guid><description>LeetCode problem 1474
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteNodes(self, head: ListNode, m: int, n: int) -&amp;gt; ListNode: pre = head while pre: for _ in range(m - 1): if pre: pre = pre.next if pre is None: return head cur = pre for _ in range(n): if cur: cur = cur.next pre.next = None if cur is None else cur.</description></item><item><title>1475. Final Prices With a Special Discount in a Shop</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1475/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1475/</guid><description>LeetCode problem 1475
class Solution: def finalPrices(self, prices: List[int]) -&amp;gt; List[int]: stk = [] res = prices[:] for i in range(len(prices) - 1, -1, -1): while stk and prices[stk[-1]] &amp;gt; prices[i]: stk.pop() if stk: res[i] -= prices[stk[-1]] stk.append(i) return res</description></item><item><title>1476. Subrectangle Queries</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1476/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1476/</guid><description>LeetCode problem 1476
class SubrectangleQueries: def __init__(self, rectangle: List[List[int]]): self.g = rectangle self.ops = [] def updateSubrectangle( self, row1: int, col1: int, row2: int, col2: int, newValue: int ) -&amp;gt; None: self.ops.append((row1, col1, row2, col2, newValue)) def getValue(self, row: int, col: int) -&amp;gt; int: for r1, c1, r2, c2, v in self.ops[::-1]: if r1 &amp;lt;= row &amp;lt;= r2 and c1 &amp;lt;= col &amp;lt;= c2: return v return self.g[row][col] # Your SubrectangleQueries object will be instantiated and called as such: # obj = SubrectangleQueries(rectangle) # obj.</description></item><item><title>1477. Find Two Non-overlapping Sub-arrays Each With Target Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1477/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1477/</guid><description>LeetCode problem 1477
class Solution: def minSumOfLengths(self, arr: List[int], target: int) -&amp;gt; int: d = {0: 0} s, n = 0, len(arr) f = [inf] * (n + 1) res = inf for i, v in enumerate(arr, 1): s += v f[i] = f[i - 1] if s - target in d: j = d[s - target] f[i] = min(f[i], i - j) res = min(res, f[j] + i - j) d[s] = i return -1 if res &amp;gt; n else res</description></item><item><title>1481. Least Number of Unique Integers after K Removals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1481/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1481/</guid><description>LeetCode problem 1481
class Solution: def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -&amp;gt; int: cnt = Counter(arr) for i, v in enumerate(sorted(cnt.values())): k -= v if k &amp;lt; 0: return len(cnt) - i return 0</description></item><item><title>1482. Minimum Number of Days to Make m Bouquets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1482/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1482/</guid><description>LeetCode problem 1482
class Solution: def minDays(self, bloomDay: List[int], m: int, k: int) -&amp;gt; int: if m * k &amp;gt; len(bloomDay): return -1 def check(day: int) -&amp;gt; bool: cnt = cur = 0 for bd in bloomDay: cur = cur + 1 if bd &amp;lt;= day else 0 if cur == k: cnt += 1 cur = 0 return cnt &amp;gt;= m left, right = min(bloomDay), max(bloomDay) while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if check(mid): right = mid else: left = mid + 1 return left</description></item><item><title>1485. Clone Binary Tree With Random Pointer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1485/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1485/</guid><description>LeetCode problem 1485
# Definition for Node. # class Node: # def __init__(self, val=0, left=None, right=None, random=None): # self.val = val # self.left = left # self.right = right # self.random = random class Solution: def copyRandomBinaryTree(self, root: &amp;#39;Optional[Node]&amp;#39;) -&amp;gt; &amp;#39;Optional[NodeCopy]&amp;#39;: def dfs(root): if root is None: return None if root in mp: return mp[root] copy = NodeCopy(root.val) mp[root] = copy copy.left = dfs(root.left) copy.right = dfs(root.right) copy.random = dfs(root.random) return copy mp = {} return dfs(root)</description></item><item><title>1486. XOR Operation in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1486/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1486/</guid><description>LeetCode problem 1486
class Solution: def xorOperation(self, n: int, start: int) -&amp;gt; int: return reduce(xor, ((start + 2 * i) for i in range(n)))</description></item><item><title>1487. Making File Names Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1487/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1487/</guid><description>LeetCode problem 1487
class Solution: def getFolderNames(self, names: List[str]) -&amp;gt; List[str]: d = defaultdict(int) for i, name in enumerate(names): if name in d: k = d[name] while f&amp;#39;{name}({k})&amp;#39; in d: k += 1 d[name] = k + 1 names[i] = f&amp;#39;{name}({k})&amp;#39; d[names[i]] = 1 return names</description></item><item><title>1488. Avoid Flood in The City</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1488/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1488/</guid><description>LeetCode problem 1488
from sortedcontainers import SortedList class Solution: def avoidFlood(self, rains: List[int]) -&amp;gt; List[int]: n = len(rains) res = [-1] * n sunny = SortedList() rainy = {} for i, v in enumerate(rains): if v: if v in rainy: idx = sunny.bisect_right(rainy[v]) if idx == len(sunny): return [] res[sunny[idx]] = v sunny.discard(sunny[idx]) rainy[v] = i else: sunny.add(i) res[i] = 1 return res</description></item><item><title>1490. Clone N-ary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1490/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1490/</guid><description>LeetCode problem 1490
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] &amp;#34;&amp;#34;&amp;#34; class Solution: def cloneTree(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; &amp;#39;Node&amp;#39;: if root is None: return None children = [self.cloneTree(child) for child in root.children] return Node(root.val, children)</description></item><item><title>1491. Average Salary Excluding the Minimum and Maximum Salary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1491/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1491/</guid><description>LeetCode problem 1491
class Solution: def average(self, salary: List[int]) -&amp;gt; float: s = sum(salary) - min(salary) - max(salary) return s / (len(salary) - 2)</description></item><item><title>1492. The kth Factor of n</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1492/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1492/</guid><description>LeetCode problem 1492
class Solution: def kthFactor(self, n: int, k: int) -&amp;gt; int: i = 1 while i * i &amp;lt; n: if n % i == 0: k -= 1 if k == 0: return i i += 1 if i * i != n: i -= 1 while i: if (n % (n // i)) == 0: k -= 1 if k == 0: return n // i i -= 1 return -1</description></item><item><title>1496. Path Crossing</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1496/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1496/</guid><description>LeetCode problem 1496
class Solution: def isPathCrossing(self, path: str) -&amp;gt; bool: i = j = 0 vis = {(0, 0)} for c in path: match c: case &amp;#39;N&amp;#39;: i -= 1 case &amp;#39;S&amp;#39;: i += 1 case &amp;#39;E&amp;#39;: j += 1 case &amp;#39;W&amp;#39;: j -= 1 if (i, j) in vis: return True vis.add((i, j)) return False</description></item><item><title>1497. Check If Array Pairs Are Divisible by k</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1497/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1497/</guid><description>LeetCode problem 1497
class Solution: def canArrange(self, arr: List[int], k: int) -&amp;gt; bool: cnt = Counter(x % k for x in arr) return cnt[0] % 2 == 0 and all(cnt[i] == cnt[k - i] for i in range(1, k))</description></item><item><title>1498. Number of Subsequences That Satisfy the Given Sum Condition</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1498/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1498/</guid><description>LeetCode problem 1498
class Solution: def numSubseq(self, nums: List[int], target: int) -&amp;gt; int: mod = 10**9 + 7 nums.sort() n = len(nums) f = [1] + [0] * n for i in range(1, n + 1): f[i] = f[i - 1] * 2 % mod res = 0 for i, x in enumerate(nums): if x * 2 &amp;gt; target: break j = bisect_right(nums, target - x, i + 1) - 1 res = (res + f[j - i]) % mod return res</description></item><item><title>1500. Design a File Sharing System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1500/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1500/</guid><description>LeetCode problem 1500
class FileSharing: def __init__(self, m: int): self.cur = 0 self.chunks = m self.reused = [] self.user_chunks = defaultdict(set) def join(self, ownedChunks: List[int]) -&amp;gt; int: if self.reused: userID = heappop(self.reused) else: self.cur += 1 userID = self.cur self.user_chunks[userID] = set(ownedChunks) return userID def leave(self, userID: int) -&amp;gt; None: heappush(self.reused, userID) self.user_chunks.pop(userID) def request(self, userID: int, chunkID: int) -&amp;gt; List[int]: if chunkID &amp;lt; 1 or chunkID &amp;gt; self.chunks: return [] res = [] for k, v in self.</description></item><item><title>1502. Can Make Arithmetic Progression From Sequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1502/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1502/</guid><description>LeetCode problem 1502
class Solution: def canMakeArithmeticProgression(self, arr: List[int]) -&amp;gt; bool: a = min(arr) b = max(arr) n = len(arr) if (b - a) % (n - 1): return False d = (b - a) // (n - 1) s = set(arr) return all(a + d * i in s for i in range(n))</description></item><item><title>1503. Last Moment Before All Ants Fall Out of a Plank</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1503/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1503/</guid><description>LeetCode problem 1503
class Solution: def getLastMoment(self, n: int, left: List[int], right: List[int]) -&amp;gt; int: res = 0 for x in left: res = max(res, x) for x in right: res = max(res, n - x) return res</description></item><item><title>1504. Count Submatrices With All Ones</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1504/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1504/</guid><description>LeetCode problem 1504
class Solution: def numSubmat(self, mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) g = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if mat[i][j]: g[i][j] = 1 if j == 0 else 1 + g[i][j - 1] res = 0 for i in range(m): for j in range(n): col = inf for k in range(i, -1, -1): col = min(col, g[k][j]) res += col return res</description></item><item><title>1506. Find Root of N-Ary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1506/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1506/</guid><description>LeetCode problem 1506
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] &amp;#34;&amp;#34;&amp;#34; class Solution: def findRoot(self, tree: List[&amp;#39;Node&amp;#39;]) -&amp;gt; &amp;#39;Node&amp;#39;: x = 0 for node in tree: x ^= node.val for child in node.children: x ^= child.val return next(node for node in tree if node.val == x)</description></item><item><title>1507. Reformat Date</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1507/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1507/</guid><description>LeetCode problem 1507
class Solution: def reformatDate(self, date: str) -&amp;gt; str: s = date.split() s.reverse() months = &amp;#34; JanFebMarAprMayJunJulAugSepOctNovDec&amp;#34; s[1] = str(months.index(s[1]) // 3 + 1).zfill(2) s[2] = s[2][:-2].zfill(2) return &amp;#34;-&amp;#34;.join(s)</description></item><item><title>1508. Range Sum of Sorted Subarray Sums</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1508/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1508/</guid><description>LeetCode problem 1508
class Solution: def rangeSum(self, nums: List[int], n: int, left: int, right: int) -&amp;gt; int: arr = [] for i in range(n): s = 0 for j in range(i, n): s += nums[j] arr.append(s) arr.sort() mod = 10**9 + 7 return sum(arr[left - 1 : right]) % mod</description></item><item><title>1509. Minimum Difference Between Largest and Smallest Value in Three Moves</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1509/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1509/</guid><description>LeetCode problem 1509
class Solution: def minDifference(self, nums: List[int]) -&amp;gt; int: n = len(nums) if n &amp;lt; 5: return 0 nums.sort() res = inf for l in range(4): r = 3 - l res = min(res, nums[n - 1 - r] - nums[l]) return res</description></item><item><title>1512. Number of Good Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1512/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1512/</guid><description>LeetCode problem 1512
class Solution: def numIdenticalPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) return sum(v * (v - 1) for v in cnt.values()) &amp;gt;&amp;gt; 1</description></item><item><title>1514. Path with Maximum Probability</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1514/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1514/</guid><description>LeetCode problem 1514
class Solution: def maxProbability( self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int, ) -&amp;gt; float: g = defaultdict(list) for (a, b), s in zip(edges, succProb): g[a].append((b, s)) g[b].append((a, s)) d = [0] * n vis = [False] * n d[start] = 1 q = deque([start]) vis[start] = True while q: i = q.popleft() vis[i] = False for j, s in g[i]: if d[j] &amp;lt; d[i] * s: d[j] = d[i] * s if not vis[j]: q.</description></item><item><title>1518. Water Bottles</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1518/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1518/</guid><description>LeetCode problem 1518
class Solution: def numWaterBottles(self, numBottles: int, numExchange: int) -&amp;gt; int: res = numBottles while numBottles &amp;gt;= numExchange: numBottles -= numExchange - 1 res += 1 return res</description></item><item><title>1519. Number of Nodes in the Sub-Tree With the Same Label</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1519/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1519/</guid><description>LeetCode problem 1519
class Solution: def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -&amp;gt; List[int]: def dfs(i, fa): res[i] -= cnt[labels[i]] cnt[labels[i]] += 1 for j in g[i]: if j != fa: dfs(j, i) res[i] += cnt[labels[i]] g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) cnt = Counter() res = [0] * n dfs(0, -1) return res</description></item><item><title>1522. Diameter of N-Ary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1522/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1522/</guid><description>LeetCode problem 1522
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] &amp;#34;&amp;#34;&amp;#34; class Solution: def diameter(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; int: &amp;#34;&amp;#34;&amp;#34; :type root: &amp;#39;Node&amp;#39; :rtype: int &amp;#34;&amp;#34;&amp;#34; def build(root): nonlocal d if root is None: return for child in root.children: d[root].add(child) d[child].add(root) build(child) def dfs(u, t): nonlocal res, vis, d, next if u in vis: return vis.add(u) for v in d[u]: dfs(v, t + 1) if res &amp;lt; t: res = t next = u d = defaultdict(set) vis = set() build(root) res = 0 next = None dfs(root, 0) vis.</description></item><item><title>1523. Count Odd Numbers in an Interval Range</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1523/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1523/</guid><description>LeetCode problem 1523
class Solution: def countOdds(self, low: int, high: int) -&amp;gt; int: return ((high + 1) &amp;gt;&amp;gt; 1) - (low &amp;gt;&amp;gt; 1)</description></item><item><title>1524. Number of Sub-arrays With Odd Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1524/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1524/</guid><description>LeetCode problem 1524
class Solution: def numOfSubarrays(self, arr: List[int]) -&amp;gt; int: mod = 10**9 + 7 cnt = [1, 0] res = s = 0 for x in arr: s += x res = (res + cnt[s &amp;amp; 1 ^ 1]) % mod cnt[s &amp;amp; 1] += 1 return res</description></item><item><title>1525. Number of Good Ways to Split a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1525/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1525/</guid><description>LeetCode problem 1525
class Solution: def numSplits(self, s: str) -&amp;gt; int: cnt = Counter(s) vis = set() res = 0 for c in s: vis.add(c) cnt[c] -= 1 if cnt[c] == 0: cnt.pop(c) res += len(vis) == len(cnt) return res</description></item><item><title>1528. Shuffle String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1528/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1528/</guid><description>LeetCode problem 1528
class Solution: def restoreString(self, s: str, indices: List[int]) -&amp;gt; str: res = [0] * len(s) for i, c in enumerate(s): res[indices[i]] = c return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1529. Minimum Suffix Flips</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1529/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1529/</guid><description>LeetCode problem 1529
class Solution: def minFlips(self, target: str) -&amp;gt; int: res = 0 for v in target: if (res &amp;amp; 1) ^ int(v): res += 1 return res</description></item><item><title>1530. Number of Good Leaf Nodes Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1530/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1530/</guid><description>LeetCode problem 1530
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def countPairs(self, root: TreeNode, distance: int) -&amp;gt; int: def dfs(root, cnt, i): if root is None or i &amp;gt;= distance: return if root.left is None and root.right is None: cnt[i] += 1 return dfs(root.left, cnt, i + 1) dfs(root.right, cnt, i + 1) if root is None: return 0 res = self.</description></item><item><title>1533. Find the Index of the Large Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1533/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1533/</guid><description>LeetCode problem 1533
# &amp;#34;&amp;#34;&amp;#34; # This is ArrayReader&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class ArrayReader(object): # # Compares the sum of arr[l..r] with the sum of arr[x..y] # # return 1 if sum(arr[l..r]) &amp;gt; sum(arr[x..y]) # # return 0 if sum(arr[l..r]) == sum(arr[x..y]) # # return -1 if sum(arr[l..r]) &amp;lt; sum(arr[x..y]) # def compareSub(self, l: int, r: int, x: int, y: int) -&amp;gt; int: # # # Returns the length of the array # def length(self) -&amp;gt; int: # class Solution: def getIndex(self, reader: &amp;#39;ArrayReader&amp;#39;) -&amp;gt; int: left, right = 0, reader.</description></item><item><title>1534. Count Good Triplets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1534/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1534/</guid><description>LeetCode problem 1534
class Solution: def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -&amp;gt; int: res, n = 0, len(arr) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): res += ( abs(arr[i] - arr[j]) &amp;lt;= a and abs(arr[j] - arr[k]) &amp;lt;= b and abs(arr[i] - arr[k]) &amp;lt;= c ) return res</description></item><item><title>1535. Find the Winner of an Array Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1535/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1535/</guid><description>LeetCode problem 1535
class Solution: def getWinner(self, arr: List[int], k: int) -&amp;gt; int: mx = arr[0] cnt = 0 for x in arr[1:]: if mx &amp;lt; x: mx = x cnt = 1 else: cnt += 1 if cnt == k: break return mx</description></item><item><title>1536. Minimum Swaps to Arrange a Binary Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1536/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1536/</guid><description>LeetCode problem 1536
class Solution: def minSwaps(self, grid: List[List[int]]) -&amp;gt; int: n = len(grid) pos = [-1] * n for i in range(n): for j in range(n - 1, -1, -1): if grid[i][j] == 1: pos[i] = j break res = 0 for i in range(n): k = -1 for j in range(i, n): if pos[j] &amp;lt;= i: res += j - i k = j break if k == -1: return -1 while k &amp;gt; i: pos[k], pos[k - 1] = pos[k - 1], pos[k] k -= 1 return res</description></item><item><title>1538. Guess the Majority in a Hidden Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1538/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1538/</guid><description>LeetCode problem 1538
# &amp;#34;&amp;#34;&amp;#34; # This is the ArrayReader&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class ArrayReader(object): # # Compares 4 different elements in the array # # return 4 if the values of the 4 elements are the same (0 or 1). # # return 2 if three elements have a value equal to 0 and one element has value equal to 1 or vice versa. # # return 0 : if two element have a value equal to 0 and two elements have a value equal to 1.</description></item><item><title>1539. Kth Missing Positive Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1539/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1539/</guid><description>LeetCode problem 1539
class Solution: def findKthPositive(self, arr: List[int], k: int) -&amp;gt; int: if arr[0] &amp;gt; k: return k left, right = 0, len(arr) while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if arr[mid] - mid - 1 &amp;gt;= k: right = mid else: left = mid + 1 return arr[left - 1] + k - (arr[left - 1] - (left - 1) - 1)</description></item><item><title>1540. Can Convert String in K Moves</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1540/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1540/</guid><description>LeetCode problem 1540
class Solution: def canConvertString(self, s: str, t: str, k: int) -&amp;gt; bool: if len(s) != len(t): return False cnt = [0] * 26 for a, b in zip(s, t): x = (ord(b) - ord(a) + 26) % 26 cnt[x] += 1 for i in range(1, 26): if i + 26 * (cnt[i] - 1) &amp;gt; k: return False return True</description></item><item><title>1541. Minimum Insertions to Balance a Parentheses String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1541/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1541/</guid><description>LeetCode problem 1541
class Solution: def minInsertions(self, s: str) -&amp;gt; int: res = x = 0 i, n = 0, len(s) while i &amp;lt; n: if s[i] == &amp;#39;(&amp;#39;: # 待匹配的左括号加 1 x += 1 else: if i &amp;lt; n - 1 and s[i + 1] == &amp;#39;)&amp;#39;: # 有连续两个右括号，i 往后移动 i += 1 else: # 只有一个右括号，插入一个 res += 1 if x == 0: # 无待匹配的左括号，插入一个 res += 1 else: # 待匹配的左括号减 1 x -= 1 i += 1 # 遍历结束，仍有待匹配的左括号，说明右括号不足，插入 x &amp;lt;&amp;lt; 1 个 res += x &amp;lt;&amp;lt; 1 return res</description></item><item><title>1544. Make The String Great</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1544/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1544/</guid><description>LeetCode problem 1544
class Solution: def makeGood(self, s: str) -&amp;gt; str: stk = [] for c in s: if not stk or abs(ord(stk[-1]) - ord(c)) != 32: stk.append(c) else: stk.pop() return &amp;#34;&amp;#34;.join(stk)</description></item><item><title>1545. Find Kth Bit in Nth Binary String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1545/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1545/</guid><description>LeetCode problem 1545
class Solution: def findKthBit(self, n: int, k: int) -&amp;gt; str: def dfs(n: int, k: int) -&amp;gt; int: if k == 1: return 0 if (k &amp;amp; (k - 1)) == 0: return 1 m = 1 &amp;lt;&amp;lt; n if k * 2 &amp;lt; m - 1: return dfs(n - 1, k) return dfs(n - 1, m - k) ^ 1 return str(dfs(n, k))</description></item><item><title>1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1546/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1546/</guid><description>LeetCode problem 1546
class Solution: def maxNonOverlapping(self, nums: List[int], target: int) -&amp;gt; int: res = 0 i, n = 0, len(nums) while i &amp;lt; n: s = 0 vis = {0} while i &amp;lt; n: s += nums[i] if s - target in vis: res += 1 break i += 1 vis.add(s) i += 1 return res</description></item><item><title>1550. Three Consecutive Odds</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1550/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1550/</guid><description>LeetCode problem 1550
class Solution: def threeConsecutiveOdds(self, arr: List[int]) -&amp;gt; bool: for i in range(len(arr) - 2): if arr[i] % 2 + arr[i + 1] % 2 + arr[i + 2] % 2 == 3: return True return False</description></item><item><title>1551. Minimum Operations to Make Array Equal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1551/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1551/</guid><description>LeetCode problem 1551
class Solution: def minOperations(self, n: int) -&amp;gt; int: return sum(n - (i &amp;lt;&amp;lt; 1 | 1) for i in range(n &amp;gt;&amp;gt; 1))</description></item><item><title>1552. Magnetic Force Between Two Balls</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1552/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1552/</guid><description>LeetCode problem 1552
class Solution: def maxDistance(self, position: List[int], m: int) -&amp;gt; int: def check(f): prev = position[0] cnt = 1 for curr in position[1:]: if curr - prev &amp;gt;= f: prev = curr cnt += 1 return cnt &amp;gt;= m position.sort() left, right = 1, position[-1] while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if check(mid): left = mid else: right = mid - 1 return left</description></item><item><title>1554. Strings Differ by One Character</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1554/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1554/</guid><description>LeetCode problem 1554
class Solution: def differByOne(self, dict: List[str]) -&amp;gt; bool: s = set() for word in dict: for i in range(len(word)): t = word[:i] + &amp;#34;*&amp;#34; + word[i + 1 :] if t in s: return True s.add(t) return False</description></item><item><title>1556. Thousand Separator</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1556/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1556/</guid><description>LeetCode problem 1556
class Solution: def thousandSeparator(self, n: int) -&amp;gt; str: cnt = 0 res = [] while 1: n, v = divmod(n, 10) res.append(str(v)) cnt += 1 if n == 0: break if cnt == 3: res.append(&amp;#39;.&amp;#39;) cnt = 0 return &amp;#39;&amp;#39;.join(res[::-1])</description></item><item><title>1557. Minimum Number of Vertices to Reach All Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1557/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1557/</guid><description>LeetCode problem 1557
class Solution: def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: cnt = Counter(t for _, t in edges) return [i for i in range(n) if cnt[i] == 0]</description></item><item><title>1558. Minimum Numbers of Function Calls to Make Target Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1558/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1558/</guid><description>LeetCode problem 1558
class Solution: def minOperations(self, nums: List[int]) -&amp;gt; int: return sum(v.bit_count() for v in nums) + max(0, max(nums).bit_length() - 1)</description></item><item><title>1560. Most Visited Sector in a Circular Track</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1560/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1560/</guid><description>LeetCode problem 1560
class Solution: def mostVisited(self, n: int, rounds: List[int]) -&amp;gt; List[int]: if rounds[0] &amp;lt;= rounds[-1]: return list(range(rounds[0], rounds[-1] + 1)) return list(range(1, rounds[-1] + 1)) + list(range(rounds[0], n + 1))</description></item><item><title>1561. Maximum Number of Coins You Can Get</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1561/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1561/</guid><description>LeetCode problem 1561
class Solution: def maxCoins(self, piles: List[int]) -&amp;gt; int: piles.sort() return sum(piles[-2 : len(piles) // 3 - 1 : -2])</description></item><item><title>1562. Find Latest Group of Size M</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1562/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1562/</guid><description>LeetCode problem 1562
class Solution: def findLatestStep(self, arr: List[int], m: int) -&amp;gt; int: n = len(arr) if m == n: return n cnt = [0] * (n + 2) res = -1 for i, v in enumerate(arr): v -= 1 l, r = cnt[v - 1], cnt[v + 1] if l == m or r == m: res = i cnt[v - l] = cnt[v + r] = l + r + 1 return res</description></item><item><title>1564. Put Boxes Into the Warehouse I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1564/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1564/</guid><description>LeetCode problem 1564
class Solution: def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -&amp;gt; int: n = len(warehouse) left = [warehouse[0]] * n for i in range(1, n): left[i] = min(left[i - 1], warehouse[i]) boxes.sort() i, j = 0, n - 1 while i &amp;lt; len(boxes): while j &amp;gt;= 0 and left[j] &amp;lt; boxes[i]: j -= 1 if j &amp;lt; 0: break i, j = i + 1, j - 1 return i</description></item><item><title>1566. Detect Pattern of Length M Repeated K or More Times</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1566/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1566/</guid><description>LeetCode problem 1566
class Solution: def containsPattern(self, arr: List[int], m: int, k: int) -&amp;gt; bool: n = len(arr) for i in range(n - m * k + 1): j = 0 while j &amp;lt; m * k: if arr[i + j] != arr[i + (j % m)]: break j += 1 if j == m * k: return True return False</description></item><item><title>1567. Maximum Length of Subarray With Positive Product</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1567/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1567/</guid><description>LeetCode problem 1567
class Solution: def getMaxLen(self, nums: List[int]) -&amp;gt; int: f1 = 1 if nums[0] &amp;gt; 0 else 0 f2 = 1 if nums[0] &amp;lt; 0 else 0 res = f1 for num in nums[1:]: pf1, pf2 = f1, f2 if num &amp;gt; 0: f1 += 1 if f2 &amp;gt; 0: f2 += 1 else: f2 = 0 elif num &amp;lt; 0: pf1, pf2 = f1, f2 f2 = pf1 + 1 if pf2 &amp;gt; 0: f1 = pf2 + 1 else: f1 = 0 else: f1 = 0 f2 = 0 res = max(res, f1) return res</description></item><item><title>1570. Dot Product of Two Sparse Vectors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1570/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1570/</guid><description>LeetCode problem 1570
class SparseVector: def __init__(self, nums: List[int]): self.d = {i: v for i, v in enumerate(nums) if v} # Return the dotProduct of two sparse vectors def dotProduct(self, vec: &amp;#34;SparseVector&amp;#34;) -&amp;gt; int: a, b = self.d, vec.d if len(b) &amp;lt; len(a): a, b = b, a return sum(v * b.get(i, 0) for i, v in a.items()) # Your SparseVector object will be instantiated and called as such: # v1 = SparseVector(nums1) # v2 = SparseVector(nums2) # res = v1.</description></item><item><title>1572. Matrix Diagonal Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1572/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1572/</guid><description>LeetCode problem 1572
class Solution: def diagonalSum(self, mat: List[List[int]]) -&amp;gt; int: res = 0 n = len(mat) for i, row in enumerate(mat): j = n - i - 1 res += row[i] + (0 if j == i else row[j]) return res</description></item><item><title>1573. Number of Ways to Split a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1573/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1573/</guid><description>LeetCode problem 1573
class Solution: def numWays(self, s: str) -&amp;gt; int: def find(x): t = 0 for i, c in enumerate(s): t += int(c == &amp;#39;1&amp;#39;) if t == x: return i cnt, m = divmod(sum(c == &amp;#39;1&amp;#39; for c in s), 3) if m: return 0 n = len(s) mod = 10**9 + 7 if cnt == 0: return ((n - 1) * (n - 2) // 2) % mod i1, i2 = find(cnt), find(cnt + 1) j1, j2 = find(cnt * 2), find(cnt * 2 + 1) return (i2 - i1) * (j2 - j1) % (10**9 + 7)</description></item><item><title>1574. Shortest Subarray to be Removed to Make Array Sorted</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1574/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1574/</guid><description>LeetCode problem 1574
class Solution: def findLengthOfShortestSubarray(self, arr: List[int]) -&amp;gt; int: n = len(arr) i, j = 0, n - 1 while i + 1 &amp;lt; n and arr[i] &amp;lt;= arr[i + 1]: i += 1 while j - 1 &amp;gt;= 0 and arr[j - 1] &amp;lt;= arr[j]: j -= 1 if i &amp;gt;= j: return 0 res = min(n - i - 1, j) r = j for l in range(i + 1): while r &amp;lt; n and arr[r] &amp;lt; arr[l]: r += 1 res = min(res, r - l - 1) return res</description></item><item><title>1576. Replace All 's to Avoid Consecutive Repeating Characters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1576/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1576/</guid><description>LeetCode problem 1576
class Solution: def modifyString(self, s: str) -&amp;gt; str: s = list(s) n = len(s) for i in range(n): if s[i] == &amp;#34;?&amp;#34;: for c in &amp;#34;abc&amp;#34;: if (i and s[i - 1] == c) or (i + 1 &amp;lt; n and s[i + 1] == c): continue s[i] = c break return &amp;#34;&amp;#34;.join(s)</description></item><item><title>1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1577/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1577/</guid><description>LeetCode problem 1577
class Solution: def numTriplets(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: cnt1 = Counter(nums1) cnt2 = Counter(nums2) res = 0 for a, x in cnt1.items(): for b, y in cnt2.items(): if a * a % b == 0: c = a * a // b if b == c: res += x * y * (y - 1) else: res += x * y * cnt2[c] if b * b % a == 0: c = b * b // a if a == c: res += x * (x - 1) * y else: res += x * y * cnt1[c] return res &amp;gt;&amp;gt; 1</description></item><item><title>1578. Minimum Time to Make Rope Colorful</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1578/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1578/</guid><description>LeetCode problem 1578
class Solution: def minCost(self, colors: str, neededTime: List[int]) -&amp;gt; int: res = i = 0 n = len(colors) while i &amp;lt; n: j = i s = mx = 0 while j &amp;lt; n and colors[j] == colors[i]: s += neededTime[j] if mx &amp;lt; neededTime[j]: mx = neededTime[j] j += 1 if j - i &amp;gt; 1: res += s - mx i = j return res</description></item><item><title>1580. Put Boxes Into the Warehouse II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1580/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1580/</guid><description>LeetCode problem 1580
class Solution: def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -&amp;gt; int: n = len(warehouse) left = [0] * n right = [0] * n left[0] = right[-1] = inf for i in range(1, n): left[i] = min(left[i - 1], warehouse[i - 1]) for i in range(n - 2, -1, -1): right[i] = min(right[i + 1], warehouse[i + 1]) for i in range(n): warehouse[i] = min(warehouse[i], max(left[i], right[i])) boxes.sort() warehouse.sort() res = i = 0 for x in boxes: while i &amp;lt; n and warehouse[i] &amp;lt; x: i += 1 if i == n: break res, i = res + 1, i + 1 return res</description></item><item><title>1582. Special Positions in a Binary Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1582/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1582/</guid><description>LeetCode problem 1582
class Solution: def numSpecial(self, mat: List[List[int]]) -&amp;gt; int: m, n = len(mat), len(mat[0]) r = [0] * m c = [0] * n for i, row in enumerate(mat): for j, v in enumerate(row): r[i] += v c[j] += v res = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and r[i] == 1 and c[j] == 1: res += 1 return res</description></item><item><title>1583. Count Unhappy Friends</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1583/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1583/</guid><description>LeetCode problem 1583
class Solution: def unhappyFriends( self, n: int, preferences: List[List[int]], pairs: List[List[int]] ) -&amp;gt; int: d = [{p: i for i, p in enumerate(v)} for v in preferences] p = {} for x, y in pairs: p[x] = y p[y] = x res = 0 for x in range(n): y = p[x] res += any(d[u][x] &amp;lt; d[u][p[u]] for u in preferences[x][: d[x][y]]) return res</description></item><item><title>1584. Min Cost to Connect All Points</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1584/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1584/</guid><description>LeetCode problem 1584
class Solution: def minCostConnectPoints(self, points: List[List[int]]) -&amp;gt; int: def find(x: int) -&amp;gt; int: if p[x] != x: p[x] = find(p[x]) return p[x] n = len(points) g = [] for i, (x1, y1) in enumerate(points): for j in range(i + 1, n): x2, y2 = points[j] t = abs(x1 - x2) + abs(y1 - y2) g.append((t, i, j)) p = list(range(n)) res = 0 for cost, i, j in sorted(g): pa, pb = find(i), find(j) if pa == pb: continue p[pa] = pb res += cost n -= 1 if n == 1: break return res</description></item><item><title>1585. Check If String Is Transformable With Substring Sort Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1585/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1585/</guid><description>LeetCode problem 1585
class Solution: def isTransformable(self, s: str, t: str) -&amp;gt; bool: pos = defaultdict(deque) for i, c in enumerate(s): pos[int(c)].append(i) for c in t: x = int(c) if not pos[x] or any(pos[i] and pos[i][0] &amp;lt; pos[x][0] for i in range(x)): return False pos[x].popleft() return True</description></item><item><title>1586. Binary Search Tree Iterator II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1586/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1586/</guid><description>LeetCode problem 1586
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator: def __init__(self, root: Optional[TreeNode]): self.nums = [] def dfs(root): if root is None: return dfs(root.left) self.nums.append(root.val) dfs(root.right) dfs(root) self.i = -1 def hasNext(self) -&amp;gt; bool: return self.i &amp;lt; len(self.nums) - 1 def next(self) -&amp;gt; int: self.i += 1 return self.nums[self.i] def hasPrev(self) -&amp;gt; bool: return self.</description></item><item><title>1588. Sum of All Odd Length Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1588/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1588/</guid><description>LeetCode problem 1588
class Solution: def sumOddLengthSubarrays(self, arr: List[int]) -&amp;gt; int: res, n = 0, len(arr) for i in range(n): s = 0 for j in range(i, n): s += arr[j] if (j - i + 1) &amp;amp; 1: res += s return res</description></item><item><title>1589. Maximum Sum Obtained of Any Permutation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1589/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1589/</guid><description>LeetCode problem 1589
class Solution: def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -&amp;gt; int: n = len(nums) d = [0] * n for l, r in requests: d[l] += 1 if r + 1 &amp;lt; n: d[r + 1] -= 1 for i in range(1, n): d[i] += d[i - 1] nums.sort() d.sort() mod = 10**9 + 7 return sum(a * b for a, b in zip(nums, d)) % mod</description></item><item><title>1590. Make Sum Divisible by P</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1590/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1590/</guid><description>LeetCode problem 1590
class Solution: def minSubarray(self, nums: List[int], p: int) -&amp;gt; int: k = sum(nums) % p if k == 0: return 0 last = {0: -1} cur = 0 res = len(nums) for i, x in enumerate(nums): cur = (cur + x) % p target = (cur - k + p) % p if target in last: res = min(res, i - last[target]) last[cur] = i return -1 if res == len(nums) else res</description></item><item><title>1592. Rearrange Spaces Between Words</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1592/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1592/</guid><description>LeetCode problem 1592
class Solution: def reorderSpaces(self, text: str) -&amp;gt; str: cnt = text.count(&amp;#39; &amp;#39;) words = text.split() m = len(words) - 1 if m == 0: return words[0] + &amp;#39; &amp;#39; * cnt return (&amp;#39; &amp;#39; * (cnt // m)).join(words) + &amp;#39; &amp;#39; * (cnt % m)</description></item><item><title>1593. Split a String Into the Max Number of Unique Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1593/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1593/</guid><description>LeetCode problem 1593
class Solution: def maxUniqueSplit(self, s: str) -&amp;gt; int: def dfs(i, t): if i &amp;gt;= len(s): nonlocal res res = max(res, t) return for j in range(i + 1, len(s) + 1): if s[i:j] not in vis: vis.add(s[i:j]) dfs(j, t + 1) vis.remove(s[i:j]) vis = set() res = 1 dfs(0, 0) return res</description></item><item><title>1594. Maximum Non Negative Product in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1594/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1594/</guid><description>LeetCode problem 1594
class Solution: def maxProductPath(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) mod = 10**9 + 7 dp = [[[grid[0][0]] * 2 for _ in range(n)] for _ in range(m)] for i in range(1, m): dp[i][0] = [dp[i - 1][0][0] * grid[i][0]] * 2 for j in range(1, n): dp[0][j] = [dp[0][j - 1][0] * grid[0][j]] * 2 for i in range(1, m): for j in range(1, n): v = grid[i][j] if v &amp;gt;= 0: dp[i][j][0] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v dp[i][j][1] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v else: dp[i][j][0] = max(dp[i - 1][j][1], dp[i][j - 1][1]) * v dp[i][j][1] = min(dp[i - 1][j][0], dp[i][j - 1][0]) * v res = dp[-1][-1][1] return -1 if res &amp;lt; 0 else res % mod</description></item><item><title>1595. Minimum Cost to Connect Two Groups of Points</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1595/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1595/</guid><description>LeetCode problem 1595
class Solution: def connectTwoGroups(self, cost: List[List[int]]) -&amp;gt; int: m, n = len(cost), len(cost[0]) f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 g = f[:] for i in range(1, m + 1): for j in range(1 &amp;lt;&amp;lt; n): g[j] = inf for k in range(n): if (j &amp;gt;&amp;gt; k &amp;amp; 1) == 0: continue c = cost[i - 1][k] x = min(g[j ^ (1 &amp;lt;&amp;lt; k)], f[j], f[j ^ (1 &amp;lt;&amp;lt; k)]) + c g[j] = min(g[j], x) f = g[:] return f[-1]</description></item><item><title>1598. Crawler Log Folder</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1598/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1598/</guid><description>LeetCode problem 1598
class Solution: def minOperations(self, logs: List[str]) -&amp;gt; int: res = 0 for v in logs: if v == &amp;#34;../&amp;#34;: res = max(0, res - 1) elif v[0] != &amp;#34;.&amp;#34;: res += 1 return res</description></item><item><title>1599. Maximum Profit of Operating a Centennial Wheel</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1599/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1599/</guid><description>LeetCode problem 1599
class Solution: def minOperationsMaxProfit( self, customers: List[int], boardingCost: int, runningCost: int ) -&amp;gt; int: res = -1 mx = t = 0 wait = 0 i = 0 while wait or i &amp;lt; len(customers): wait += customers[i] if i &amp;lt; len(customers) else 0 up = wait if wait &amp;lt; 4 else 4 wait -= up t += up * boardingCost - runningCost i += 1 if t &amp;gt; mx: mx = t res = i return res</description></item><item><title>1600. Throne Inheritance</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1600/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1600/</guid><description>LeetCode problem 1600
class ThroneInheritance: def __init__(self, kingName: str): self.g = defaultdict(list) self.dead = set() self.king = kingName def birth(self, parentName: str, childName: str) -&amp;gt; None: self.g[parentName].append(childName) def death(self, name: str) -&amp;gt; None: self.dead.add(name) def getInheritanceOrder(self) -&amp;gt; List[str]: def dfs(x): if x not in self.dead: res.append(x) for y in self.g[x]: dfs(y) res = [] dfs(self.king) return res # Your ThroneInheritance object will be instantiated and called as such: # obj = ThroneInheritance(kingName) # obj.birth(parentName,childName) # obj.death(name) # param_3 = obj.</description></item><item><title>1601. Maximum Number of Achievable Transfer Requests</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1601/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1601/</guid><description>LeetCode problem 1601
class Solution: def maximumRequests(self, n: int, requests: List[List[int]]) -&amp;gt; int: def check(mask: int) -&amp;gt; bool: cnt = [0] * n for i, (f, t) in enumerate(requests): if mask &amp;gt;&amp;gt; i &amp;amp; 1: cnt[f] -= 1 cnt[t] += 1 return all(v == 0 for v in cnt) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(requests)): cnt = mask.bit_count() if res &amp;lt; cnt and check(mask): res = cnt return res</description></item><item><title>1602. Find Nearest Right Node in Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1602/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1602/</guid><description>LeetCode problem 1602
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findNearestRightNode(self, root: TreeNode, u: TreeNode) -&amp;gt; Optional[TreeNode]: def dfs(root, i): nonlocal d, res if root is None or res: return if d == i: res = root return if root == u: d = i return dfs(root.left, i + 1) dfs(root.right, i + 1) d = 0 res = None dfs(root, 1) return res</description></item><item><title>1603. Design Parking System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1603/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1603/</guid><description>LeetCode problem 1603
class ParkingSystem: def __init__(self, big: int, medium: int, small: int): self.cnt = [0, big, medium, small] def addCar(self, carType: int) -&amp;gt; bool: if self.cnt[carType] == 0: return False self.cnt[carType] -= 1 return True # Your ParkingSystem object will be instantiated and called as such: # obj = ParkingSystem(big, medium, small) # param_1 = obj.addCar(carType)</description></item><item><title>1604. Alert Using Same Key-Card Three or More Times in a One Hour Period</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1604/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1604/</guid><description>LeetCode problem 1604
class Solution: def alertNames(self, keyName: List[str], keyTime: List[str]) -&amp;gt; List[str]: d = defaultdict(list) for name, t in zip(keyName, keyTime): t = int(t[:2]) * 60 + int(t[3:]) d[name].append(t) res = [] for name, ts in d.items(): if (n := len(ts)) &amp;gt; 2: ts.sort() for i in range(n - 2): if ts[i + 2] - ts[i] &amp;lt;= 60: res.append(name) break res.sort() return res</description></item><item><title>1605. Find Valid Matrix Given Row and Column Sums</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1605/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1605/</guid><description>LeetCode problem 1605
class Solution: def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -&amp;gt; List[List[int]]: m, n = len(rowSum), len(colSum) res = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): x = min(rowSum[i], colSum[j]) res[i][j] = x rowSum[i] -= x colSum[j] -= x return res</description></item><item><title>1606. Find Servers That Handled Most Number of Requests</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1606/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1606/</guid><description>LeetCode problem 1606
from sortedcontainers import SortedList class Solution: def busiestServers(self, k: int, arrival: List[int], load: List[int]) -&amp;gt; List[int]: free = SortedList(range(k)) busy = [] cnt = [0] * k for i, (start, t) in enumerate(zip(arrival, load)): while busy and busy[0][0] &amp;lt;= start: free.add(busy[0][1]) heappop(busy) if not free: continue j = free.bisect_left(i % k) if j == len(free): j = 0 server = free[j] cnt[server] += 1 heappush(busy, (start + t, server)) free.remove(server) mx = max(cnt) return [i for i, v in enumerate(cnt) if v == mx]</description></item><item><title>1608. Special Array With X Elements Greater Than or Equal X</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1608/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1608/</guid><description>LeetCode problem 1608
class Solution: def specialArray(self, nums: List[int]) -&amp;gt; int: nums.sort() n = len(nums) for x in range(1, n + 1): cnt = n - bisect_left(nums, x) if cnt == x: return x return -1</description></item><item><title>1609. Even Odd Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1609/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1609/</guid><description>LeetCode problem 1609
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isEvenOddTree(self, root: Optional[TreeNode]) -&amp;gt; bool: d = {} def dfs(root, i): if root is None: return True even = i % 2 == 0 prev = d.get(i, 0 if even else inf) if even and (root.val % 2 == 0 or prev &amp;gt;= root.val): return False if not even and (root.</description></item><item><title>1610. Maximum Number of Visible Points</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1610/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1610/</guid><description>LeetCode problem 1610
class Solution: def visiblePoints( self, points: List[List[int]], angle: int, location: List[int] ) -&amp;gt; int: v = [] x, y = location same = 0 for xi, yi in points: if xi == x and yi == y: same += 1 else: v.append(atan2(yi - y, xi - x)) v.sort() n = len(v) v += [deg + 2 * pi for deg in v] t = angle * pi / 180 mx = max((bisect_right(v, v[i] + t) - i for i in range(n)), default=0) return mx + same</description></item><item><title>1611. Minimum One Bit Operations to Make Integers Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1611/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1611/</guid><description>LeetCode problem 1611
class Solution: def minimumOneBitOperations(self, n: int) -&amp;gt; int: if n == 0: return 0 return n ^ self.minimumOneBitOperations(n &amp;gt;&amp;gt; 1)</description></item><item><title>1612. Check If Two Expression Trees are Equivalent</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1612/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1612/</guid><description>LeetCode problem 1612
# Definition for a binary tree node. # class Node(object): # def __init__(self, val=&amp;#34; &amp;#34;, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def checkEquivalence(self, root1: &amp;#39;Node&amp;#39;, root2: &amp;#39;Node&amp;#39;) -&amp;gt; bool: def dfs(root): cnt = [0] * 26 if root is None: return cnt if root.val in &amp;#39;+-&amp;#39;: l, r = dfs(root.left), dfs(root.right) k = 1 if root.val == &amp;#39;+&amp;#39; else -1 for i in range(26): cnt[i] += l[i] + r[i] * k else: cnt[ord(root.</description></item><item><title>1614. Maximum Nesting Depth of the Parentheses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1614/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1614/</guid><description>LeetCode problem 1614
class Solution: def maxDepth(self, s: str) -&amp;gt; int: res = d = 0 for c in s: if c == &amp;#39;(&amp;#39;: d += 1 res = max(res, d) elif c == &amp;#39;)&amp;#39;: d -= 1 return res</description></item><item><title>1615. Maximal Network Rank</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1615/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1615/</guid><description>LeetCode problem 1615
class Solution: def maximalNetworkRank(self, n: int, roads: List[List[int]]) -&amp;gt; int: g = [[0] * n for _ in range(n)] cnt = [0] * n for a, b in roads: g[a][b] = g[b][a] = 1 cnt[a] += 1 cnt[b] += 1 return max(cnt[a] + cnt[b] - g[a][b] for a in range(n) for b in range(a + 1, n))</description></item><item><title>1616. Split Two Strings to Make Palindrome</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1616/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1616/</guid><description>LeetCode problem 1616
class Solution: def checkPalindromeFormation(self, a: str, b: str) -&amp;gt; bool: def check1(a: str, b: str) -&amp;gt; bool: i, j = 0, len(b) - 1 while i &amp;lt; j and a[i] == b[j]: i, j = i + 1, j - 1 return i &amp;gt;= j or check2(a, i, j) or check2(b, i, j) def check2(a: str, i: int, j: int) -&amp;gt; bool: return a[i : j + 1] == a[i : j + 1][::-1] return check1(a, b) or check1(b, a)</description></item><item><title>1617. Count Subtrees With Max Distance Between Cities</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1617/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1617/</guid><description>LeetCode problem 1617
class Solution: def countSubgraphsForEachDiameter( self, n: int, edges: List[List[int]] ) -&amp;gt; List[int]: def bfs(u: int) -&amp;gt; int: d = -1 q = deque([u]) nonlocal msk, nxt msk ^= 1 &amp;lt;&amp;lt; u while q: d += 1 for _ in range(len(q)): nxt = u = q.popleft() for v in g[u]: if msk &amp;gt;&amp;gt; v &amp;amp; 1: msk ^= 1 &amp;lt;&amp;lt; v q.append(v) return d g = defaultdict(list) for u, v in edges: u, v = u - 1, v - 1 g[u].</description></item><item><title>1618. Maximum Font to Fit a Sentence in a Screen</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1618/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1618/</guid><description>LeetCode problem 1618
# &amp;#34;&amp;#34;&amp;#34; # This is FontInfo&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class FontInfo(object): # Return the width of char ch when fontSize is used. # def getWidth(self, fontSize, ch): # &amp;#34;&amp;#34;&amp;#34; # :type fontSize: int # :type ch: char # :rtype int # &amp;#34;&amp;#34;&amp;#34; # # def getHeight(self, fontSize): # &amp;#34;&amp;#34;&amp;#34; # :type fontSize: int # :rtype int # &amp;#34;&amp;#34;&amp;#34; class Solution: def maxFont( self, text: str, w: int, h: int, fonts: List[int], fontInfo: &amp;#39;FontInfo&amp;#39; ) -&amp;gt; int: def check(size): if fontInfo.</description></item><item><title>1619. Mean of Array After Removing Some Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1619/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1619/</guid><description>LeetCode problem 1619
class Solution: def trimMean(self, arr: List[int]) -&amp;gt; float: n = len(arr) start, end = int(n * 0.05), int(n * 0.95) arr.sort() t = arr[start:end] return round(sum(t) / len(t), 5)</description></item><item><title>1620. Coordinate With Maximum Network Quality</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1620/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1620/</guid><description>LeetCode problem 1620
class Solution: def bestCoordinate(self, towers: List[List[int]], radius: int) -&amp;gt; List[int]: mx = 0 res = [0, 0] for i in range(51): for j in range(51): t = 0 for x, y, q in towers: d = ((x - i) ** 2 + (y - j) ** 2) ** 0.5 if d &amp;lt;= radius: t += floor(q / (1 + d)) if t &amp;gt; mx: mx = t res = [i, j] return res</description></item><item><title>1621. Number of Sets of K Non-Overlapping Line Segments</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1621/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1621/</guid><description>LeetCode problem 1621
class Solution: def numberOfSets(self, n: int, k: int) -&amp;gt; int: mod = 10**9 + 7 f = [[0] * (k + 1) for _ in range(n + 1)] g = [[0] * (k + 1) for _ in range(n + 1)] f[1][0] = 1 for i in range(2, n + 1): for j in range(k + 1): f[i][j] = (f[i - 1][j] + g[i - 1][j]) % mod g[i][j] = g[i - 1][j] if j: g[i][j] += f[i - 1][j - 1] g[i][j] %= mod g[i][j] += g[i - 1][j - 1] g[i][j] %= mod return (f[-1][-1] + g[-1][-1]) % mod</description></item><item><title>1622. Fancy Sequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1622/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1622/</guid><description>LeetCode problem 1622
MOD = int(1e9 + 7) class Node: def __init__(self, l, r): self.left = None self.right = None self.l = l self.r = r self.mid = (l + r) &amp;gt;&amp;gt; 1 self.v = 0 self.add = 0 self.mul = 1 class SegmentTree: def __init__(self): self.root = Node(1, int(1e5 + 1)) def modifyAdd(self, l, r, inc, node=None): if l &amp;gt; r: return if node is None: node = self.root if node.l &amp;gt;= l and node.r &amp;lt;= r: node.</description></item><item><title>1624. Largest Substring Between Two Equal Characters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1624/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1624/</guid><description>LeetCode problem 1624
class Solution: def maxLengthBetweenEqualCharacters(self, s: str) -&amp;gt; int: d = {} res = -1 for i, c in enumerate(s): if c in d: res = max(res, i - d[c] - 1) else: d[c] = i return res</description></item><item><title>1625. Lexicographically Smallest String After Applying Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1625/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1625/</guid><description>LeetCode problem 1625
class Solution: def findLexSmallestString(self, s: str, a: int, b: int) -&amp;gt; str: res = s n = len(s) s = list(s) for _ in range(n): s = s[-b:] + s[:-b] for j in range(10): for k in range(1, n, 2): s[k] = str((int(s[k]) + a) % 10) if b &amp;amp; 1: for p in range(10): for k in range(0, n, 2): s[k] = str((int(s[k]) + a) % 10) t = &amp;#39;&amp;#39;.join(s) if res &amp;gt; t: res = t else: t = &amp;#39;&amp;#39;.</description></item><item><title>1626. Best Team With No Conflicts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1626/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1626/</guid><description>LeetCode problem 1626
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) def update(self, x, val): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], val) x += x &amp;amp; -x def query(self, x): s = 0 while x: s = max(s, self.c[x]) x -= x &amp;amp; -x return s class Solution: def bestTeamScore(self, scores: List[int], ages: List[int]) -&amp;gt; int: m = max(ages) tree = BinaryIndexedTree(m) for score, age in sorted(zip(scores, ages)): tree.update(age, score + tree.</description></item><item><title>1627. Graph Connectivity With Threshold</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1627/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1627/</guid><description>LeetCode problem 1627
class UnionFind: def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a, b): pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] return True class Solution: def areConnected( self, n: int, threshold: int, queries: List[List[int]] ) -&amp;gt; List[bool]: uf = UnionFind(n + 1) for a in range(threshold + 1, n + 1): for b in range(a + a, n + 1, a): uf.</description></item><item><title>1628. Design an Expression Tree With Evaluate Function</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1628/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1628/</guid><description>LeetCode problem 1628
import abc from abc import ABC, abstractmethod &amp;#34;&amp;#34;&amp;#34; This is the interface for the expression tree Node. You should not remove it, and you can define some classes to implement it. &amp;#34;&amp;#34;&amp;#34; class Node(ABC): @abstractmethod # define your fields here def evaluate(self) -&amp;gt; int: pass class MyNode(Node): def __init__(self, val): self.val = val self.left = None self.right = None def evaluate(self) -&amp;gt; int: x = self.val if x.isdigit(): return int(x) left, right = self.left.evaluate(), self.right.evaluate() if x == &amp;#39;+&amp;#39;: return left + right if x == &amp;#39;-&amp;#39;: return left - right if x == &amp;#39;*&amp;#39;: return left * right if x == &amp;#39;/&amp;#39;: return left // right &amp;#34;&amp;#34;&amp;#34; This is the TreeBuilder class.</description></item><item><title>1629. Slowest Key</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1629/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1629/</guid><description>LeetCode problem 1629
class Solution: def slowestKey(self, releaseTimes: List[int], keysPressed: str) -&amp;gt; str: res = keysPressed[0] mx = releaseTimes[0] for i in range(1, len(keysPressed)): d = releaseTimes[i] - releaseTimes[i - 1] if d &amp;gt; mx or (d == mx and ord(keysPressed[i]) &amp;gt; ord(res)): mx = d res = keysPressed[i] return res</description></item><item><title>1630. Arithmetic Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1630/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1630/</guid><description>LeetCode problem 1630
class Solution: def checkArithmeticSubarrays( self, nums: List[int], l: List[int], r: List[int] ) -&amp;gt; List[bool]: def check(nums, l, r): n = r - l + 1 s = set(nums[l : l + n]) a1, an = min(nums[l : l + n]), max(nums[l : l + n]) d, mod = divmod(an - a1, n - 1) return mod == 0 and all((a1 + (i - 1) * d) in s for i in range(1, n)) return [check(nums, left, right) for left, right in zip(l, r)]</description></item><item><title>1631. Path With Minimum Effort</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1631/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1631/</guid><description>LeetCode problem 1631
class Solution: def minimumEffortPath(self, heights: List[List[int]]) -&amp;gt; int: m, n = len(heights), len(heights[0]) dist = [[inf] * n for _ in range(m)] dist[0][0] = 0 dirs = (-1, 0, 1, 0, -1) q = [(0, 0, 0)] while q: t, i, j = heappop(q) for a, b in pairwise(dirs): x, y = i + a, j + b if ( 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and (d := max(t, abs(heights[i][j] - heights[x][y]))) &amp;lt; dist[x][y] ): dist[x][y] = d heappush(q, (d, x, y)) return int(dist[-1][-1])</description></item><item><title>1632. Rank Transform of a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1632/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1632/</guid><description>LeetCode problem 1632
class UnionFind: def __init__(self, n): self.p = list(range(n)) self.size = [1] * n def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a, b): pa, pb = self.find(a), self.find(b) if pa != pb: if self.size[pa] &amp;gt; self.size[pb]: self.p[pb] = pa self.size[pa] += self.size[pb] else: self.p[pa] = pb self.size[pb] += self.size[pa] def reset(self, x): self.p[x] = x self.size[x] = 1 class Solution: def matrixRankTransform(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(matrix), len(matrix[0]) d = defaultdict(list) for i, row in enumerate(matrix): for j, v in enumerate(row): d[v].</description></item><item><title>1634. Add Two Polynomials Represented as Linked Lists</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1634/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1634/</guid><description>LeetCode problem 1634
# Definition for polynomial singly-linked list. # class PolyNode: # def __init__(self, x=0, y=0, next=None): # self.coefficient = x # self.power = y # self.next = next class Solution: def addPoly(self, poly1: &amp;#34;PolyNode&amp;#34;, poly2: &amp;#34;PolyNode&amp;#34;) -&amp;gt; &amp;#34;PolyNode&amp;#34;: dummy = curr = PolyNode() while poly1 and poly2: if poly1.power &amp;gt; poly2.power: curr.next = poly1 poly1 = poly1.next curr = curr.next elif poly1.power &amp;lt; poly2.power: curr.next = poly2 poly2 = poly2.next curr = curr.next else: if c := poly1.</description></item><item><title>1636. Sort Array by Increasing Frequency</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1636/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1636/</guid><description>LeetCode problem 1636
class Solution: def frequencySort(self, nums: List[int]) -&amp;gt; List[int]: cnt = Counter(nums) return sorted(nums, key=lambda x: (cnt[x], -x))</description></item><item><title>1637. Widest Vertical Area Between Two Points Containing No Points</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1637/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1637/</guid><description>LeetCode problem 1637
class Solution: def maxWidthOfVerticalArea(self, points: List[List[int]]) -&amp;gt; int: nums = [x for x, _ in points] n = len(nums) mi, mx = min(nums), max(nums) bucket_size = max(1, (mx - mi) // (n - 1)) bucket_count = (mx - mi) // bucket_size + 1 buckets = [[inf, -inf] for _ in range(bucket_count)] for x in nums: i = (x - mi) // bucket_size buckets[i][0] = min(buckets[i][0], x) buckets[i][1] = max(buckets[i][1], x) res = 0 prev = inf for curmin, curmax in buckets: if curmin &amp;gt; curmax: continue res = max(res, curmin - prev) prev = curmax return res</description></item><item><title>1638. Count Substrings That Differ by One Character</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1638/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1638/</guid><description>LeetCode problem 1638
class Solution: def countSubstrings(self, s: str, t: str) -&amp;gt; int: res = 0 m, n = len(s), len(t) f = [[0] * (n + 1) for _ in range(m + 1)] g = [[0] * (n + 1) for _ in range(m + 1)] for i, a in enumerate(s, 1): for j, b in enumerate(t, 1): if a == b: f[i][j] = f[i - 1][j - 1] + 1 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): if s[i] == t[j]: g[i][j] = g[i + 1][j + 1] + 1 else: res += (f[i][j] + 1) * (g[i + 1][j + 1] + 1) return res</description></item><item><title>1639. Number of Ways to Form a Target String Given a Dictionary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1639/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1639/</guid><description>LeetCode problem 1639
class Solution: def numWays(self, words: List[str], target: str) -&amp;gt; int: m, n = len(target), len(words[0]) cnt = [[0] * 26 for _ in range(n)] for w in words: for j, c in enumerate(w): cnt[j][ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 mod = 10**9 + 7 f = [[0] * (n + 1) for _ in range(m + 1)] f[0] = [1] * (n + 1) for i in range(1, m + 1): for j in range(1, n + 1): f[i][j] = ( f[i][j - 1] + f[i - 1][j - 1] * cnt[j - 1][ord(target[i - 1]) - ord(&amp;#39;a&amp;#39;)] ) f[i][j] %= mod return f[m][n]</description></item><item><title>1640. Check Array Formation Through Concatenation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1640/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1640/</guid><description>LeetCode problem 1640
class Solution: def canFormArray(self, arr: List[int], pieces: List[List[int]]) -&amp;gt; bool: d = {p[0]: p for p in pieces} i, n = 0, len(arr) while i &amp;lt; n: if arr[i] not in d: return False p = d[arr[i]] if arr[i : i + len(p)] != p: return False i += len(p) return True</description></item><item><title>1641. Count Sorted Vowel Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1641/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1641/</guid><description>LeetCode problem 1641
class Solution: def countVowelStrings(self, n: int) -&amp;gt; int: f = [1] * 5 for _ in range(n - 1): s = 0 for j in range(5): s += f[j] f[j] = s return sum(f)</description></item><item><title>1642. Furthest Building You Can Reach</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1642/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1642/</guid><description>LeetCode problem 1642
class Solution: def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -&amp;gt; int: h = [] for i, a in enumerate(heights[:-1]): b = heights[i + 1] d = b - a if d &amp;gt; 0: heappush(h, d) if len(h) &amp;gt; ladders: bricks -= heappop(h) if bricks &amp;lt; 0: return i return len(heights) - 1</description></item><item><title>1643. Kth Smallest Instructions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1643/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1643/</guid><description>LeetCode problem 1643
class Solution: def kthSmallestPath(self, destination: List[int], k: int) -&amp;gt; str: v, h = destination res = [] for _ in range(h + v): if h == 0: res.append(&amp;#34;V&amp;#34;) else: x = comb(h + v - 1, h - 1) if k &amp;gt; x: res.append(&amp;#34;V&amp;#34;) v -= 1 k -= x else: res.append(&amp;#34;H&amp;#34;) h -= 1 return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1644. Lowest Common Ancestor of a Binary Tree II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1644/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1644/</guid><description>LeetCode problem 1644
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor( self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39; ) -&amp;gt; &amp;#39;TreeNode&amp;#39;: def dfs(root, p, q): if root is None: return False l = dfs(root.left, p, q) r = dfs(root.right, p, q) nonlocal res if l and r: res = root if (l or r) and (root.val == p.</description></item><item><title>1646. Get Maximum in Generated Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1646/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1646/</guid><description>LeetCode problem 1646
class Solution: def getMaximumGenerated(self, n: int) -&amp;gt; int: if n &amp;lt; 2: return n nums = [0] * (n + 1) nums[1] = 1 for i in range(2, n + 1): nums[i] = nums[i &amp;gt;&amp;gt; 1] if i % 2 == 0 else nums[i &amp;gt;&amp;gt; 1] + nums[(i &amp;gt;&amp;gt; 1) + 1] return max(nums)</description></item><item><title>1647. Minimum Deletions to Make Character Frequencies Unique</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1647/</guid><description>LeetCode задача 1647
Задача Строка s называется хорошей, если в ней нет двух разных символов с одинаковой частотой.
Дана строка s, верните минимальное количество символов, которое необходимо удалить, чтобы сделать s хорошим.
Подход Основная идея решения заключается в подсчете частот символов в строке и определении количества удалений, необходимых для того, чтобы все частоты были уникальными.
Если проверять встречалась ли частота текущего символа ранее, то
Алгоритм / Абстрактный алгоритм Считаем частоты всех символов в строке. Сортируем частоты в порядке убывания.</description></item><item><title>1648. Sell Diminishing-Valued Colored Balls</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1648/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1648/</guid><description>LeetCode problem 1648
class Solution: def maxProfit(self, inventory: List[int], orders: int) -&amp;gt; int: inventory.sort(reverse=True) mod = 10**9 + 7 res = i = 0 n = len(inventory) while orders &amp;gt; 0: while i &amp;lt; n and inventory[i] &amp;gt;= inventory[0]: i += 1 nxt = 0 if i &amp;lt; n: nxt = inventory[i] cnt = i x = inventory[0] - nxt tot = cnt * x if tot &amp;gt; orders: decr = orders // cnt a1, an = inventory[0] - decr + 1, inventory[0] res += (a1 + an) * decr // 2 * cnt res += (inventory[0] - decr) * (orders % cnt) else: a1, an = nxt + 1, inventory[0] res += (a1 + an) * x // 2 * cnt inventory[0] = nxt orders -= tot res %= mod return res</description></item><item><title>1649. Create Sorted Array through Instructions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1649/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1649/</guid><description>LeetCode problem 1649
class Node: def __init__(self): self.l = 0 self.r = 0 self.v = 0 class SegmentTree: def __init__(self, n): self.tr = [Node() for _ in range(4 * n)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l = l self.tr[u].r = r if l == r: return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) def modify(self, u, x, v): if self.tr[u].l == x and self.</description></item><item><title>1650. Lowest Common Ancestor of a Binary Tree III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1650/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1650/</guid><description>LeetCode problem 1650
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val): self.val = val self.left = None self.right = None self.parent = None &amp;#34;&amp;#34;&amp;#34; class Solution: def lowestCommonAncestor(self, p: &amp;#39;Node&amp;#39;, q: &amp;#39;Node&amp;#39;) -&amp;gt; &amp;#39;Node&amp;#39;: a, b = p, q while a != b: a = a.parent if a.parent else q b = b.parent if b.parent else p return a</description></item><item><title>1652. Defuse the Bomb</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1652/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1652/</guid><description>LeetCode problem 1652
class Solution: def decrypt(self, code: List[int], k: int) -&amp;gt; List[int]: n = len(code) res = [0] * n if k == 0: return res s = list(accumulate(code + code, initial=0)) for i in range(n): if k &amp;gt; 0: res[i] = s[i + k + 1] - s[i + 1] else: res[i] = s[i + n] - s[i + k + n] return res</description></item><item><title>1653. Minimum Deletions to Make String Balanced</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1653/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1653/</guid><description>LeetCode problem 1653
class Solution: def minimumDeletions(self, s: str) -&amp;gt; int: lb, ra = 0, s.count(&amp;#39;a&amp;#39;) res = len(s) for c in s: ra -= c == &amp;#39;a&amp;#39; res = min(res, lb + ra) lb += c == &amp;#39;b&amp;#39; return res</description></item><item><title>1654. Minimum Jumps to Reach Home</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1654/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1654/</guid><description>LeetCode problem 1654
class Solution: def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -&amp;gt; int: s = set(forbidden) q = deque([(0, 1)]) vis = {(0, 1)} res = 0 while q: for _ in range(len(q)): i, k = q.popleft() if i == x: return res nxt = [(i + a, 1)] if k &amp;amp; 1: nxt.append((i - b, 0)) for j, k in nxt: if 0 &amp;lt;= j &amp;lt; 6000 and j not in s and (j, k) not in vis: q.</description></item><item><title>1655. Distribute Repeating Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1655/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1655/</guid><description>LeetCode problem 1655
class Solution: def canDistribute(self, nums: List[int], quantity: List[int]) -&amp;gt; bool: m = len(quantity) s = [0] * (1 &amp;lt;&amp;lt; m) for i in range(1, 1 &amp;lt;&amp;lt; m): for j in range(m): if i &amp;gt;&amp;gt; j &amp;amp; 1: s[i] = s[i ^ (1 &amp;lt;&amp;lt; j)] + quantity[j] break cnt = Counter(nums) arr = list(cnt.values()) n = len(arr) f = [[False] * (1 &amp;lt;&amp;lt; m) for _ in range(n)] for i in range(n): f[i][0] = True for i, x in enumerate(arr): for j in range(1, 1 &amp;lt;&amp;lt; m): if i and f[i - 1][j]: f[i][j] = True continue k = j while k: ok1 = j == k if i == 0 else f[i - 1][j ^ k] ok2 = s[k] &amp;lt;= x if ok1 and ok2: f[i][j] = True break k = (k - 1) &amp;amp; j return f[-1][-1]</description></item><item><title>1656. Design an Ordered Stream</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1656/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1656/</guid><description>LeetCode problem 1656
class OrderedStream: def __init__(self, n: int): self.data = [None] * n self.ptr = 0 def insert(self, idKey: int, value: str) -&amp;gt; List[str]: self.data[idKey - 1] = value res = [] while self.ptr &amp;lt; len(self.data) and self.data[self.ptr]: res.append(self.data[self.ptr]) self.ptr += 1 return res # Your OrderedStream object will be instantiated and called as such: # obj = OrderedStream(n) # param_1 = obj.insert(idKey,value)</description></item><item><title>1658. Minimum Operations to Reduce X to Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1658/</link><pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1658/</guid><description>LeetCode problem 1658
Problem Statement You have an integer array nums and another integer x. In a single operation, you can either remove the leftmost or the rightmost element from the array nums and decrement x by the value of the removed element. The question is: What is the minimum number of operations required to reduce x to exactly zero? If it&amp;rsquo;s not feasible, the answer should be -1.
Naive Solution The naive approach would be to explore every possible combination of removing elements from the start or the end, recursively.</description></item><item><title>1659. Maximize Grid Happiness</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1659/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1659/</guid><description>LeetCode problem 1659
class Solution: def getMaxGridHappiness( self, m: int, n: int, introvertsCount: int, extrovertsCount: int ) -&amp;gt; int: @cache def dfs(pos: int, pre: int, ic: int, ec: int) -&amp;gt; int: if pos == m * n or (ic == 0 and ec == 0): return 0 res = 0 up = pre // p left = 0 if pos % n == 0 else pre % 3 for i in range(3): if (i == 1 and ic == 0) or (i == 2 and ec == 0): continue cur = pre % p * 3 + i a = h[up][i] + h[left][i] b = dfs(pos + 1, cur, ic - (i == 1), ec - (i == 2)) c = 0 if i == 1: c = 120 elif i == 2: c = 40 res = max(res, a + b + c) return res p = pow(3, n - 1) h = [[0, 0, 0], [0, -60, -10], [0, -10, 40]] return dfs(0, 0, introvertsCount, extrovertsCount)</description></item><item><title>1660. Correct a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1660/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1660/</guid><description>LeetCode problem 1660
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def correctBinaryTree(self, root: TreeNode) -&amp;gt; TreeNode: def dfs(root): if root is None or root.right in vis: return None vis.add(root) root.right = dfs(root.right) root.left = dfs(root.left) return root vis = set() return dfs(root)</description></item><item><title>1662. Check If Two String Arrays are Equivalent</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1662/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1662/</guid><description>LeetCode problem 1662
class Solution: def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -&amp;gt; bool: i = j = x = y = 0 while i &amp;lt; len(word1) and j &amp;lt; len(word2): if word1[i][x] != word2[j][y]: return False x, y = x + 1, y + 1 if x == len(word1[i]): x, i = 0, i + 1 if y == len(word2[j]): y, j = 0, j + 1 return i == len(word1) and j == len(word2)</description></item><item><title>1663. Smallest String With A Given Numeric Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1663/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1663/</guid><description>LeetCode problem 1663
class Solution: def getSmallestString(self, n: int, k: int) -&amp;gt; str: res = [&amp;#39;a&amp;#39;] * n i, d = n - 1, k - n while d &amp;gt; 25: res[i] = &amp;#39;z&amp;#39; d -= 25 i -= 1 res[i] = chr(ord(res[i]) + d) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1664. Ways to Make a Fair Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1664/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1664/</guid><description>LeetCode problem 1664
class Solution: def waysToMakeFair(self, nums: List[int]) -&amp;gt; int: s1, s2 = sum(nums[::2]), sum(nums[1::2]) res = t1 = t2 = 0 for i, v in enumerate(nums): res += i % 2 == 0 and t2 + s1 - t1 - v == t1 + s2 - t2 res += i % 2 == 1 and t2 + s1 - t1 == t1 + s2 - t2 - v t1 += v if i % 2 == 0 else 0 t2 += v if i % 2 == 1 else 0 return res</description></item><item><title>1665. Minimum Initial Energy to Finish Tasks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1665/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1665/</guid><description>LeetCode problem 1665
class Solution: def minimumEffort(self, tasks: List[List[int]]) -&amp;gt; int: res = cur = 0 for a, m in sorted(tasks, key=lambda x: x[0] - x[1]): if cur &amp;lt; m: res += m - cur cur = m cur -= a return res</description></item><item><title>1666. Change the Root of a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1666/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1666/</guid><description>LeetCode problem 1666
&amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val): self.val = val self.left = None self.right = None self.parent = None &amp;#34;&amp;#34;&amp;#34; class Solution: def flipBinaryTree(self, root: &amp;#34;Node&amp;#34;, leaf: &amp;#34;Node&amp;#34;) -&amp;gt; &amp;#34;Node&amp;#34;: cur = leaf p = cur.parent while cur != root: gp = p.parent if cur.left: cur.right = cur.left cur.left = p p.parent = cur if p.left == cur: p.left = None elif p.right == cur: p.right = None cur = p p = gp leaf.</description></item><item><title>1668. Maximum Repeating Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1668/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1668/</guid><description>LeetCode problem 1668
class Solution: def maxRepeating(self, sequence: str, word: str) -&amp;gt; int: for k in range(len(sequence) // len(word), -1, -1): if word * k in sequence: return k</description></item><item><title>1669. Merge In Between Linked Lists</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1669/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1669/</guid><description>LeetCode problem 1669
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeInBetween( self, list1: ListNode, a: int, b: int, list2: ListNode ) -&amp;gt; ListNode: p = q = list1 for _ in range(a - 1): p = p.next for _ in range(b): q = q.next p.next = list2 while p.next: p = p.next p.next = q.next q.next = None return list1</description></item><item><title>1670. Design Front Middle Back Queue</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1670/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1670/</guid><description>LeetCode problem 1670
class FrontMiddleBackQueue: def __init__(self): self.q1 = deque() self.q2 = deque() def pushFront(self, val: int) -&amp;gt; None: self.q1.appendleft(val) self.rebalance() def pushMiddle(self, val: int) -&amp;gt; None: self.q1.append(val) self.rebalance() def pushBack(self, val: int) -&amp;gt; None: self.q2.append(val) self.rebalance() def popFront(self) -&amp;gt; int: if not self.q1 and not self.q2: return -1 if self.q1: val = self.q1.popleft() else: val = self.q2.popleft() self.rebalance() return val def popMiddle(self) -&amp;gt; int: if not self.q1 and not self.q2: return -1 if len(self.q1) == len(self.q2): val = self.</description></item><item><title>1671. Minimum Number of Removals to Make Mountain Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1671/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1671/</guid><description>LeetCode problem 1671
class Solution: def minimumMountainRemovals(self, nums: List[int]) -&amp;gt; int: n = len(nums) left = [1] * n right = [1] * n for i in range(1, n): for j in range(i): if nums[i] &amp;gt; nums[j]: left[i] = max(left[i], left[j] + 1) for i in range(n - 2, -1, -1): for j in range(i + 1, n): if nums[i] &amp;gt; nums[j]: right[i] = max(right[i], right[j] + 1) return n - max(a + b - 1 for a, b in zip(left, right) if a &amp;gt; 1 and b &amp;gt; 1)</description></item><item><title>1672. Richest Customer Wealth</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1672/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1672/</guid><description>LeetCode problem 1672
class Solution: def maximumWealth(self, accounts: List[List[int]]) -&amp;gt; int: return max(sum(v) for v in accounts)</description></item><item><title>1673. Find the Most Competitive Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1673/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1673/</guid><description>LeetCode problem 1673
class Solution: def mostCompetitive(self, nums: List[int], k: int) -&amp;gt; List[int]: stk = [] n = len(nums) for i, v in enumerate(nums): while stk and stk[-1] &amp;gt; v and len(stk) + n - i &amp;gt; k: stk.pop() if len(stk) &amp;lt; k: stk.append(v) return stk</description></item><item><title>1674. Minimum Moves to Make Array Complementary</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1674/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1674/</guid><description>LeetCode problem 1674
class Solution: def minMoves(self, nums: List[int], limit: int) -&amp;gt; int: d = [0] * (limit * 2 + 2) n = len(nums) for i in range(n &amp;gt;&amp;gt; 1): a, b = min(nums[i], nums[n - i - 1]), max(nums[i], nums[n - i - 1]) d[2] += 2 d[limit * 2 + 1] -= 2 d[a + 1] -= 1 d[b + limit + 1] += 1 d[a + b] -= 1 d[a + b + 1] += 1 res, s = n, 0 for v in d[2 : limit * 2 + 1]: s += v if res &amp;gt; s: res = s return res</description></item><item><title>1675. Minimize Deviation in Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1675/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1675/</guid><description>LeetCode problem 1675
class Solution: def minimumDeviation(self, nums: List[int]) -&amp;gt; int: h = [] mi = inf for v in nums: if v &amp;amp; 1: v &amp;lt;&amp;lt;= 1 h.append(-v) mi = min(mi, v) heapify(h) res = -h[0] - mi while h[0] % 2 == 0: x = heappop(h) // 2 heappush(h, x) mi = min(mi, -x) res = min(res, -h[0] - mi) return res</description></item><item><title>1676. Lowest Common Ancestor of a Binary Tree IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1676/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1676/</guid><description>LeetCode problem 1676
# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor( self, root: &amp;#39;TreeNode&amp;#39;, nodes: &amp;#39;List[TreeNode]&amp;#39; ) -&amp;gt; &amp;#39;TreeNode&amp;#39;: def dfs(root): if root is None or root.val in s: return root left, right = dfs(root.left), dfs(root.right) if left and right: return root return left or right s = {node.val for node in nodes} return dfs(root)</description></item><item><title>1678. Goal Parser Interpretation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1678/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1678/</guid><description>LeetCode problem 1678
class Solution: def interpret(self, command: str) -&amp;gt; str: res = [] for i, c in enumerate(command): if c == &amp;#39;G&amp;#39;: res.append(c) elif c == &amp;#39;(&amp;#39;: res.append(&amp;#39;o&amp;#39; if command[i + 1] == &amp;#39;)&amp;#39; else &amp;#39;al&amp;#39;) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1680. Concatenation of Consecutive Binary Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1680/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1680/</guid><description>LeetCode problem 1680
class Solution: def concatenatedBinary(self, n: int) -&amp;gt; int: mod = 10**9 + 7 res = shift = 0 for i in range(1, n + 1): if (i &amp;amp; (i - 1)) == 0: shift += 1 res = (res &amp;lt;&amp;lt; shift | i) % mod return res</description></item><item><title>1681. Minimum Incompatibility</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1681/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1681/</guid><description>LeetCode problem 1681
class Solution: def minimumIncompatibility(self, nums: List[int], k: int) -&amp;gt; int: @cache def dfs(mask): if mask == (1 &amp;lt;&amp;lt; n) - 1: return 0 d = {v: i for i, v in enumerate(nums) if (mask &amp;gt;&amp;gt; i &amp;amp; 1) == 0} res = inf if len(d) &amp;lt; m: return res for vs in combinations(d.keys(), m): nxt = mask for v in vs: nxt |= 1 &amp;lt;&amp;lt; d[v] res = min(res, max(vs) - min(vs) + dfs(nxt)) return res n = len(nums) m = n // k res = dfs(0) dfs.</description></item><item><title>1682. Longest Palindromic Subsequence II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1682/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1682/</guid><description>LeetCode problem 1682
class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: @cache def dfs(i, j, x): if i &amp;gt;= j: return 0 if s[i] == s[j] and s[i] != x: return dfs(i + 1, j - 1, s[i]) + 2 return max(dfs(i + 1, j, x), dfs(i, j - 1, x)) res = dfs(0, len(s) - 1, &amp;#39;&amp;#39;) dfs.cache_clear() return res</description></item><item><title>1684. Count the Number of Consistent Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1684/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1684/</guid><description>LeetCode problem 1684
class Solution: def countConsistentStrings(self, allowed: str, words: List[str]) -&amp;gt; int: def f(w): return reduce(or_, (1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) for c in w)) mask = f(allowed) return sum((mask | f(w)) == mask for w in words)</description></item><item><title>1685. Sum of Absolute Differences in a Sorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1685/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1685/</guid><description>LeetCode problem 1685
class Solution: def getSumAbsoluteDifferences(self, nums: List[int]) -&amp;gt; List[int]: res = [] s, t = sum(nums), 0 for i, x in enumerate(nums): v = x * i - t + s - t - x * (len(nums) - i) res.append(v) t += x return res</description></item><item><title>1686. Stone Game VI</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1686/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1686/</guid><description>LeetCode problem 1686
class Solution: def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -&amp;gt; int: vals = [(a + b, i) for i, (a, b) in enumerate(zip(aliceValues, bobValues))] vals.sort(reverse=True) a = sum(aliceValues[i] for _, i in vals[::2]) b = sum(bobValues[i] for _, i in vals[1::2]) if a &amp;gt; b: return 1 if a &amp;lt; b: return -1 return 0</description></item><item><title>1687. Delivering Boxes from Storage to Ports</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1687/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1687/</guid><description>LeetCode problem 1687
class Solution: def boxDelivering( self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int ) -&amp;gt; int: n = len(boxes) ws = list(accumulate((box[1] for box in boxes), initial=0)) c = [int(a != b) for a, b in pairwise(box[0] for box in boxes)] cs = list(accumulate(c, initial=0)) f = [0] * (n + 1) q = deque([0]) for i in range(1, n + 1): while q and (i - q[0] &amp;gt; maxBoxes or ws[i] - ws[q[0]] &amp;gt; maxWeight): q.</description></item><item><title>1688. Count of Matches in Tournament</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1688/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1688/</guid><description>LeetCode problem 1688
class Solution: def numberOfMatches(self, n: int) -&amp;gt; int: return n - 1</description></item><item><title>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1689/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1689/</guid><description>LeetCode problem 1689
class Solution: def minPartitions(self, n: str) -&amp;gt; int: return int(max(n))</description></item><item><title>1690. Stone Game VII</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1690/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1690/</guid><description>LeetCode problem 1690
class Solution: def stoneGameVII(self, stones: List[int]) -&amp;gt; int: s = list(accumulate(stones, initial=0)) n = len(stones) f = [[0] * n for _ in range(n)] for i in range(n - 2, -1, -1): for j in range(i + 1, n): a = s[j + 1] - s[i + 1] - f[i + 1][j] b = s[j] - s[i] - f[i][j - 1] f[i][j] = max(a, b) return f[0][-1]</description></item><item><title>1691. Maximum Height by Stacking Cuboids</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1691/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1691/</guid><description>LeetCode problem 1691
class Solution: def maxHeight(self, cuboids: List[List[int]]) -&amp;gt; int: for c in cuboids: c.sort() cuboids.sort() n = len(cuboids) f = [0] * n for i in range(n): for j in range(i): if cuboids[j][1] &amp;lt;= cuboids[i][1] and cuboids[j][2] &amp;lt;= cuboids[i][2]: f[i] = max(f[i], f[j]) f[i] += cuboids[i][2] return max(f)</description></item><item><title>1692. Count Ways to Distribute Candies</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1692/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1692/</guid><description>LeetCode problem 1692
class Solution: def waysToDistribute(self, n: int, k: int) -&amp;gt; int: mod = 10**9 + 7 f = [[0] * (k + 1) for _ in range(n + 1)] f[0][0] = 1 for i in range(1, n + 1): for j in range(1, k + 1): f[i][j] = (f[i - 1][j] * j + f[i - 1][j - 1]) % mod return f[n][k]</description></item><item><title>1694. Reformat Phone Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1694/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1694/</guid><description>LeetCode problem 1694
class Solution: def reformatNumber(self, number: str) -&amp;gt; str: number = number.replace(&amp;#34;-&amp;#34;, &amp;#34;&amp;#34;).replace(&amp;#34; &amp;#34;, &amp;#34;&amp;#34;) n = len(number) res = [number[i * 3 : i * 3 + 3] for i in range(n // 3)] if n % 3 == 1: res[-1] = res[-1][:2] res.append(number[-2:]) elif n % 3 == 2: res.append(number[-2:]) return &amp;#34;-&amp;#34;.join(res)</description></item><item><title>1695. Maximum Erasure Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1695/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1695/</guid><description>LeetCode problem 1695
class Solution: def maximumUniqueSubarray(self, nums: List[int]) -&amp;gt; int: d = defaultdict(int) s = list(accumulate(nums, initial=0)) res = j = 0 for i, v in enumerate(nums, 1): j = max(j, d[v]) res = max(res, s[i] - s[j]) d[v] = i return res</description></item><item><title>1696. Jump Game VI</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1696/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1696/</guid><description>LeetCode problem 1696
class Solution: def maxResult(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) f = [0] * n q = deque([0]) for i in range(n): if i - q[0] &amp;gt; k: q.popleft() f[i] = nums[i] + f[q[0]] while q and f[q[-1]] &amp;lt;= f[i]: q.pop() q.append(i) return f[-1]</description></item><item><title>1697. Checking Existence of Edge Length Limited Paths</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1697/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1697/</guid><description>LeetCode problem 1697
class Solution: def distanceLimitedPathsExist( self, n: int, edgeList: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[bool]: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(n)) edgeList.sort(key=lambda x: x[2]) j = 0 res = [False] * len(queries) for i, (a, b, limit) in sorted(enumerate(queries), key=lambda x: x[1][2]): while j &amp;lt; len(edgeList) and edgeList[j][2] &amp;lt; limit: u, v, _ = edgeList[j] p[find(u)] = find(v) j += 1 res[i] = find(a) == find(b) return res</description></item><item><title>1698. Number of Distinct Substrings in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1698/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1698/</guid><description>LeetCode problem 1698
class Solution: def countDistinct(self, s: str) -&amp;gt; int: base = 131 n = len(s) p = [0] * (n + 10) h = [0] * (n + 10) p[0] = 1 for i, c in enumerate(s): p[i + 1] = p[i] * base h[i + 1] = h[i] * base + ord(c) ss = set() for i in range(1, n + 1): for j in range(i, n + 1): t = h[j] - h[i - 1] * p[j - i + 1] ss.</description></item><item><title>1700. Number of Students Unable to Eat Lunch</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1700/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1700/</guid><description>LeetCode problem 1700
class Solution: def countStudents(self, students: List[int], sandwiches: List[int]) -&amp;gt; int: cnt = Counter(students) for v in sandwiches: if cnt[v] == 0: return cnt[v ^ 1] cnt[v] -= 1 return 0</description></item><item><title>1701. Average Waiting Time</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1701/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1701/</guid><description>LeetCode problem 1701
class Solution: def averageWaitingTime(self, customers: List[List[int]]) -&amp;gt; float: tot = t = 0 for a, b in customers: t = max(t, a) + b tot += t - a return tot / len(customers)</description></item><item><title>1702. Maximum Binary String After Change</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1702/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1702/</guid><description>LeetCode problem 1702
class Solution: def maximumBinaryString(self, binary: str) -&amp;gt; str: k = binary.find(&amp;#39;0&amp;#39;) if k == -1: return binary k += binary[k + 1 :].count(&amp;#39;0&amp;#39;) return &amp;#39;1&amp;#39; * k + &amp;#39;0&amp;#39; + &amp;#39;1&amp;#39; * (len(binary) - k - 1)</description></item><item><title>1703. Minimum Adjacent Swaps for K Consecutive Ones</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1703/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1703/</guid><description>LeetCode problem 1703
class Solution: def minMoves(self, nums: List[int], k: int) -&amp;gt; int: arr = [i for i, x in enumerate(nums) if x] s = list(accumulate(arr, initial=0)) res = inf x = (k + 1) // 2 y = k - x for i in range(x - 1, len(arr) - y): j = arr[i] ls = s[i + 1] - s[i + 1 - x] rs = s[i + 1 + y] - s[i + 1] a = (j + j - x + 1) * x // 2 - ls b = rs - (j + 1 + j + y) * y // 2 res = min(res, a + b) return res</description></item><item><title>1704. Determine if String Halves Are Alike</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1704/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1704/</guid><description>LeetCode problem 1704
class Solution: def halvesAreAlike(self, s: str) -&amp;gt; bool: vowels = set(&amp;#39;aeiouAEIOU&amp;#39;) a, b = s[: len(s) &amp;gt;&amp;gt; 1], s[len(s) &amp;gt;&amp;gt; 1 :] return sum(c in vowels for c in a) == sum(c in vowels for c in b)</description></item><item><title>1705. Maximum Number of Eaten Apples</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1705/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1705/</guid><description>LeetCode problem 1705
class Solution: def eatenApples(self, apples: List[int], days: List[int]) -&amp;gt; int: n = len(days) i = res = 0 q = [] while i &amp;lt; n or q: if i &amp;lt; n and apples[i]: heappush(q, (i + days[i] - 1, apples[i])) while q and q[0][0] &amp;lt; i: heappop(q) if q: t, v = heappop(q) v -= 1 res += 1 if v and t &amp;gt; i: heappush(q, (t, v)) i += 1 return res</description></item><item><title>1706. Where Will the Ball Fall</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1706/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1706/</guid><description>LeetCode problem 1706
class Solution: def findBall(self, grid: List[List[int]]) -&amp;gt; List[int]: def dfs(i: int, j: int) -&amp;gt; int: if i == m: return j if j == 0 and grid[i][j] == -1: return -1 if j == n - 1 and grid[i][j] == 1: return -1 if grid[i][j] == 1 and grid[i][j + 1] == -1: return -1 if grid[i][j] == -1 and grid[i][j - 1] == 1: return -1 return dfs(i + 1, j + 1) if grid[i][j] == 1 else dfs(i + 1, j - 1) m, n = len(grid), len(grid[0]) return [dfs(0, j) for j in range(n)]</description></item><item><title>1707. Maximum XOR With an Element From Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1707/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1707/</guid><description>LeetCode problem 1707
class Trie: __slots__ = [&amp;#34;children&amp;#34;] def __init__(self): self.children = [None] * 2 def insert(self, x: int): node = self for i in range(30, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v] is None: node.children[v] = Trie() node = node.children[v] def search(self, x: int) -&amp;gt; int: node = self res = 0 for i in range(30, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v ^ 1]: res |= 1 &amp;lt;&amp;lt; i node = node.</description></item><item><title>1708. Largest Subarray Length K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1708/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1708/</guid><description>LeetCode problem 1708
class Solution: def largestSubarray(self, nums: List[int], k: int) -&amp;gt; List[int]: i = nums.index(max(nums[: len(nums) - k + 1])) return nums[i : i + k]</description></item><item><title>1710. Maximum Units on a Truck</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1710/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1710/</guid><description>LeetCode problem 1710
class Solution: def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -&amp;gt; int: cnt = [0] * 1001 for a, b in boxTypes: cnt[b] += a res = 0 for b in range(1000, 0, -1): a = cnt[b] if a: res += b * min(truckSize, a) truckSize -= a if truckSize &amp;lt;= 0: break return res</description></item><item><title>1711. Count Good Meals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1711/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1711/</guid><description>LeetCode problem 1711
class Solution: def countPairs(self, deliciousness: List[int]) -&amp;gt; int: mod = 10**9 + 7 cnt = Counter(deliciousness) res = 0 for i in range(22): s = 1 &amp;lt;&amp;lt; i for a, m in cnt.items(): if (b := s - a) in cnt: res += m * (m - 1) if a == b else m * cnt[b] return (res &amp;gt;&amp;gt; 1) % mod</description></item><item><title>1712. Ways to Split Array Into Three Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1712/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1712/</guid><description>LeetCode problem 1712
class Solution: def waysToSplit(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 s = list(accumulate(nums)) res, n = 0, len(nums) for i in range(n - 2): j = bisect_left(s, s[i] &amp;lt;&amp;lt; 1, i + 1, n - 1) k = bisect_right(s, (s[-1] + s[i]) &amp;gt;&amp;gt; 1, j, n - 1) res += k - j return res % mod</description></item><item><title>1713. Minimum Operations to Make a Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1713/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1713/</guid><description>LeetCode problem 1713
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) @staticmethod def lowbit(x): return x &amp;amp; -x def update(self, x, val): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], val) x += BinaryIndexedTree.lowbit(x) def query(self, x): s = 0 while x: s = max(s, self.c[x]) x -= BinaryIndexedTree.lowbit(x) return s class Solution: def minOperations(self, target: List[int], arr: List[int]) -&amp;gt; int: d = {v: i for i, v in enumerate(target)} nums = [d[v] for v in arr if v in d] return len(target) - self.</description></item><item><title>1714. Sum Of Special Evenly-Spaced Elements In Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1714/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1714/</guid><description>LeetCode problem 1714
class Solution: def solve(self, nums: List[int], queries: List[List[int]]) -&amp;gt; List[int]: mod = 10**9 + 7 n = len(nums) m = int(sqrt(n)) suf = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(n - 1, -1, -1): suf[i][j] = suf[i][min(n, j + i)] + nums[j] res = [] for x, y in queries: if y &amp;lt;= m: res.append(suf[y][x] % mod) else: res.append(sum(nums[x::y]) % mod) return res</description></item><item><title>1716. Calculate Money in Leetcode Bank</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1716/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1716/</guid><description>LeetCode problem 1716
class Solution: def totalMoney(self, n: int) -&amp;gt; int: a, b = divmod(n, 7) return (28 + 28 + 7 * (a - 1)) * a // 2 + (a * 2 + b + 1) * b // 2</description></item><item><title>1717. Maximum Score From Removing Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1717/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1717/</guid><description>LeetCode problem 1717
class Solution: def maximumGain(self, s: str, x: int, y: int) -&amp;gt; int: if x &amp;lt; y: return self.maximumGain(s[::-1], y, x) res = 0 stk1, stk2 = [], [] for c in s: if c != &amp;#39;b&amp;#39;: stk1.append(c) else: if stk1 and stk1[-1] == &amp;#39;a&amp;#39;: stk1.pop() res += x else: stk1.append(c) while stk1: c = stk1.pop() if c != &amp;#39;b&amp;#39;: stk2.append(c) else: if stk2 and stk2[-1] == &amp;#39;a&amp;#39;: stk2.pop() res += y else: stk2.append(c) return res</description></item><item><title>1718. Construct the Lexicographically Largest Valid Sequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1718/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1718/</guid><description>LeetCode problem 1718
class Solution: def constructDistancedSequence(self, n: int) -&amp;gt; List[int]: def dfs(u): if u == n * 2: return True if path[u]: return dfs(u + 1) for i in range(n, 1, -1): if cnt[i] and u + i &amp;lt; n * 2 and path[u + i] == 0: cnt[i] = 0 path[u] = path[u + i] = i if dfs(u + 1): return True path[u] = path[u + i] = 0 cnt[i] = 2 if cnt[1]: cnt[1], path[u] = 0, 1 if dfs(u + 1): return True path[u], cnt[1] = 0, 1 return False path = [0] * (n * 2) cnt = [2] * (n * 2) cnt[1] = 1 dfs(1) return path[1:]</description></item><item><title>1719. Number Of Ways To Reconstruct A Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1719/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1719/</guid><description>LeetCode problem 1719
class Solution: def checkWays(self, pairs: List[List[int]]) -&amp;gt; int: g = [[False] * 510 for _ in range(510)] v = defaultdict(list) for x, y in pairs: g[x][y] = g[y][x] = True v[x].append(y) v[y].append(x) nodes = [] for i in range(510): if v[i]: nodes.append(i) g[i][i] = True nodes.sort(key=lambda x: len(v[x])) equal = False root = 0 for i, x in enumerate(nodes): j = i + 1 while j &amp;lt; len(nodes) and not g[x][nodes[j]]: j += 1 if j &amp;lt; len(nodes): y = nodes[j] if len(v[x]) == len(v[y]): equal = True for z in v[x]: if not g[y][z]: return 0 else: root += 1 if root &amp;gt; 1: return 0 return 2 if equal else 1</description></item><item><title>1720. Decode XORed Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1720/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1720/</guid><description>LeetCode problem 1720
class Solution: def decode(self, encoded: List[int], first: int) -&amp;gt; List[int]: res = [first] for e in encoded: res.append(res[-1] ^ e) return res</description></item><item><title>1721. Swapping Nodes in a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1721/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1721/</guid><description>LeetCode problem 1721
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def swapNodes(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: fast = slow = head for _ in range(k - 1): fast = fast.next p = fast while fast.next: fast, slow = fast.next, slow.next q = slow p.val, q.val = q.val, p.val return head</description></item><item><title>1722. Minimize Hamming Distance After Swap Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1722/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1722/</guid><description>LeetCode problem 1722
class Solution: def minimumHammingDistance( self, source: List[int], target: List[int], allowedSwaps: List[List[int]] ) -&amp;gt; int: def find(x: int) -&amp;gt; int: if p[x] != x: p[x] = find(p[x]) return p[x] n = len(source) p = list(range(n)) for a, b in allowedSwaps: p[find(a)] = find(b) cnt = defaultdict(Counter) for i, x in enumerate(source): j = find(i) cnt[j][x] += 1 res = 0 for i, x in enumerate(target): j = find(i) cnt[j][x] -= 1 res += cnt[j][x] &amp;lt; 0 return res</description></item><item><title>1723. Find Minimum Time to Finish All Jobs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1723/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1723/</guid><description>LeetCode problem 1723
class Solution: def minimumTimeRequired(self, jobs: List[int], k: int) -&amp;gt; int: def dfs(i): nonlocal res if i == len(jobs): res = min(res, max(cnt)) return for j in range(k): if cnt[j] + jobs[i] &amp;gt;= res: continue cnt[j] += jobs[i] dfs(i + 1) cnt[j] -= jobs[i] if cnt[j] == 0: break cnt = [0] * k jobs.sort(reverse=True) res = inf dfs(0) return res</description></item><item><title>1724. Checking Existence of Edge Length Limited Paths II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1724/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1724/</guid><description>LeetCode problem 1724
class PersistentUnionFind: def __init__(self, n): self.rank = [0] * n self.p = list(range(n)) self.version = [inf] * n def find(self, x, t=inf): if self.p[x] == x or self.version[x] &amp;gt;= t: return x return self.find(self.p[x], t) def union(self, a, b, t): pa, pb = self.find(a), self.find(b) if pa == pb: return False if self.rank[pa] &amp;gt; self.rank[pb]: self.version[pb] = t self.p[pb] = pa else: self.version[pa] = t self.p[pa] = pb if self.rank[pa] == self.rank[pb]: self.rank[pb] += 1 return True class DistanceLimitedPathsExist: def __init__(self, n: int, edgeList: List[List[int]]): self.</description></item><item><title>1725. Number Of Rectangles That Can Form The Largest Square</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1725/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1725/</guid><description>LeetCode problem 1725
class Solution: def countGoodRectangles(self, rectangles: List[List[int]]) -&amp;gt; int: res = mx = 0 for l, w in rectangles: x = min(l, w) if mx &amp;lt; x: res = 1 mx = x elif mx == x: res += 1 return res</description></item><item><title>1726. Tuple with Same Product</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1726/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1726/</guid><description>LeetCode problem 1726
class Solution: def tupleSameProduct(self, nums: List[int]) -&amp;gt; int: cnt = defaultdict(int) for i in range(1, len(nums)): for j in range(i): x = nums[i] * nums[j] cnt[x] += 1 return sum(v * (v - 1) // 2 for v in cnt.values()) &amp;lt;&amp;lt; 3</description></item><item><title>1727. Largest Submatrix With Rearrangements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1727/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1727/</guid><description>LeetCode problem 1727
class Solution: def largestSubmatrix(self, matrix: List[List[int]]) -&amp;gt; int: for i in range(1, len(matrix)): for j in range(len(matrix[0])): if matrix[i][j]: matrix[i][j] = matrix[i - 1][j] + 1 res = 0 for row in matrix: row.sort(reverse=True) for j, v in enumerate(row, 1): res = max(res, j * v) return res</description></item><item><title>1728. Cat and Mouse II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1728/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1728/</guid><description>LeetCode problem 1728
class Solution: def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -&amp;gt; bool: dirs = [0, 1, 0, -1, 0] m = len(grid) n = len(grid[0]) nFloors = 0 cat = 0 # cat&amp;#39;s position mouse = 0 # mouse&amp;#39;s position def hash(i: int, j: int) -&amp;gt; int: return i * n + j for i in range(m): for j in range(n): if grid[i][j] != &amp;#34;#&amp;#34;: nFloors += 1 if grid[i][j] == &amp;#34;C&amp;#34;: cat = hash(i, j) elif grid[i][j] == &amp;#34;M&amp;#34;: mouse = hash(i, j) # dp(i, j, k) := True if mouse can win w// # Cat on (i // 8, i % 8), mouse on (j // 8, j % 8), and turns = k @functools.</description></item><item><title>1730. Shortest Path to Get Food</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1730/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1730/</guid><description>LeetCode problem 1730
class Solution: def getFood(self, grid: List[List[str]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) i, j = next((i, j) for i in range(m) for j in range(n) if grid[i][j] == &amp;#39;*&amp;#39;) q = deque([(i, j)]) dirs = (-1, 0, 1, 0, -1) res = 0 while q: res += 1 for _ in range(len(q)): i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n: if grid[x][y] == &amp;#39;#&amp;#39;: return res if grid[x][y] == &amp;#39;O&amp;#39;: grid[x][y] = &amp;#39;X&amp;#39; q.</description></item><item><title>1733. Minimum Number of People to Teach</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1733/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1733/</guid><description>LeetCode problem 1733
class Solution: def minimumTeachings( self, n: int, languages: List[List[int]], friendships: List[List[int]] ) -&amp;gt; int: def check(u, v): for x in languages[u - 1]: for y in languages[v - 1]: if x == y: return True return False s = set() for u, v in friendships: if not check(u, v): s.add(u) s.add(v) cnt = Counter() for u in s: for l in languages[u - 1]: cnt[l] += 1 return len(s) - max(cnt.values(), default=0)</description></item><item><title>1734. Decode XORed Permutation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1734/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1734/</guid><description>LeetCode problem 1734
class Solution: def decode(self, encoded: List[int]) -&amp;gt; List[int]: n = len(encoded) + 1 a = b = 0 for i in range(0, n - 1, 2): a ^= encoded[i] for i in range(1, n + 1): b ^= i perm = [0] * n perm[-1] = a ^ b for i in range(n - 2, -1, -1): perm[i] = encoded[i] ^ perm[i + 1] return perm</description></item><item><title>1735. Count Ways to Make Array With Product</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1735/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1735/</guid><description>LeetCode problem 1735
N = 10020 MOD = 10**9 + 7 f = [1] * N g = [1] * N p = defaultdict(list) for i in range(1, N): f[i] = f[i - 1] * i % MOD g[i] = pow(f[i], MOD - 2, MOD) x = i j = 2 while j &amp;lt;= x // j: if x % j == 0: cnt = 0 while x % j == 0: cnt += 1 x //= j p[i].</description></item><item><title>1736. Latest Time by Replacing Hidden Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1736/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1736/</guid><description>LeetCode problem 1736
class Solution: def maximumTime(self, time: str) -&amp;gt; str: t = list(time) if t[0] == &amp;#39;?&amp;#39;: t[0] = &amp;#39;1&amp;#39; if &amp;#39;4&amp;#39; &amp;lt;= t[1] &amp;lt;= &amp;#39;9&amp;#39; else &amp;#39;2&amp;#39; if t[1] == &amp;#39;?&amp;#39;: t[1] = &amp;#39;3&amp;#39; if t[0] == &amp;#39;2&amp;#39; else &amp;#39;9&amp;#39; if t[3] == &amp;#39;?&amp;#39;: t[3] = &amp;#39;5&amp;#39; if t[4] == &amp;#39;?&amp;#39;: t[4] = &amp;#39;9&amp;#39; return &amp;#39;&amp;#39;.join(t)</description></item><item><title>1737. Change Minimum Characters to Satisfy One of Three Conditions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1737/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1737/</guid><description>LeetCode problem 1737
class Solution: def minCharacters(self, a: str, b: str) -&amp;gt; int: def f(cnt1, cnt2): for i in range(1, 26): t = sum(cnt1[i:]) + sum(cnt2[:i]) nonlocal res res = min(res, t) m, n = len(a), len(b) cnt1 = [0] * 26 cnt2 = [0] * 26 for c in a: cnt1[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 for c in b: cnt2[ord(c) - ord(&amp;#39;a&amp;#39;)] += 1 res = m + n for c1, c2 in zip(cnt1, cnt2): res = min(res, m + n - c1 - c2) f(cnt1, cnt2) f(cnt2, cnt1) return res</description></item><item><title>1738. Find Kth Largest XOR Coordinate Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1738/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1738/</guid><description>LeetCode problem 1738
class Solution: def kthLargestValue(self, matrix: List[List[int]], k: int) -&amp;gt; int: m, n = len(matrix), len(matrix[0]) s = [[0] * (n + 1) for _ in range(m + 1)] res = [] for i in range(m): for j in range(n): s[i + 1][j + 1] = s[i + 1][j] ^ s[i][j + 1] ^ s[i][j] ^ matrix[i][j] res.append(s[i + 1][j + 1]) return nlargest(k, res)[-1]</description></item><item><title>1739. Building Boxes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1739/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1739/</guid><description>LeetCode problem 1739
class Solution: def minimumBoxes(self, n: int) -&amp;gt; int: s, k = 0, 1 while s + k * (k + 1) // 2 &amp;lt;= n: s += k * (k + 1) // 2 k += 1 k -= 1 res = k * (k + 1) // 2 k = 1 while s &amp;lt; n: res += 1 s += k k += 1 return res</description></item><item><title>1740. Find Distance in a Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1740/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1740/</guid><description>LeetCode problem 1740
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findDistance(self, root: Optional[TreeNode], p: int, q: int) -&amp;gt; int: def lca(root, p, q): if root is None or root.val in [p, q]: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left is None: return right if right is None: return left return root def dfs(root, v): if root is None: return -1 if root.</description></item><item><title>1742. Maximum Number of Balls in a Box</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1742/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1742/</guid><description>LeetCode problem 1742
class Solution: def countBalls(self, lowLimit: int, highLimit: int) -&amp;gt; int: cnt = [0] * 50 for x in range(lowLimit, highLimit + 1): y = 0 while x: y += x % 10 x //= 10 cnt[y] += 1 return max(cnt)</description></item><item><title>1743. Restore the Array From Adjacent Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1743/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1743/</guid><description>LeetCode problem 1743
class Solution: def restoreArray(self, adjacentPairs: List[List[int]]) -&amp;gt; List[int]: def dfs(i, fa): res.append(i) for j in g[i]: if j != fa: dfs(j, i) g = defaultdict(list) for a, b in adjacentPairs: g[a].append(b) g[b].append(a) i = next(i for i, v in g.items() if len(v) == 1) res = [] dfs(i, 1e6) return res</description></item><item><title>1744. Can You Eat Your Favorite Candy on Your Favorite Day</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1744/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1744/</guid><description>LeetCode problem 1744
class Solution: def canEat(self, candiesCount: List[int], queries: List[List[int]]) -&amp;gt; List[bool]: s = list(accumulate(candiesCount, initial=0)) res = [] for t, day, mx in queries: least, most = day, (day + 1) * mx res.append(least &amp;lt; s[t + 1] and most &amp;gt; s[t]) return res</description></item><item><title>1745. Palindrome Partitioning IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1745/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1745/</guid><description>LeetCode problem 1745
class Solution: def checkPartitioning(self, s: str) -&amp;gt; bool: n = len(s) g = [[True] * n for _ in range(n)] for i in range(n - 1, -1, -1): for j in range(i + 1, n): g[i][j] = s[i] == s[j] and (i + 1 == j or g[i + 1][j - 1]) for i in range(n - 2): for j in range(i + 1, n - 1): if g[0][i] and g[i + 1][j] and g[j + 1][-1]: return True return False</description></item><item><title>1746. Maximum Subarray Sum After One Operation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1746/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1746/</guid><description>LeetCode problem 1746
class Solution: def maxSumAfterOperation(self, nums: List[int]) -&amp;gt; int: f = g = 0 res = -inf for x in nums: ff = max(f, 0) + x gg = max(max(f, 0) + x * x, g + x) f, g = ff, gg res = max(res, f, g) return res</description></item><item><title>1748. Sum of Unique Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1748/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1748/</guid><description>LeetCode problem 1748
class Solution: def sumOfUnique(self, nums: List[int]) -&amp;gt; int: cnt = Counter(nums) return sum(x for x, v in cnt.items() if v == 1)</description></item><item><title>1749. Maximum Absolute Sum of Any Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1749/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1749/</guid><description>LeetCode problem 1749
class Solution: def maxAbsoluteSum(self, nums: List[int]) -&amp;gt; int: f = g = 0 res = 0 for x in nums: f = max(f, 0) + x g = min(g, 0) + x res = max(res, f, abs(g)) return res</description></item><item><title>1750. Minimum Length of String After Deleting Similar Ends</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1750/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1750/</guid><description>LeetCode problem 1750
class Solution: def minimumLength(self, s: str) -&amp;gt; int: p1 = 0 p2 = len(s) - 1 while p1 &amp;lt; p2 and s[p1] == s[p2]: c = s[p1] while p1 &amp;lt;= p2 and s[p1] == c: p1 += 1 while p1 &amp;lt;= p2 and s[p2] == c: p2 -= 1 return p2 - p1 + 1</description></item><item><title>1751. Maximum Number of Events That Can Be Attended II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1751/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1751/</guid><description>LeetCode problem 1751
class Solution: def maxValue(self, events: List[List[int]], k: int) -&amp;gt; int: events.sort(key=lambda x: x[1]) n = len(events) f = [[0] * (k + 1) for _ in range(n + 1)] for i, (st, _, val) in enumerate(events, 1): p = bisect_left(events, st, hi=i - 1, key=lambda x: x[1]) for j in range(1, k + 1): f[i][j] = max(f[i - 1][j], f[p][j - 1] + val) return f[n][k]</description></item><item><title>1752. Check if Array Is Sorted and Rotated</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1752/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1752/</guid><description>LeetCode problem 1752
class Solution: def check(self, nums: List[int]) -&amp;gt; bool: return sum(nums[i - 1] &amp;gt; v for i, v in enumerate(nums)) &amp;lt;= 1</description></item><item><title>1753. Maximum Score From Removing Stones</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1753/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1753/</guid><description>LeetCode problem 1753
class Solution: def maximumScore(self, a: int, b: int, c: int) -&amp;gt; int: a, b, c = sorted([a, b, c]) if a + b &amp;lt; c: return a + b return (a + b + c) &amp;gt;&amp;gt; 1</description></item><item><title>1754. Largest Merge Of Two Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1754/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1754/</guid><description>LeetCode problem 1754
class Solution: def largestMerge(self, word1: str, word2: str) -&amp;gt; str: i = j = 0 res = [] while i &amp;lt; len(word1) and j &amp;lt; len(word2): if word1[i:] &amp;gt; word2[j:]: res.append(word1[i]) i += 1 else: res.append(word2[j]) j += 1 res.append(word1[i:]) res.append(word2[j:]) return &amp;#34;&amp;#34;.join(res)</description></item><item><title>1755. Closest Subsequence Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1755/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1755/</guid><description>LeetCode problem 1755
class Solution: def minAbsDifference(self, nums: List[int], goal: int) -&amp;gt; int: def dfs(arr, res, i, s): if i == len(arr): res.add(s) return dfs(arr, res, i + 1, s) dfs(arr, res, i + 1, s + arr[i]) n = len(nums) left, right = set(), set() dfs(nums[: n &amp;gt;&amp;gt; 1], left, 0, 0) dfs(nums[n &amp;gt;&amp;gt; 1 :], right, 0, 0) right = sorted(right) res = inf for l in left: x = goal - l i = bisect_left(right, x) if i &amp;lt; len(right): res = min(res, abs(x - right[i])) if i: res = min(res, abs(x - right[i - 1])) return res</description></item><item><title>1756. Design Most Recently Used Queue</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1756/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1756/</guid><description>LeetCode problem 1756
class BinaryIndexedTree: def __init__(self, n: int): self.n = n self.c = [0] * (n + 1) def update(self, x: int, v: int): while x &amp;lt;= self.n: self.c[x] += v x += x &amp;amp; -x def query(self, x: int) -&amp;gt; int: s = 0 while x: s += self.c[x] x -= x &amp;amp; -x return s class MRUQueue: def __init__(self, n: int): self.q = list(range(n + 1)) self.tree = BinaryIndexedTree(n + 2010) def fetch(self, k: int) -&amp;gt; int: l, r = 1, len(self.</description></item><item><title>1757. Recyclable and Low Fat Products</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1757/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1757/</guid><description>LeetCode problem 1757
import pandas as pd def find_products(products: pd.DataFrame) -&amp;gt; pd.DataFrame: rs = products[(products[&amp;#34;low_fats&amp;#34;] == &amp;#34;Y&amp;#34;) &amp;amp; (products[&amp;#34;recyclable&amp;#34;] == &amp;#34;Y&amp;#34;)] rs = rs[[&amp;#34;product_id&amp;#34;]] return rs</description></item><item><title>1758. Minimum Changes To Make Alternating Binary String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1758/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1758/</guid><description>LeetCode problem 1758
class Solution: def minOperations(self, s: str) -&amp;gt; int: cnt = sum(c != &amp;#39;01&amp;#39;[i &amp;amp; 1] for i, c in enumerate(s)) return min(cnt, len(s) - cnt)</description></item><item><title>1759. Count Number of Homogenous Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1759/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1759/</guid><description>LeetCode problem 1759
class Solution: def countHomogenous(self, s: str) -&amp;gt; int: mod = 10**9 + 7 res = cnt = 1 for a, b in pairwise(s): cnt = cnt + 1 if a == b else 1 res = (res + cnt) % mod return res</description></item><item><title>1760. Minimum Limit of Balls in a Bag</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1760/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1760/</guid><description>LeetCode problem 1760
class Solution: def minimumSize(self, nums: List[int], maxOperations: int) -&amp;gt; int: def check(mx: int) -&amp;gt; bool: return sum((x - 1) // mx for x in nums) &amp;lt;= maxOperations return bisect_left(range(1, max(nums)), True, key=check) + 1</description></item><item><title>1761. Minimum Degree of a Connected Trio in a Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1761/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1761/</guid><description>LeetCode problem 1761
class Solution: def minTrioDegree(self, n: int, edges: List[List[int]]) -&amp;gt; int: g = [[False] * n for _ in range(n)] deg = [0] * n for u, v in edges: u, v = u - 1, v - 1 g[u][v] = g[v][u] = True deg[u] += 1 deg[v] += 1 res = inf for i in range(n): for j in range(i + 1, n): if g[i][j]: for k in range(j + 1, n): if g[i][k] and g[j][k]: res = min(res, deg[i] + deg[j] + deg[k] - 6) return -1 if res == inf else res</description></item><item><title>1762. Buildings With an Ocean View</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1762/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1762/</guid><description>LeetCode problem 1762
class Solution: def findBuildings(self, heights: List[int]) -&amp;gt; List[int]: res = [] mx = 0 for i in range(len(heights) - 1, -1, -1): if heights[i] &amp;gt; mx: res.append(i) mx = heights[i] return res[::-1]</description></item><item><title>1763. Longest Nice Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1763/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1763/</guid><description>LeetCode problem 1763
class Solution: def longestNiceSubstring(self, s: str) -&amp;gt; str: n = len(s) res = &amp;#39;&amp;#39; for i in range(n): lower = upper = 0 for j in range(i, n): if s[j].islower(): lower |= 1 &amp;lt;&amp;lt; (ord(s[j]) - ord(&amp;#39;a&amp;#39;)) else: upper |= 1 &amp;lt;&amp;lt; (ord(s[j]) - ord(&amp;#39;A&amp;#39;)) if lower == upper and len(res) &amp;lt; j - i + 1: res = s[i : j + 1] return res</description></item><item><title>1764. Form Array by Concatenating Subarrays of Another Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1764/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1764/</guid><description>LeetCode problem 1764
class Solution: def canChoose(self, groups: List[List[int]], nums: List[int]) -&amp;gt; bool: n, m = len(groups), len(nums) i = j = 0 while i &amp;lt; n and j &amp;lt; m: g = groups[i] if g == nums[j : j + len(g)]: j += len(g) i += 1 else: j += 1 return i == n</description></item><item><title>1765. Map of Highest Peak</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1765/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1765/</guid><description>LeetCode problem 1765
class Solution: def highestPeak(self, isWater: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(isWater), len(isWater[0]) res = [[-1] * n for _ in range(m)] q = deque() for i, row in enumerate(isWater): for j, v in enumerate(row): if v: q.append((i, j)) res[i][j] = 0 while q: for _ in range(len(q)): i, j = q.popleft() for a, b in pairwise((-1, 0, 1, 0, -1)): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and res[x][y] == -1: res[x][y] = res[i][j] + 1 q.</description></item><item><title>1766. Tree of Coprimes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1766/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1766/</guid><description>LeetCode problem 1766
class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -&amp;gt; List[int]: def dfs(i, fa, depth): t = k = -1 for v in f[nums[i]]: stk = stks[v] if stk and stk[-1][1] &amp;gt; k: t, k = stk[-1] res[i] = t for j in g[i]: if j != fa: stks[nums[i]].append((i, depth)) dfs(j, i, depth + 1) stks[nums[i]].pop() g = defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) f = defaultdict(list) for i in range(1, 51): for j in range(1, 51): if gcd(i, j) == 1: f[i].</description></item><item><title>1769. Minimum Number of Operations to Move All Balls to Each Box</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1769/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1769/</guid><description>LeetCode problem 1769
class Solution: def minOperations(self, boxes: str) -&amp;gt; List[int]: n = len(boxes) res = [0] * n cnt = 0 for i in range(1, n): if boxes[i - 1] == &amp;#39;1&amp;#39;: cnt += 1 res[i] = res[i - 1] + cnt cnt = s = 0 for i in range(n - 2, -1, -1): if boxes[i + 1] == &amp;#39;1&amp;#39;: cnt += 1 s += cnt res[i] += s return res</description></item><item><title>1770. Maximum Score from Performing Multiplication Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1770/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1770/</guid><description>LeetCode problem 1770
class Solution: def maximumScore(self, nums: List[int], multipliers: List[int]) -&amp;gt; int: n, m = len(nums), len(multipliers) f = [[-inf] * (m + 1) for _ in range(m + 1)] f[0][0] = 0 res = -inf for i in range(m + 1): for j in range(m - i + 1): k = i + j - 1 if i &amp;gt; 0: f[i][j] = max(f[i][j], f[i - 1][j] + multipliers[k] * nums[i - 1]) if j &amp;gt; 0: f[i][j] = max(f[i][j], f[i][j - 1] + multipliers[k] * nums[n - j]) if i + j == m: res = max(res, f[i][j]) return res</description></item><item><title>1771. Maximize Palindrome Length From Subsequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1771/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1771/</guid><description>LeetCode problem 1771
class Solution: def longestPalindrome(self, word1: str, word2: str) -&amp;gt; int: s = word1 + word2 n = len(s) f = [[0] * n for _ in range(n)] for i in range(n): f[i][i] = 1 res = 0 for i in range(n - 2, -1, -1): for j in range(i + 1, n): if s[i] == s[j]: f[i][j] = f[i + 1][j - 1] + 2 if i &amp;lt; len(word1) &amp;lt;= j: res = max(res, f[i][j]) else: f[i][j] = max(f[i + 1][j], f[i][j - 1]) return res</description></item><item><title>1772. Sort Features by Popularity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1772/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1772/</guid><description>LeetCode problem 1772
class Solution: def sortFeatures(self, features: List[str], responses: List[str]) -&amp;gt; List[str]: cnt = Counter() for s in responses: for w in set(s.split()): cnt[w] += 1 return sorted(features, key=lambda w: -cnt[w])</description></item><item><title>1773. Count Items Matching a Rule</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1773/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1773/</guid><description>LeetCode problem 1773
class Solution: def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -&amp;gt; int: i = 0 if ruleKey[0] == &amp;#39;t&amp;#39; else (1 if ruleKey[0] == &amp;#39;c&amp;#39; else 2) return sum(v[i] == ruleValue for v in items)</description></item><item><title>1774. Closest Dessert Cost</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1774/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1774/</guid><description>LeetCode problem 1774
class Solution: def closestCost( self, baseCosts: List[int], toppingCosts: List[int], target: int ) -&amp;gt; int: def dfs(i, t): if i &amp;gt;= len(toppingCosts): arr.append(t) return dfs(i + 1, t) dfs(i + 1, t + toppingCosts[i]) arr = [] dfs(0, 0) arr.sort() d = res = inf # 选择一种冰激淋基料 for x in baseCosts: # 枚举子集和 for y in arr: # 二分查找 i = bisect_left(arr, target - x - y) for j in (i, i - 1): if 0 &amp;lt;= j &amp;lt; len(arr): t = abs(x + y + arr[j] - target) if d &amp;gt; t or (d == t and res &amp;gt; x + y + arr[j]): d = t res = x + y + arr[j] return res</description></item><item><title>1775. Equal Sum Arrays With Minimum Number of Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1775/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1775/</guid><description>LeetCode problem 1775
class Solution: def minOperations(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: s1, s2 = sum(nums1), sum(nums2) if s1 == s2: return 0 if s1 &amp;gt; s2: return self.minOperations(nums2, nums1) cnt = Counter([6 - v for v in nums1] + [v - 1 for v in nums2]) d = s2 - s1 res = 0 for i in range(5, 0, -1): while cnt[i] and d &amp;gt; 0: d -= i cnt[i] -= 1 res += 1 return res if d &amp;lt;= 0 else -1</description></item><item><title>1776. Car Fleet II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1776/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1776/</guid><description>LeetCode problem 1776
class Solution: def getCollisionTimes(self, cars: List[List[int]]) -&amp;gt; List[float]: stk = [] n = len(cars) res = [-1] * n for i in range(n - 1, -1, -1): while stk: j = stk[-1] if cars[i][1] &amp;gt; cars[j][1]: t = (cars[j][0] - cars[i][0]) / (cars[i][1] - cars[j][1]) if res[j] == -1 or t &amp;lt;= res[j]: res[i] = t break stk.pop() stk.append(i) return res</description></item><item><title>1778. Shortest Path in a Hidden Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1778/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1778/</guid><description>LeetCode problem 1778
# &amp;#34;&amp;#34;&amp;#34; # This is GridMaster&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class GridMaster(object): # def canMove(self, direction: str) -&amp;gt; bool: # # # def move(self, direction: str) -&amp;gt; bool: # # # def isTarget(self) -&amp;gt; None: # # class Solution(object): def findShortestPath(self, master: &amp;#34;GridMaster&amp;#34;) -&amp;gt; int: def dfs(i: int, j: int): if master.isTarget(): nonlocal target target = (i, j) return for k, c in enumerate(s): x, y = i + dirs[k], j + dirs[k + 1] if master.</description></item><item><title>1779. Find Nearest Point That Has the Same X or Y Coordinate</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1779/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1779/</guid><description>LeetCode problem 1779
class Solution: def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -&amp;gt; int: res, mi = -1, inf for i, (a, b) in enumerate(points): if a == x or b == y: d = abs(a - x) + abs(b - y) if mi &amp;gt; d: res, mi = i, d return res</description></item><item><title>1780. Check if Number is a Sum of Powers of Three</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1780/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1780/</guid><description>LeetCode problem 1780
class Solution: def checkPowersOfThree(self, n: int) -&amp;gt; bool: while n: if n % 3 &amp;gt; 1: return False n //= 3 return True</description></item><item><title>1781. Sum of Beauty of All Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1781/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1781/</guid><description>LeetCode problem 1781
class Solution: def beautySum(self, s: str) -&amp;gt; int: res, n = 0, len(s) for i in range(n): cnt = Counter() freq = Counter() mi = mx = 1 for j in range(i, n): freq[cnt[s[j]]] -= 1 cnt[s[j]] += 1 freq[cnt[s[j]]] += 1 if cnt[s[j]] == 1: mi = 1 if freq[mi] == 0: mi += 1 if cnt[s[j]] &amp;gt; mx: mx = cnt[s[j]] res += mx - mi return res</description></item><item><title>1782. Count Pairs Of Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1782/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1782/</guid><description>LeetCode problem 1782
class Solution: def countPairs( self, n: int, edges: List[List[int]], queries: List[int] ) -&amp;gt; List[int]: cnt = [0] * n g = defaultdict(int) for a, b in edges: a, b = a - 1, b - 1 a, b = min(a, b), max(a, b) cnt[a] += 1 cnt[b] += 1 g[(a, b)] += 1 s = sorted(cnt) res = [0] * len(queries) for i, t in enumerate(queries): for j, x in enumerate(s): k = bisect_right(s, t - x, lo=j + 1) res[i] += n - k for (a, b), v in g.</description></item><item><title>1784. Check if Binary String Has at Most One Segment of Ones</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1784/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1784/</guid><description>LeetCode problem 1784
class Solution: def checkOnesSegment(self, s: str) -&amp;gt; bool: return &amp;#39;01&amp;#39; not in s</description></item><item><title>1785. Minimum Elements to Add to Form a Given Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1785/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1785/</guid><description>LeetCode problem 1785
class Solution: def minElements(self, nums: List[int], limit: int, goal: int) -&amp;gt; int: d = abs(sum(nums) - goal) return (d + limit - 1) // limit</description></item><item><title>1786. Number of Restricted Paths From First to Last Node</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1786/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1786/</guid><description>LeetCode problem 1786
class Solution: def countRestrictedPaths(self, n: int, edges: List[List[int]]) -&amp;gt; int: g = defaultdict(list) for u, v, w in edges: g[u].append((v, w)) g[v].append((u, w)) dist = [inf] * (n + 1) dist[n] = 0 q = [(0, n)] mod = 10**9 + 7 while q: _, u = heappop(q) for v, w in g[u]: if dist[v] &amp;gt; dist[u] + w: dist[v] = dist[u] + w heappush(q, (dist[v], v)) arr = list(range(1, n + 1)) arr.sort(key=lambda i: dist[i]) f = [0] * (n + 1) f[n] = 1 for i in arr: for j, _ in g[i]: if dist[i] &amp;gt; dist[j]: f[i] = (f[i] + f[j]) % mod return f[1]</description></item><item><title>1787. Make the XOR of All Segments Equal to Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1787/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1787/</guid><description>LeetCode problem 1787
class Solution: def minChanges(self, nums: List[int], k: int) -&amp;gt; int: n = 1 &amp;lt;&amp;lt; 10 cnt = [Counter() for _ in range(k)] size = [0] * k for i, v in enumerate(nums): cnt[i % k][v] += 1 size[i % k] += 1 f = [inf] * n f[0] = 0 for i in range(k): g = [min(f) + size[i]] * n for j in range(n): for v, c in cnt[i].items(): g[j] = min(g[j], f[j ^ v] + size[i] - c) f = g return f[0]</description></item><item><title>1788. Maximize the Beauty of the Garden</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1788/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1788/</guid><description>LeetCode problem 1788
class Solution: def maximumBeauty(self, flowers: List[int]) -&amp;gt; int: s = [0] * (len(flowers) + 1) d = {} res = -inf for i, v in enumerate(flowers): if v in d: res = max(res, s[i] - s[d[v] + 1] + v * 2) else: d[v] = i s[i + 1] = s[i] + max(v, 0) return res</description></item><item><title>1790. Check if One String Swap Can Make Strings Equal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1790/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1790/</guid><description>LeetCode problem 1790
class Solution: def areAlmostEqual(self, s1: str, s2: str) -&amp;gt; bool: cnt = 0 c1 = c2 = None for a, b in zip(s1, s2): if a != b: cnt += 1 if cnt &amp;gt; 2 or (cnt == 2 and (a != c2 or b != c1)): return False c1, c2 = a, b return cnt != 1</description></item><item><title>1791. Find Center of Star Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1791/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1791/</guid><description>LeetCode problem 1791
class Solution: def findCenter(self, edges: List[List[int]]) -&amp;gt; int: return edges[0][0] if edges[0][0] in edges[1] else edges[0][1]</description></item><item><title>1792. Maximum Average Pass Ratio</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1792/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1792/</guid><description>LeetCode problem 1792
class Solution: def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -&amp;gt; float: h = [(a / b - (a + 1) / (b + 1), a, b) for a, b in classes] heapify(h) for _ in range(extraStudents): _, a, b = heappop(h) a, b = a + 1, b + 1 heappush(h, (a / b - (a + 1) / (b + 1), a, b)) return sum(v[1] / v[2] for v in h) / len(classes)</description></item><item><title>1793. Maximum Score of a Good Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1793/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1793/</guid><description>LeetCode problem 1793
class Solution: def maximumScore(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): v = nums[i] while stk and nums[stk[-1]] &amp;gt; v: stk.pop() if stk: right[i] = stk[-1] stk.append(i) res = 0 for i, v in enumerate(nums): if left[i] + 1 &amp;lt;= k &amp;lt;= right[i] - 1: res = max(res, v * (right[i] - left[i] - 1)) return res</description></item><item><title>1794. Count Pairs of Equal Substrings With Minimum Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1794/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1794/</guid><description>LeetCode problem 1794
class Solution: def countQuadruples(self, firstString: str, secondString: str) -&amp;gt; int: last = {c: i for i, c in enumerate(secondString)} res, mi = 0, inf for i, c in enumerate(firstString): if c in last: t = i - last[c] if mi &amp;gt; t: mi = t res = 1 elif mi == t: res += 1 return res</description></item><item><title>1796. Second Largest Digit in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1796/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1796/</guid><description>LeetCode problem 1796
class Solution: def secondHighest(self, s: str) -&amp;gt; int: mask = reduce(or_, (1 &amp;lt;&amp;lt; int(c) for c in s if c.isdigit()), 0) cnt = 0 for i in range(9, -1, -1): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: cnt += 1 if cnt == 2: return i return -1</description></item><item><title>1797. Design Authentication Manager</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1797/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1797/</guid><description>LeetCode problem 1797
class AuthenticationManager: def __init__(self, timeToLive: int): self.t = timeToLive self.d = defaultdict(int) def generate(self, tokenId: str, currentTime: int) -&amp;gt; None: self.d[tokenId] = currentTime + self.t def renew(self, tokenId: str, currentTime: int) -&amp;gt; None: if self.d[tokenId] &amp;lt;= currentTime: return self.d[tokenId] = currentTime + self.t def countUnexpiredTokens(self, currentTime: int) -&amp;gt; int: return sum(exp &amp;gt; currentTime for exp in self.d.values()) # Your AuthenticationManager object will be instantiated and called as such: # obj = AuthenticationManager(timeToLive) # obj.generate(tokenId,currentTime) # obj.</description></item><item><title>1798. Maximum Number of Consecutive Values You Can Make</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1798/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1798/</guid><description>LeetCode problem 1798
class Solution: def getMaximumConsecutive(self, coins: List[int]) -&amp;gt; int: res = 1 for v in sorted(coins): if v &amp;gt; res: break res += v return res</description></item><item><title>1799. Maximize Score After N Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1799/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1799/</guid><description>LeetCode problem 1799
class Solution: def maxScore(self, nums: List[int]) -&amp;gt; int: m = len(nums) f = [0] * (1 &amp;lt;&amp;lt; m) g = [[0] * m for _ in range(m)] for i in range(m): for j in range(i + 1, m): g[i][j] = gcd(nums[i], nums[j]) for k in range(1 &amp;lt;&amp;lt; m): if (cnt := k.bit_count()) % 2 == 0: for i in range(m): if k &amp;gt;&amp;gt; i &amp;amp; 1: for j in range(i + 1, m): if k &amp;gt;&amp;gt; j &amp;amp; 1: f[k] = max( f[k], f[k ^ (1 &amp;lt;&amp;lt; i) ^ (1 &amp;lt;&amp;lt; j)] + cnt // 2 * g[i][j], ) return f[-1]</description></item><item><title>1800. Maximum Ascending Subarray Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1800/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1800/</guid><description>LeetCode problem 1800
class Solution: def maxAscendingSum(self, nums: List[int]) -&amp;gt; int: res = t = 0 for i, v in enumerate(nums): if i == 0 or v &amp;gt; nums[i - 1]: t += v res = max(res, t) else: t = v return res</description></item><item><title>1801. Number of Orders in the Backlog</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1801/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1801/</guid><description>LeetCode problem 1801
class Solution: def getNumberOfBacklogOrders(self, orders: List[List[int]]) -&amp;gt; int: buy, sell = [], [] for p, a, t in orders: if t == 0: while a and sell and sell[0][0] &amp;lt;= p: x, y = heappop(sell) if a &amp;gt;= y: a -= y else: heappush(sell, (x, y - a)) a = 0 if a: heappush(buy, (-p, a)) else: while a and buy and -buy[0][0] &amp;gt;= p: x, y = heappop(buy) if a &amp;gt;= y: a -= y else: heappush(buy, (x, y - a)) a = 0 if a: heappush(sell, (p, a)) mod = 10**9 + 7 return sum(v[1] for v in buy + sell) % mod</description></item><item><title>1802. Maximum Value at a Given Index in a Bounded Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1802/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1802/</guid><description>LeetCode problem 1802
class Solution: def maxValue(self, n: int, index: int, maxSum: int) -&amp;gt; int: def sum(x, cnt): return ( (x + x - cnt + 1) * cnt // 2 if x &amp;gt;= cnt else (x + 1) * x // 2 + cnt - x ) left, right = 1, maxSum while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if sum(mid - 1, index) + sum(mid, n - index) &amp;lt;= maxSum: left = mid else: right = mid - 1 return left</description></item><item><title>1803. Count Pairs With XOR in a Range</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1803/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1803/</guid><description>LeetCode problem 1803
class Trie: def __init__(self): self.children = [None] * 2 self.cnt = 0 def insert(self, x): node = self for i in range(15, -1, -1): v = x &amp;gt;&amp;gt; i &amp;amp; 1 if node.children[v] is None: node.children[v] = Trie() node = node.children[v] node.cnt += 1 def search(self, x, limit): node = self res = 0 for i in range(15, -1, -1): if node is None: return res v = x &amp;gt;&amp;gt; i &amp;amp; 1 if limit &amp;gt;&amp;gt; i &amp;amp; 1: if node.</description></item><item><title>1804. Implement Trie II (Prefix Tree)</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1804/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1804/</guid><description>LeetCode problem 1804
class Trie: def __init__(self): self.children = [None] * 26 self.v = self.pv = 0 def insert(self, word: str) -&amp;gt; None: node = self for c in word: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: node.children[idx] = Trie() node = node.children[idx] node.pv += 1 node.v += 1 def countWordsEqualTo(self, word: str) -&amp;gt; int: node = self.search(word) return 0 if node is None else node.v def countWordsStartingWith(self, prefix: str) -&amp;gt; int: node = self.search(prefix) return 0 if node is None else node.</description></item><item><title>1805. Number of Different Integers in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1805/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1805/</guid><description>LeetCode problem 1805
class Solution: def numDifferentIntegers(self, word: str) -&amp;gt; int: s = set() i, n = 0, len(word) while i &amp;lt; n: if word[i].isdigit(): while i &amp;lt; n and word[i] == &amp;#39;0&amp;#39;: i += 1 j = i while j &amp;lt; n and word[j].isdigit(): j += 1 s.add(word[i:j]) i = j i += 1 return len(s)</description></item><item><title>1806. Minimum Number of Operations to Reinitialize a Permutation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1806/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1806/</guid><description>LeetCode problem 1806
class Solution: def reinitializePermutation(self, n: int) -&amp;gt; int: res, i = 0, 1 while 1: res += 1 if i &amp;lt; n &amp;gt;&amp;gt; 1: i &amp;lt;&amp;lt;= 1 else: i = (i - (n &amp;gt;&amp;gt; 1)) &amp;lt;&amp;lt; 1 | 1 if i == 1: return res</description></item><item><title>1807. Evaluate the Bracket Pairs of a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1807/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1807/</guid><description>LeetCode problem 1807
class Solution: def evaluate(self, s: str, knowledge: List[List[str]]) -&amp;gt; str: d = {a: b for a, b in knowledge} i, n = 0, len(s) res = [] while i &amp;lt; n: if s[i] == &amp;#39;(&amp;#39;: j = s.find(&amp;#39;)&amp;#39;, i + 1) res.append(d.get(s[i + 1 : j], &amp;#39;?&amp;#39;)) i = j else: res.append(s[i]) i += 1 return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1808. Maximize Number of Nice Divisors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1808/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1808/</guid><description>LeetCode problem 1808
class Solution: def maxNiceDivisors(self, primeFactors: int) -&amp;gt; int: mod = 10**9 + 7 if primeFactors &amp;lt; 4: return primeFactors if primeFactors % 3 == 0: return pow(3, primeFactors // 3, mod) % mod if primeFactors % 3 == 1: return 4 * pow(3, primeFactors // 3 - 1, mod) % mod return 2 * pow(3, primeFactors // 3, mod) % mod</description></item><item><title>1810. Minimum Path Cost in a Hidden Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1810/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1810/</guid><description>LeetCode problem 1810
# &amp;#34;&amp;#34;&amp;#34; # This is GridMaster&amp;#39;s API interface. # You should not implement it, or speculate about its implementation # &amp;#34;&amp;#34;&amp;#34; # class GridMaster(object): # def canMove(self, direction: str) -&amp;gt; bool: # # # def move(self, direction: str) -&amp;gt; int: # # # def isTarget(self) -&amp;gt; None: # # class Solution(object): def findShortestPath(self, master: &amp;#39;GridMaster&amp;#39;) -&amp;gt; int: def dfs(i, j): nonlocal target if master.isTarget(): target = (i, j) for dir, (a, b, ndir) in dirs.items(): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; N and 0 &amp;lt;= y &amp;lt; N and master.</description></item><item><title>1812. Determine Color of a Chessboard Square</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1812/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1812/</guid><description>LeetCode problem 1812
class Solution: def squareIsWhite(self, coordinates: str) -&amp;gt; bool: return (ord(coordinates[0]) + ord(coordinates[1])) % 2 == 1</description></item><item><title>1813. Sentence Similarity III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1813/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1813/</guid><description>LeetCode problem 1813
class Solution: def areSentencesSimilar(self, sentence1: str, sentence2: str) -&amp;gt; bool: words1, words2 = sentence1.split(), sentence2.split() m, n = len(words1), len(words2) if m &amp;lt; n: words1, words2 = words2, words1 m, n = n, m i = j = 0 while i &amp;lt; n and words1[i] == words2[i]: i += 1 while j &amp;lt; n and words1[m - 1 - j] == words2[n - 1 - j]: j += 1 return i + j &amp;gt;= n</description></item><item><title>1814. Count Nice Pairs in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1814/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1814/</guid><description>LeetCode problem 1814
class Solution: def countNicePairs(self, nums: List[int]) -&amp;gt; int: def rev(x): y = 0 while x: y = y * 10 + x % 10 x //= 10 return y res = 0 mod = 10**9 + 7 cnt = Counter() for x in nums: y = x - rev(x) res += cnt[y] cnt[y] += 1 return res % mod</description></item><item><title>1815. Maximum Number of Groups Getting Fresh Donuts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1815/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1815/</guid><description>LeetCode problem 1815
class Solution: def maxHappyGroups(self, batchSize: int, groups: List[int]) -&amp;gt; int: @cache def dfs(state, x): if state == mask: return 0 vis = [False] * batchSize res = 0 for i, v in enumerate(g): if state &amp;gt;&amp;gt; i &amp;amp; 1 == 0 and not vis[v]: vis[v] = True y = (x + v) % batchSize res = max(res, dfs(state | 1 &amp;lt;&amp;lt; i, y)) return res + (x == 0) g = [v % batchSize for v in groups if v % batchSize] mask = (1 &amp;lt;&amp;lt; len(g)) - 1 return len(groups) - len(g) + dfs(0, 0)</description></item><item><title>1816. Truncate Sentence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1816/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1816/</guid><description>LeetCode problem 1816
class Solution: def truncateSentence(self, s: str, k: int) -&amp;gt; str: for i, c in enumerate(s): k -= c == &amp;#39; &amp;#39; if k == 0: return s[:i] return s</description></item><item><title>1817. Finding the Users Active Minutes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1817/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1817/</guid><description>LeetCode problem 1817
class Solution: def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -&amp;gt; List[int]: d = defaultdict(set) for i, t in logs: d[i].add(t) res = [0] * k for ts in d.values(): res[len(ts) - 1] += 1 return res</description></item><item><title>1818. Minimum Absolute Sum Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1818/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1818/</guid><description>LeetCode problem 1818
class Solution: def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: mod = 10**9 + 7 nums = sorted(nums1) s = sum(abs(a - b) for a, b in zip(nums1, nums2)) % mod mx = 0 for a, b in zip(nums1, nums2): d1, d2 = abs(a - b), inf i = bisect_left(nums, b) if i &amp;lt; len(nums): d2 = min(d2, abs(nums[i] - b)) if i: d2 = min(d2, abs(nums[i - 1] - b)) mx = max(mx, d1 - d2) return (s - mx + mod) % mod</description></item><item><title>1819. Number of Different Subsequences GCDs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1819/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1819/</guid><description>LeetCode problem 1819
class Solution: def countDifferentSubsequenceGCDs(self, nums: List[int]) -&amp;gt; int: mx = max(nums) vis = set(nums) res = 0 for x in range(1, mx + 1): g = 0 for y in range(x, mx + 1, x): if y in vis: g = gcd(g, y) if g == x: res += 1 break return res</description></item><item><title>1820. Maximum Number of Accepted Invitations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1820/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1820/</guid><description>LeetCode problem 1820
class Solution: def maximumInvitations(self, grid: List[List[int]]) -&amp;gt; int: def find(i): for j, v in enumerate(grid[i]): if v and j not in vis: vis.add(j) if match[j] == -1 or find(match[j]): match[j] = i return True return False m, n = len(grid), len(grid[0]) match = [-1] * n res = 0 for i in range(m): vis = set() res += find(i) return res</description></item><item><title>1822. Sign of the Product of an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1822/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1822/</guid><description>LeetCode problem 1822
class Solution: def arraySign(self, nums: List[int]) -&amp;gt; int: res = 1 for v in nums: if v == 0: return 0 if v &amp;lt; 0: res *= -1 return res</description></item><item><title>1823. Find the Winner of the Circular Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1823/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1823/</guid><description>LeetCode problem 1823
class Solution: def findTheWinner(self, n: int, k: int) -&amp;gt; int: if n == 1: return 1 res = (k + self.findTheWinner(n - 1, k)) % n return n if res == 0 else res</description></item><item><title>1824. Minimum Sideway Jumps</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1824/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1824/</guid><description>LeetCode problem 1824
class Solution: def minSideJumps(self, obstacles: List[int]) -&amp;gt; int: f = [1, 0, 1] for v in obstacles[1:]: for j in range(3): if v == j + 1: f[j] = inf break x = min(f) + 1 for j in range(3): if v != j + 1: f[j] = min(f[j], x) return min(f)</description></item><item><title>1825. Finding MK Average</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1825/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1825/</guid><description>LeetCode problem 1825
from sortedcontainers import SortedList class MKAverage: def __init__(self, m: int, k: int): self.m = m self.k = k self.sl = SortedList() self.q = deque() self.s = 0 def addElement(self, num: int) -&amp;gt; None: self.q.append(num) if len(self.q) == self.m: self.sl = SortedList(self.q) self.s = sum(self.sl[self.k : -self.k]) elif len(self.q) &amp;gt; self.m: i = self.sl.bisect_left(num) if i &amp;lt; self.k: self.s += self.sl[self.k - 1] elif self.k &amp;lt;= i &amp;lt;= self.m - self.k: self.s += num else: self.s += self.</description></item><item><title>1826. Faulty Sensor</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1826/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1826/</guid><description>LeetCode problem 1826
class Solution: def badSensor(self, sensor1: List[int], sensor2: List[int]) -&amp;gt; int: i, n = 0, len(sensor1) while i &amp;lt; n - 1: if sensor1[i] != sensor2[i]: break i += 1 while i &amp;lt; n - 1: if sensor1[i + 1] != sensor2[i]: return 1 if sensor1[i] != sensor2[i + 1]: return 2 i += 1 return -1</description></item><item><title>1828. Queries on Number of Points Inside a Circle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1828/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1828/</guid><description>LeetCode problem 1828
class Solution: def countPoints( self, points: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: res = [] for x, y, r in queries: cnt = 0 for i, j in points: dx, dy = i - x, j - y cnt += dx * dx + dy * dy &amp;lt;= r * r res.append(cnt) return res</description></item><item><title>1829. Maximum XOR for Each Query</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1829/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1829/</guid><description>LeetCode problem 1829
class Solution: def getMaximumXor(self, nums: List[int], maximumBit: int) -&amp;gt; List[int]: res = [] xs = reduce(xor, nums) mask = (1 &amp;lt;&amp;lt; maximumBit) - 1 for x in nums[::-1]: k = xs ^ mask res.append(k) xs ^= x return res</description></item><item><title>1830. Minimum Number of Operations to Make String Sorted</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1830/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1830/</guid><description>LeetCode problem 1830
n = 3010 mod = 10**9 + 7 f = [1] + [0] * n g = [1] + [0] * n for i in range(1, n): f[i] = f[i - 1] * i % mod g[i] = pow(f[i], mod - 2, mod) class Solution: def makeStringSorted(self, s: str) -&amp;gt; int: cnt = Counter(s) res, n = 0, len(s) for i, c in enumerate(s): m = sum(v for a, v in cnt.items() if a &amp;lt; c) t = f[n - i - 1] * m for v in cnt.</description></item><item><title>1833. Maximum Ice Cream Bars</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1833/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1833/</guid><description>LeetCode problem 1833
class Solution: def maxIceCream(self, costs: List[int], coins: int) -&amp;gt; int: costs.sort() for i, c in enumerate(costs): if coins &amp;lt; c: return i coins -= c return len(costs)</description></item><item><title>1834. Single-Threaded CPU</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1834/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1834/</guid><description>LeetCode problem 1834
class Solution: def getOrder(self, tasks: List[List[int]]) -&amp;gt; List[int]: for i, task in enumerate(tasks): task.append(i) tasks.sort() res = [] q = [] n = len(tasks) i = t = 0 while q or i &amp;lt; n: if not q: t = max(t, tasks[i][0]) while i &amp;lt; n and tasks[i][0] &amp;lt;= t: heappush(q, (tasks[i][1], tasks[i][2])) i += 1 pt, j = heappop(q) res.append(j) t += pt return res</description></item><item><title>1835. Find XOR Sum of All Pairs Bitwise AND</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1835/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1835/</guid><description>LeetCode problem 1835
class Solution: def getXORSum(self, arr1: List[int], arr2: List[int]) -&amp;gt; int: a = reduce(xor, arr1) b = reduce(xor, arr2) return a &amp;amp; b</description></item><item><title>1836. Remove Duplicates From an Unsorted Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1836/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1836/</guid><description>LeetCode problem 1836
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteDuplicatesUnsorted(self, head: ListNode) -&amp;gt; ListNode: cnt = Counter() cur = head while cur: cnt[cur.val] += 1 cur = cur.next dummy = ListNode(0, head) pre, cur = dummy, head while cur: if cnt[cur.val] &amp;gt; 1: pre.next = cur.next else: pre = cur cur = cur.next return dummy.next</description></item><item><title>1838. Frequency of the Most Frequent Element</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1838/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1838/</guid><description>LeetCode problem 1838
class Solution: def maxFrequency(self, nums: List[int], k: int) -&amp;gt; int: def check(cnt): for i in range(n + 1 - cnt): j = i + cnt - 1 if nums[j] * cnt - (s[j + 1] - s[i]) &amp;lt;= k: return True return False nums.sort() s = list(accumulate(nums, initial=0)) n = len(nums) left, right = 1, n while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if check(mid): left = mid else: right = mid - 1 return left</description></item><item><title>1839. Longest Substring Of All Vowels in Order</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1839/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1839/</guid><description>LeetCode problem 1839
class Solution: def longestBeautifulSubstring(self, word: str) -&amp;gt; int: arr = [] n = len(word) i = 0 while i &amp;lt; n: j = i while j &amp;lt; n and word[j] == word[i]: j += 1 arr.append((word[i], j - i)) i = j res = 0 for i in range(len(arr) - 4): a, b, c, d, e = arr[i : i + 5] if a[0] + b[0] + c[0] + d[0] + e[0] == &amp;#34;aeiou&amp;#34;: res = max(res, a[1] + b[1] + c[1] + d[1] + e[1]) return res</description></item><item><title>1840. Maximum Building Height</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1840/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1840/</guid><description>LeetCode problem 1840
class Solution: def maxBuilding(self, n: int, restrictions: List[List[int]]) -&amp;gt; int: r = restrictions r.append([1, 0]) r.sort() if r[-1][0] != n: r.append([n, n - 1]) m = len(r) for i in range(1, m): r[i][1] = min(r[i][1], r[i - 1][1] + r[i][0] - r[i - 1][0]) for i in range(m - 2, 0, -1): r[i][1] = min(r[i][1], r[i + 1][1] + r[i + 1][0] - r[i][0]) res = 0 for i in range(m - 1): t = (r[i][1] + r[i + 1][1] + r[i + 1][0] - r[i][0]) // 2 res = max(res, t) return res</description></item><item><title>1842. Next Palindrome Using Same Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1842/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1842/</guid><description>LeetCode problem 1842
class Solution: def nextPalindrome(self, num: str) -&amp;gt; str: def next_permutation(nums: List[str]) -&amp;gt; bool: n = len(nums) // 2 i = n - 2 while i &amp;gt;= 0 and nums[i] &amp;gt;= nums[i + 1]: i -= 1 if i &amp;lt; 0: return False j = n - 1 while j &amp;gt;= 0 and nums[j] &amp;lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1 : n] = nums[i + 1 : n][::-1] return True nums = list(num) if not next_permutation(nums): return &amp;#34;&amp;#34; n = len(nums) for i in range(n // 2): nums[n - i - 1] = nums[i] return &amp;#34;&amp;#34;.</description></item><item><title>1845. Seat Reservation Manager</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1845/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1845/</guid><description>LeetCode problem 1845
class SeatManager: def __init__(self, n: int): self.q = list(range(1, n + 1)) heapify(self.q) def reserve(self) -&amp;gt; int: return heappop(self.q) def unreserve(self, seatNumber: int) -&amp;gt; None: heappush(self.q, seatNumber) # Your SeatManager object will be instantiated and called as such: # obj = SeatManager(n) # param_1 = obj.reserve() # obj.unreserve(seatNumber)</description></item><item><title>1846. Maximum Element After Decreasing and Rearranging</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1846/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1846/</guid><description>LeetCode problem 1846
class Solution: def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -&amp;gt; int: arr.sort() arr[0] = 1 for i in range(1, len(arr)): d = max(0, arr[i] - arr[i - 1] - 1) arr[i] -= d return max(arr)</description></item><item><title>1847. Closest Room</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1847/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1847/</guid><description>LeetCode problem 1847
from sortedcontainers import SortedList class Solution: def closestRoom( self, rooms: List[List[int]], queries: List[List[int]] ) -&amp;gt; List[int]: rooms.sort(key=lambda x: x[1]) k = len(queries) idx = sorted(range(k), key=lambda i: queries[i][1]) res = [-1] * k i, n = 0, len(rooms) sl = SortedList(x[0] for x in rooms) for j in idx: prefer, minSize = queries[j] while i &amp;lt; n and rooms[i][1] &amp;lt; minSize: sl.remove(rooms[i][0]) i += 1 if i == n: break p = sl.bisect_left(prefer) if p &amp;lt; len(sl): res[j] = sl[p] if p and (res[j] == -1 or res[j] - prefer &amp;gt;= prefer - sl[p - 1]): res[j] = sl[p - 1] return res</description></item><item><title>1849. Splitting a String Into Descending Consecutive Values</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1849/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1849/</guid><description>LeetCode problem 1849
class Solution: def splitString(self, s: str) -&amp;gt; bool: def dfs(i, x, k): if i == len(s): return k &amp;gt; 1 y = 0 for j in range(i, len(s)): y = y * 10 + int(s[j]) if (x == -1 or x - y == 1) and dfs(j + 1, y, k + 1): return True return False return dfs(0, -1, 0)</description></item><item><title>1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1850/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1850/</guid><description>LeetCode problem 1850
class Solution: def getMinSwaps(self, num: str, k: int) -&amp;gt; int: def next_permutation(nums: List[str]) -&amp;gt; bool: n = len(nums) i = n - 2 while i &amp;gt;= 0 and nums[i] &amp;gt;= nums[i + 1]: i -= 1 if i &amp;lt; 0: return False j = n - 1 while j &amp;gt;= 0 and nums[j] &amp;lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1 : n] = nums[i + 1 : n][::-1] return True s = list(num) for _ in range(k): next_permutation(s) d = [[] for _ in range(10)] idx = [0] * 10 n = len(s) for i, c in enumerate(num): j = ord(c) - ord(&amp;#34;0&amp;#34;) d[j].</description></item><item><title>1851. Minimum Interval to Include Each Query</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1851/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1851/</guid><description>LeetCode problem 1851
class Solution: def minInterval(self, intervals: List[List[int]], queries: List[int]) -&amp;gt; List[int]: n, m = len(intervals), len(queries) intervals.sort() queries = sorted((x, i) for i, x in enumerate(queries)) res = [-1] * m pq = [] i = 0 for x, j in queries: while i &amp;lt; n and intervals[i][0] &amp;lt;= x: a, b = intervals[i] heappush(pq, (b - a + 1, b)) i += 1 while pq and pq[0][1] &amp;lt; x: heappop(pq) if pq: res[j] = pq[0][0] return res</description></item><item><title>1852. Distinct Numbers in Each Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1852/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1852/</guid><description>LeetCode problem 1852
class Solution: def distinctNumbers(self, nums: List[int], k: int) -&amp;gt; List[int]: cnt = Counter(nums[:k]) res = [len(cnt)] for i in range(k, len(nums)): cnt[nums[i]] += 1 cnt[nums[i - k]] -= 1 if cnt[nums[i - k]] == 0: cnt.pop(nums[i - k]) res.append(len(cnt)) return res</description></item><item><title>1855. Maximum Distance Between a Pair of Values</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1855/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1855/</guid><description>LeetCode problem 1855
class Solution: def maxDistance(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: m, n = len(nums1), len(nums2) res = i = j = 0 while i &amp;lt; m: while j &amp;lt; n and nums1[i] &amp;lt;= nums2[j]: j += 1 res = max(res, j - i - 1) i += 1 return res</description></item><item><title>1856. Maximum Subarray Min-Product</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1856/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1856/</guid><description>LeetCode problem 1856
class Solution: def maxSumMinProduct(self, nums: List[int]) -&amp;gt; int: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, x in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt; nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) s = list(accumulate(nums, initial=0)) mod = 10**9 + 7 return max((s[right[i]] - s[left[i] + 1]) * x for i, x in enumerate(nums)) % mod</description></item><item><title>1857. Largest Color Value in a Directed Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1857/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1857/</guid><description>LeetCode problem 1857
class Solution: def largestPathValue(self, colors: str, edges: List[List[int]]) -&amp;gt; int: n = len(colors) indeg = [0] * n g = defaultdict(list) for a, b in edges: g[a].append(b) indeg[b] += 1 q = deque() dp = [[0] * 26 for _ in range(n)] for i, v in enumerate(indeg): if v == 0: q.append(i) c = ord(colors[i]) - ord(&amp;#39;a&amp;#39;) dp[i][c] += 1 cnt = 0 res = 1 while q: i = q.popleft() cnt += 1 for j in g[i]: indeg[j] -= 1 if indeg[j] == 0: q.</description></item><item><title>1858. Longest Word With All Prefixes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1858/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1858/</guid><description>LeetCode problem 1858
class Trie: __slots__ = [&amp;#34;children&amp;#34;, &amp;#34;is_end&amp;#34;] def __init__(self): self.children: List[Trie | None] = [None] * 26 self.is_end: bool = False def insert(self, w: str) -&amp;gt; None: node = self for c in w: idx = ord(c) - ord(&amp;#34;a&amp;#34;) if not node.children[idx]: node.children[idx] = Trie() node = node.children[idx] node.is_end = True def search(self, w: str) -&amp;gt; bool: node = self for c in w: idx = ord(c) - ord(&amp;#34;a&amp;#34;) node = node.children[idx] if not node.is_end: return False return True class Solution: def longestWord(self, words: List[str]) -&amp;gt; str: trie = Trie() for w in words: trie.</description></item><item><title>1860. Incremental Memory Leak</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1860/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1860/</guid><description>LeetCode problem 1860
class Solution: def memLeak(self, memory1: int, memory2: int) -&amp;gt; List[int]: i = 1 while i &amp;lt;= max(memory1, memory2): if memory1 &amp;gt;= memory2: memory1 -= i else: memory2 -= i i += 1 return [i, memory1, memory2]</description></item><item><title>1861. Rotating the Box</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1861/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1861/</guid><description>LeetCode problem 1861
class Solution: def rotateTheBox(self, box: List[List[str]]) -&amp;gt; List[List[str]]: m, n = len(box), len(box[0]) res = [[None] * m for _ in range(n)] for i in range(m): for j in range(n): res[j][m - i - 1] = box[i][j] for j in range(m): q = deque() for i in range(n - 1, -1, -1): if res[i][j] == &amp;#39;*&amp;#39;: q.clear() elif res[i][j] == &amp;#39;.&amp;#39;: q.append(i) elif q: res[q.popleft()][j] = &amp;#39;#&amp;#39; res[i][j] = &amp;#39;.&amp;#39; q.append(i) return res</description></item><item><title>1862. Sum of Floored Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1862/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1862/</guid><description>LeetCode problem 1862
class Solution: def sumOfFlooredPairs(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 cnt = Counter(nums) mx = max(nums) s = [0] * (mx + 1) for i in range(1, mx + 1): s[i] = s[i - 1] + cnt[i] res = 0 for y in range(1, mx + 1): if cnt[y]: d = 1 while d * y &amp;lt;= mx: res += cnt[y] * d * (s[min(mx, d * y + y - 1)] - s[d * y - 1]) res %= mod d += 1 return res</description></item><item><title>1864. Minimum Number of Swaps to Make the Binary String Alternating</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1864/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1864/</guid><description>LeetCode problem 1864
class Solution: def minSwaps(self, s: str) -&amp;gt; int: s0n0 = s0n1 = s1n0 = s1n1 = 0 for i in range(len(s)): if (i &amp;amp; 1) == 0: if s[i] != &amp;#39;0&amp;#39;: s0n0 += 1 else: s1n1 += 1 else: if s[i] != &amp;#39;0&amp;#39;: s1n0 += 1 else: s0n1 += 1 if s0n0 != s0n1 and s1n0 != s1n1: return -1 if s0n0 != s0n1: return s1n0 if s1n0 != s1n1: return s0n0 return min(s0n0, s1n0)</description></item><item><title>1865. Finding Pairs With a Certain Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1865/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1865/</guid><description>LeetCode problem 1865
class FindSumPairs: def __init__(self, nums1: List[int], nums2: List[int]): self.nums1 = nums1 self.nums2 = nums2 self.cnt = Counter(nums2) def add(self, index: int, val: int) -&amp;gt; None: old = self.nums2[index] self.cnt[old] -= 1 self.cnt[old + val] += 1 self.nums2[index] += val def count(self, tot: int) -&amp;gt; int: return sum(self.cnt[tot - v] for v in self.nums1) # Your FindSumPairs object will be instantiated and called as such: # obj = FindSumPairs(nums1, nums2) # obj.add(index,val) # param_2 = obj.count(tot)</description></item><item><title>1866. Number of Ways to Rearrange Sticks With K Sticks Visible</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1866/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1866/</guid><description>LeetCode problem 1866
class Solution: def rearrangeSticks(self, n: int, k: int) -&amp;gt; int: mod = 10**9 + 7 f = [1] + [0] * k for i in range(1, n + 1): for j in range(k, 0, -1): f[j] = (f[j] * (i - 1) + f[j - 1]) % mod f[0] = 0 return f[k]</description></item><item><title>1868. Product of Two Run-Length Encoded Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1868/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1868/</guid><description>LeetCode problem 1868
class Solution: def findRLEArray( self, encoded1: List[List[int]], encoded2: List[List[int]] ) -&amp;gt; List[List[int]]: res = [] j = 0 for vi, fi in encoded1: while fi: f = min(fi, encoded2[j][1]) v = vi * encoded2[j][0] if res and res[-1][0] == v: res[-1][1] += f else: res.append([v, f]) fi -= f encoded2[j][1] -= f if encoded2[j][1] == 0: j += 1 return res</description></item><item><title>1870. Minimum Speed to Arrive on Time</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1870/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1870/</guid><description>LeetCode problem 1870
class Solution: def minSpeedOnTime(self, dist: List[int], hour: float) -&amp;gt; int: def check(speed): res = 0 for i, d in enumerate(dist): res += (d / speed) if i == len(dist) - 1 else math.ceil(d / speed) return res &amp;lt;= hour r = 10**7 + 1 res = bisect_left(range(1, r), True, key=check) + 1 return -1 if res == r else res</description></item><item><title>1871. Jump Game VII</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1871/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1871/</guid><description>LeetCode problem 1871
class Solution: def canReach(self, s: str, minJump: int, maxJump: int) -&amp;gt; bool: n = len(s) pre = [0] * (n + 1) pre[1] = 1 f = [True] + [False] * (n - 1) for i in range(1, n): if s[i] == &amp;#34;0&amp;#34;: l, r = max(0, i - maxJump), i - minJump f[i] = l &amp;lt;= r and pre[r + 1] - pre[l] &amp;gt; 0 pre[i + 1] = pre[i] + f[i] return f[-1]</description></item><item><title>1872. Stone Game VIII</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1872/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1872/</guid><description>LeetCode problem 1872
class Solution: def stoneGameVIII(self, stones: List[int]) -&amp;gt; int: s = list(accumulate(stones)) f = s[-1] for i in range(len(s) - 2, 0, -1): f = max(f, s[i] - f) return f</description></item><item><title>1874. Minimize Product Sum of Two Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1874/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1874/</guid><description>LeetCode problem 1874
class Solution: def minProductSum(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: nums1.sort() nums2.sort() n, res = len(nums1), 0 for i in range(n): res += nums1[i] * nums2[n - i - 1] return res</description></item><item><title>1877. Minimize Maximum Pair Sum in Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1877/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1877/</guid><description>LeetCode problem 1877
class Solution: def minPairSum(self, nums: List[int]) -&amp;gt; int: nums.sort() n = len(nums) return max(x + nums[n - i - 1] for i, x in enumerate(nums[: n &amp;gt;&amp;gt; 1]))</description></item><item><title>1878. Get Biggest Three Rhombus Sums in a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1878/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1878/</guid><description>LeetCode problem 1878
from sortedcontainers import SortedSet class Solution: def getBiggestThree(self, grid: List[List[int]]) -&amp;gt; List[int]: m, n = len(grid), len(grid[0]) s1 = [[0] * (n + 2) for _ in range(m + 1)] s2 = [[0] * (n + 2) for _ in range(m + 1)] for i, row in enumerate(grid, 1): for j, x in enumerate(row, 1): s1[i][j] = s1[i - 1][j - 1] + x s2[i][j] = s2[i - 1][j + 1] + x ss = SortedSet() for i, row in enumerate(grid, 1): for j, x in enumerate(row, 1): l = min(i - 1, m - i, j - 1, n - j) ss.</description></item><item><title>1879. Minimum XOR Sum of Two Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1879/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1879/</guid><description>LeetCode problem 1879
class Solution: def minimumXORSum(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums2) f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): k = i.bit_count() - 1 for j in range(n): if i &amp;gt;&amp;gt; j &amp;amp; 1: f[i] = min(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + (nums1[k] ^ nums2[j])) return f[-1]</description></item><item><title>1881. Maximum Value after Insertion</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1881/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1881/</guid><description>LeetCode problem 1881
class Solution: def maxValue(self, n: str, x: int) -&amp;gt; str: if n[0] != &amp;#39;-&amp;#39;: for i, c in enumerate(n): if int(c) &amp;lt; x: return n[:i] + str(x) + n[i:] return n + str(x) else: for i, c in enumerate(n[1:]): if int(c) &amp;gt; x: return n[: i + 1] + str(x) + n[i + 1 :] return n + str(x)</description></item><item><title>1882. Process Tasks Using Servers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1882/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1882/</guid><description>LeetCode problem 1882
class Solution: def assignTasks(self, servers: List[int], tasks: List[int]) -&amp;gt; List[int]: idle, busy = [], [] for i, weight in enumerate(servers): heappush(idle, (weight, i)) res = [] for start, cost in enumerate(tasks): while busy and busy[0][0] &amp;lt;= start: _, s, i = heappop(busy) heappush(idle, (s, i)) if idle: s, i = heappop(idle) heappush(busy, (start + cost, s, i)) else: t, s, i = heappop(busy) heappush(busy, (t + cost, s, i)) res.append(i) return res</description></item><item><title>1883. Minimum Skips to Arrive at Meeting On Time</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1883/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1883/</guid><description>LeetCode problem 1883
class Solution: def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -&amp;gt; int: n = len(dist) f = [[inf] * (n + 1) for _ in range(n + 1)] f[0][0] = 0 for i, x in enumerate(dist, 1): for j in range(i + 1): if j &amp;lt; i: f[i][j] = min(f[i][j], ((f[i - 1][j] + x - 1) // speed + 1) * speed) if j: f[i][j] = min(f[i][j], f[i - 1][j - 1] + x) for j in range(n + 1): if f[n][j] &amp;lt;= hoursBefore * speed: return j return -1</description></item><item><title>1885. Count Pairs in Two Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1885/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1885/</guid><description>LeetCode problem 1885
class Solution: def countPairs(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) d = [nums1[i] - nums2[i] for i in range(n)] d.sort() return sum(n - bisect_right(d, -v, lo=i + 1) for i, v in enumerate(d))</description></item><item><title>1887. Reduction Operations to Make the Array Elements Equal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1887/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1887/</guid><description>LeetCode Problem 1887
Problem Statement The goal of this problem is to make all elements in a given integer array nums equal, through a series of reduction operations. In each operation, we find the largest element in the array, find the next largest element that is strictly smaller than the largest, and reduce the largest element to this next largest value. The task is to return the number of such operations needed to make all array elements equal.</description></item><item><title>1888. Minimum Number of Flips to Make the Binary String Alternating</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1888/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1888/</guid><description>LeetCode problem 1888
class Solution: def minFlips(self, s: str) -&amp;gt; int: n = len(s) target = &amp;#34;01&amp;#34; cnt = sum(c != target[i &amp;amp; 1] for i, c in enumerate(s)) res = min(cnt, n - cnt) for i in range(n): cnt -= s[i] != target[i &amp;amp; 1] cnt += s[i] != target[(i + n) &amp;amp; 1] res = min(res, cnt, n - cnt) return res</description></item><item><title>1889. Minimum Space Wasted From Packaging</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1889/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1889/</guid><description>LeetCode problem 1889
class Solution: def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -&amp;gt; int: mod = 10**9 + 7 res = inf packages.sort() for box in boxes: box.sort() if packages[-1] &amp;gt; box[-1]: continue s = i = 0 for b in box: j = bisect_right(packages, b, lo=i) s += (j - i) * b i = j res = min(res, s) if res == inf: return -1 return (res - sum(packages)) % mod</description></item><item><title>1891. Cutting Ribbons</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1891/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1891/</guid><description>LeetCode problem 1891
class Solution: def maxLength(self, ribbons: List[int], k: int) -&amp;gt; int: left, right = 0, max(ribbons) while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 cnt = sum(x // mid for x in ribbons) if cnt &amp;gt;= k: left = mid else: right = mid - 1 return left</description></item><item><title>1894. Find the Student that Will Replace the Chalk</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1894/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1894/</guid><description>LeetCode problem 1894
class Solution: def chalkReplacer(self, chalk: List[int], k: int) -&amp;gt; int: s = sum(chalk) k %= s for i, x in enumerate(chalk): if k &amp;lt; x: return i k -= x</description></item><item><title>1895. Largest Magic Square</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1895/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1895/</guid><description>LeetCode problem 1895
class Solution: def largestMagicSquare(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) rowsum = [[0] * (n + 1) for _ in range(m + 1)] colsum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): rowsum[i][j] = rowsum[i][j - 1] + grid[i - 1][j - 1] colsum[i][j] = colsum[i - 1][j] + grid[i - 1][j - 1] def check(x1, y1, x2, y2): val = rowsum[x1 + 1][y2 + 1] - rowsum[x1 + 1][y1] for i in range(x1 + 1, x2 + 1): if rowsum[i + 1][y2 + 1] - rowsum[i + 1][y1] !</description></item><item><title>1898. Maximum Number of Removable Characters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1898/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1898/</guid><description>LeetCode problem 1898
class Solution: def maximumRemovals(self, s: str, p: str, removable: List[int]) -&amp;gt; int: def check(k): i = j = 0 ids = set(removable[:k]) while i &amp;lt; m and j &amp;lt; n: if i not in ids and s[i] == p[j]: j += 1 i += 1 return j == n m, n = len(s), len(p) left, right = 0, len(removable) while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 if check(mid): left = mid else: right = mid - 1 return left</description></item><item><title>1899. Merge Triplets to Form Target Triplet</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1899/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1899/</guid><description>LeetCode problem 1899
class Solution: def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -&amp;gt; bool: x, y, z = target d = e = f = 0 for a, b, c in triplets: if a &amp;lt;= x and b &amp;lt;= y and c &amp;lt;= z: d = max(d, a) e = max(e, b) f = max(f, c) return [d, e, f] == target</description></item><item><title>1900. The Earliest and Latest Rounds Where Players Compete</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1900/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1900/</guid><description>LeetCode problem 1900
class Solution: def earliestAndLatest( self, n: int, firstPlayer: int, secondPlayer: int ) -&amp;gt; List[int]: # dp[i][j][k] := (earliest, latest) pair w/ firstPlayer is i-th player from # Front, secondPlayer is j-th player from end, and there&amp;#39;re k people @functools.lru_cache(None) def dp(l: int, r: int, k: int) -&amp;gt; List[int]: if l == r: return [1, 1] if l &amp;gt; r: return dp(r, l, k) a = math.inf b = -math.inf # Enumerate all possible positions for i in range(1, l + 1): for j in range(l - i + 1, r - i + 1): if not l + r - k // 2 &amp;lt;= i + j &amp;lt;= (k + 1) // 2: continue x, y = dp(i, j, (k + 1) // 2) a = min(a, x + 1) b = max(b, y + 1) return [a, b] return dp(firstPlayer, n - secondPlayer + 1, n)</description></item><item><title>1901. Find a Peak Element II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1901/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1901/</guid><description>LeetCode problem 1901
class Solution: def findPeakGrid(self, mat: List[List[int]]) -&amp;gt; List[int]: l, r = 0, len(mat) - 1 while l &amp;lt; r: mid = (l + r) &amp;gt;&amp;gt; 1 j = mat[mid].index(max(mat[mid])) if mat[mid][j] &amp;gt; mat[mid + 1][j]: r = mid else: l = mid + 1 return [l, mat[l].index(max(mat[l]))]</description></item><item><title>1902. Depth of BST Given Insertion Order</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1902/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1902/</guid><description>LeetCode problem 1902
from sortedcontainers import SortedDict class Solution: def maxDepthBST(self, order: List[int]) -&amp;gt; int: sd = SortedDict({0: 0, inf: 0, order[0]: 1}) res = 1 for v in order[1:]: lower = sd.bisect_left(v) - 1 higher = lower + 1 depth = 1 + max(sd.values()[lower], sd.values()[higher]) res = max(res, depth) sd[v] = depth return res</description></item><item><title>1904. The Number of Full Rounds You Have Played</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1904/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1904/</guid><description>LeetCode problem 1904
class Solution: def numberOfRounds(self, loginTime: str, logoutTime: str) -&amp;gt; int: def f(s: str) -&amp;gt; int: return int(s[:2]) * 60 + int(s[3:]) a, b = f(loginTime), f(logoutTime) if a &amp;gt; b: b += 1440 a, b = (a + 14) // 15, b // 15 return max(0, b - a)</description></item><item><title>1905. Count Sub Islands</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1905/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1905/</guid><description>LeetCode problem 1905
class Solution: def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -&amp;gt; int: def bfs(i: int, j: int) -&amp;gt; int: ok = grid1[i][j] q = deque([(i, j)]) grid2[i][j] = 0 while q: i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and grid2[x][y]: q.append((x, y)) ok = ok &amp;amp; grid1[x][y] grid2[x][y] = 0 return ok m, n = len(grid1), len(grid1[0]) dirs = (-1, 0, 1, 0, -1) return sum(bfs(i, j) for i in range(m) for j in range(n) if grid2[i][j])</description></item><item><title>1906. Minimum Absolute Difference Queries</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1906/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1906/</guid><description>LeetCode problem 1906
class Solution: def minDifference(self, nums: List[int], queries: List[List[int]]) -&amp;gt; List[int]: m, n = len(nums), len(queries) pre_sum = [[0] * 101 for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, 101): t = 1 if nums[i - 1] == j else 0 pre_sum[i][j] = pre_sum[i - 1][j] + t res = [] for i in range(n): left, right = queries[i][0], queries[i][1] + 1 t = inf last = -1 for j in range(1, 101): if pre_sum[right][j] - pre_sum[left][j] &amp;gt; 0: if last !</description></item><item><title>1908. Game of Nim</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1908/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1908/</guid><description>LeetCode problem 1908
class Solution: def nimGame(self, piles: List[int]) -&amp;gt; bool: @cache def dfs(st): lst = list(st) for i, x in enumerate(lst): for j in range(1, x + 1): lst[i] -= j if not dfs(tuple(lst)): return True lst[i] += j return False return dfs(tuple(piles))</description></item><item><title>1910. Remove All Occurrences of a Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1910/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1910/</guid><description>LeetCode problem 1910
class Solution: def removeOccurrences(self, s: str, part: str) -&amp;gt; str: while part in s: s = s.replace(part, &amp;#39;&amp;#39;, 1) return s</description></item><item><title>1911. Maximum Alternating Subsequence Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1911/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1911/</guid><description>LeetCode problem 1911
class Solution: def maxAlternatingSum(self, nums: List[int]) -&amp;gt; int: f = g = 0 for x in nums: f, g = max(g - x, f), max(f + x, g) return max(f, g)</description></item><item><title>1912. Design Movie Rental System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1912/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1912/</guid><description>LeetCode problem 1912
from sortedcontainers import SortedList class MovieRentingSystem: def __init__(self, n: int, entries: List[List[int]]): self.unrented = collections.defaultdict(SortedList) # {movie: (price, shop)} self.shopAndMovieToPrice = {} # {(shop, movie): price} self.rented = SortedList() # (price, shop, movie) for shop, movie, price in entries: self.unrented[movie].add((price, shop)) self.shopAndMovieToPrice[(shop, movie)] = price def search(self, movie: int) -&amp;gt; List[int]: return [shop for _, shop in self.unrented[movie][:5]] def rent(self, shop: int, movie: int) -&amp;gt; None: price = self.shopAndMovieToPrice[(shop, movie)] self.unrented[movie].remove((price, shop)) self.rented.add((price, shop, movie)) def drop(self, shop: int, movie: int) -&amp;gt; None: price = self.</description></item><item><title>1914. Cyclically Rotating a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1914/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1914/</guid><description>LeetCode problem 1914
class Solution: def rotateGrid(self, grid: List[List[int]], k: int) -&amp;gt; List[List[int]]: def rotate(p: int, k: int): nums = [] for j in range(p, n - p - 1): nums.append(grid[p][j]) for i in range(p, m - p - 1): nums.append(grid[i][n - p - 1]) for j in range(n - p - 1, p, -1): nums.append(grid[m - p - 1][j]) for i in range(m - p - 1, p, -1): nums.append(grid[i][p]) k %= len(nums) if k == 0: return nums = nums[k:] + nums[:k] k = 0 for j in range(p, n - p - 1): grid[p][j] = nums[k] k += 1 for i in range(p, m - p - 1): grid[i][n - p - 1] = nums[k] k += 1 for j in range(n - p - 1, p, -1): grid[m - p - 1][j] = nums[k] k += 1 for i in range(m - p - 1, p, -1): grid[i][p] = nums[k] k += 1 m, n = len(grid), len(grid[0]) for p in range(min(m, n) &amp;gt;&amp;gt; 1): rotate(p, k) return grid</description></item><item><title>1915. Number of Wonderful Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1915/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1915/</guid><description>LeetCode problem 1915
class Solution: def wonderfulSubstrings(self, word: str) -&amp;gt; int: cnt = Counter({0: 1}) res = st = 0 for c in word: st ^= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) res += cnt[st] for i in range(10): res += cnt[st ^ (1 &amp;lt;&amp;lt; i)] cnt[st] += 1 return res</description></item><item><title>1918. Kth Smallest Subarray Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1918/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1918/</guid><description>LeetCode problem 1918
class Solution: def kthSmallestSubarraySum(self, nums: List[int], k: int) -&amp;gt; int: def f(s): t = j = 0 cnt = 0 for i, x in enumerate(nums): t += x while t &amp;gt; s: t -= nums[j] j += 1 cnt += i - j + 1 return cnt &amp;gt;= k l, r = min(nums), sum(nums) return l + bisect_left(range(l, r + 1), True, key=f)</description></item><item><title>1921. Eliminate Maximum Number of Monsters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1921/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1921/</guid><description>LeetCode problem 1921
class Solution: def eliminateMaximum(self, dist: List[int], speed: List[int]) -&amp;gt; int: times = sorted((d - 1) // s for d, s in zip(dist, speed)) for i, t in enumerate(times): if t &amp;lt; i: return i return len(times)</description></item><item><title>1922. Count Good Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1922/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1922/</guid><description>LeetCode problem 1922
class Solution: def countGoodNumbers(self, n: int) -&amp;gt; int: mod = 10**9 + 7 def myPow(x, n): res = 1 while n: if (n &amp;amp; 1) == 1: res = res * x % mod x = x * x % mod n &amp;gt;&amp;gt;= 1 return res return myPow(5, (n + 1) &amp;gt;&amp;gt; 1) * myPow(4, n &amp;gt;&amp;gt; 1) % mod</description></item><item><title>1923. Longest Common Subpath</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1923/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1923/</guid><description>LeetCode problem 1923
class Solution: def longestCommonSubpath(self, n: int, paths: List[List[int]]) -&amp;gt; int: def check(k: int) -&amp;gt; bool: cnt = Counter() for h in hh: vis = set() for i in range(1, len(h) - k + 1): j = i + k - 1 x = (h[j] - h[i - 1] * p[j - i + 1]) % mod if x not in vis: vis.add(x) cnt[x] += 1 return max(cnt.values()) == m m = len(paths) mx = max(len(path) for path in paths) base = 133331 mod = 2**64 + 1 p = [0] * (mx + 1) p[0] = 1 for i in range(1, len(p)): p[i] = p[i - 1] * base % mod hh = [] for path in paths: k = len(path) h = [0] * (k + 1) for i, x in enumerate(path, 1): h[i] = h[i - 1] * base % mod + x hh.</description></item><item><title>1926. Nearest Exit from Entrance in Maze</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1926/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1926/</guid><description>LeetCode problem 1926
class Solution: def nearestExit(self, maze: List[List[str]], entrance: List[int]) -&amp;gt; int: m, n = len(maze), len(maze[0]) i, j = entrance q = deque([(i, j)]) maze[i][j] = &amp;#39;+&amp;#39; res = 0 while q: res += 1 for _ in range(len(q)): i, j = q.popleft() for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]: x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and maze[x][y] == &amp;#39;.</description></item><item><title>1927. Sum Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1927/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1927/</guid><description>LeetCode problem 1927
class Solution: def sumGame(self, num: str) -&amp;gt; bool: n = len(num) cnt1 = num[: n // 2].count(&amp;#34;?&amp;#34;) cnt2 = num[n // 2 :].count(&amp;#34;?&amp;#34;) s1 = sum(int(x) for x in num[: n // 2] if x != &amp;#34;?&amp;#34;) s2 = sum(int(x) for x in num[n // 2 :] if x != &amp;#34;?&amp;#34;) return (cnt1 + cnt2) % 2 == 1 or s1 - s2 != 9 * (cnt2 - cnt1) // 2</description></item><item><title>1929. Concatenation of Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1929/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1929/</guid><description>LeetCode problem 1929
class Solution: def getConcatenation(self, nums: List[int]) -&amp;gt; List[int]: return nums + nums</description></item><item><title>1931. Painting a Grid With Three Different Colors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1931/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1931/</guid><description>LeetCode problem 1931
class Solution: def colorTheGrid(self, m: int, n: int) -&amp;gt; int: def f1(x: int) -&amp;gt; bool: last = -1 for _ in range(m): if x % 3 == last: return False last = x % 3 x //= 3 return True def f2(x: int, y: int) -&amp;gt; bool: for _ in range(m): if x % 3 == y % 3: return False x, y = x // 3, y // 3 return True mod = 10**9 + 7 mx = 3**m valid = {i for i in range(mx) if f1(i)} d = defaultdict(list) for x in valid: for y in valid: if f2(x, y): d[x].</description></item><item><title>1933. Check if String Is Decomposable Into Value-Equal Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1933/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1933/</guid><description>LeetCode problem 1933
class Solution: def isDecomposable(self, s: str) -&amp;gt; bool: cnt2 = 0 for _, g in groupby(s): m = len(list(g)) if m % 3 == 1: return False cnt2 += m % 3 == 2 if cnt2 &amp;gt; 1: return False return cnt2 == 1</description></item><item><title>1935. Maximum Number of Words You Can Type</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1935/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1935/</guid><description>LeetCode problem 1935
class Solution: def canBeTypedWords(self, text: str, brokenLetters: str) -&amp;gt; int: s = set(brokenLetters) return sum(all(c not in s for c in w) for w in text.split())</description></item><item><title>1936. Add Minimum Number of Rungs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1936/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1936/</guid><description>LeetCode problem 1936
class Solution: def addRungs(self, rungs: List[int], dist: int) -&amp;gt; int: rungs = [0] + rungs return sum((b - a - 1) // dist for a, b in pairwise(rungs))</description></item><item><title>1937. Maximum Number of Points with Cost</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1937/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1937/</guid><description>LeetCode problem 1937
class Solution: def maxPoints(self, points: List[List[int]]) -&amp;gt; int: n = len(points[0]) f = points[0][:] for p in points[1:]: g = [0] * n lmx = -inf for j in range(n): lmx = max(lmx, f[j] + j) g[j] = max(g[j], p[j] + lmx - j) rmx = -inf for j in range(n - 1, -1, -1): rmx = max(rmx, f[j] - j) g[j] = max(g[j], p[j] + rmx + j) f = g return max(f)</description></item><item><title>1940. Longest Common Subsequence Between Sorted Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1940/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1940/</guid><description>LeetCode problem 1940
class Solution: def longestCommomSubsequence(self, arrays: List[List[int]]) -&amp;gt; List[int]: def common(l1, l2): i, j, n1, n2 = 0, 0, len(l1), len(l2) res = [] while i &amp;lt; n1 and j &amp;lt; n2: if l1[i] == l2[j]: res.append(l1[i]) i += 1 j += 1 elif l1[i] &amp;gt; l2[j]: j += 1 else: i += 1 return res n = len(arrays) for i in range(1, n): arrays[i] = common(arrays[i - 1], arrays[i]) return arrays[n - 1]</description></item><item><title>1941. Check if All Characters Have Equal Number of Occurrences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1941/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1941/</guid><description>LeetCode problem 1941
class Solution: def areOccurrencesEqual(self, s: str) -&amp;gt; bool: cnt = Counter(s) return len(set(cnt.values())) == 1</description></item><item><title>1942. The Number of the Smallest Unoccupied Chair</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1942/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1942/</guid><description>LeetCode problem 1942
class Solution: def smallestChair(self, times: List[List[int]], targetFriend: int) -&amp;gt; int: n = len(times) h = list(range(n)) heapify(h) for i in range(n): times[i].append(i) times.sort() busy = [] for a, b, i in times: while busy and busy[0][0] &amp;lt;= a: heappush(h, heappop(busy)[1]) c = heappop(h) if i == targetFriend: return c heappush(busy, (b, c)) return -1</description></item><item><title>1943. Describe the Painting</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1943/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1943/</guid><description>LeetCode problem 1943
class Solution: def splitPainting(self, segments: List[List[int]]) -&amp;gt; List[List[int]]: d = defaultdict(int) for l, r, c in segments: d[l] += c d[r] -= c s = sorted([[k, v] for k, v in d.items()]) n = len(s) for i in range(1, n): s[i][1] += s[i - 1][1] return [[s[i][0], s[i + 1][0], s[i][1]] for i in range(n - 1) if s[i][1]]</description></item><item><title>1944. Number of Visible People in a Queue</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1944/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1944/</guid><description>LeetCode problem 1944
class Solution: def canSeePersonsCount(self, heights: List[int]) -&amp;gt; List[int]: n = len(heights) res = [0] * n stk = [] for i in range(n - 1, -1, -1): while stk and stk[-1] &amp;lt; heights[i]: res[i] += 1 stk.pop() if stk: res[i] += 1 stk.append(heights[i]) return res</description></item><item><title>1945. Sum of Digits of String After Convert</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1945/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1945/</guid><description>LeetCode problem 1945
class Solution: def getLucky(self, s: str, k: int) -&amp;gt; int: s = &amp;#39;&amp;#39;.join(str(ord(c) - ord(&amp;#39;a&amp;#39;) + 1) for c in s) for _ in range(k): t = sum(int(c) for c in s) s = str(t) return int(s)</description></item><item><title>1946. Largest Number After Mutating Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1946/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1946/</guid><description>LeetCode problem 1946
class Solution: def maximumNumber(self, num: str, change: List[int]) -&amp;gt; str: s = list(num) for i, c in enumerate(s): if change[int(c)] &amp;gt; int(c): while i &amp;lt; len(s) and int(s[i]) &amp;lt;= change[int(s[i])]: s[i] = str(change[int(s[i])]) i += 1 break return &amp;#39;&amp;#39;.join(s)</description></item><item><title>1947. Maximum Compatibility Score Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1947/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1947/</guid><description>LeetCode problem 1947
class Solution: def maxCompatibilitySum( self, students: List[List[int]], mentors: List[List[int]] ) -&amp;gt; int: def dfs(i, t): if i == m: nonlocal res res = max(res, t) return for j in range(m): if not vis[j]: vis[j] = True dfs(i + 1, t + g[i][j]) vis[j] = False m = len(students) g = [[0] * m for _ in range(m)] for i in range(m): for j in range(m): g[i][j] = sum(a == b for a, b in zip(students[i], mentors[j])) vis = [False] * m res = 0 dfs(0, 0) return res</description></item><item><title>1950. Maximum of Minimum Values in All Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1950/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1950/</guid><description>LeetCode problem 1950
class Solution: def findMaximums(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, x in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= x: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt;= nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) res = [0] * n for i in range(n): m = right[i] - left[i] - 1 res[m - 1] = max(res[m - 1], nums[i]) for i in range(n - 2, -1, -1): res[i] = max(res[i], res[i + 1]) return res</description></item><item><title>1952. Three Divisors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1952/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1952/</guid><description>LeetCode problem 1952
class Solution: def isThree(self, n: int) -&amp;gt; bool: cnt = 0 i = 1 while i &amp;lt;= n // i: if n % i == 0: cnt += 1 if i == n // i else 2 i += 1 return cnt == 3</description></item><item><title>1953. Maximum Number of Weeks for Which You Can Work</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1953/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1953/</guid><description>LeetCode problem 1953
class Solution: def numberOfWeeks(self, milestones: List[int]) -&amp;gt; int: mx, s = max(milestones), sum(milestones) rest = s - mx return rest * 2 + 1 if mx &amp;gt; rest + 1 else s</description></item><item><title>1954. Minimum Garden Perimeter to Collect Enough Apples</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1954/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1954/</guid><description>LeetCode problem 1954
class Solution: def minimumPerimeter(self, neededApples: int) -&amp;gt; int: l, r = 1, 100000 while l &amp;lt; r: mid = (l + r) &amp;gt;&amp;gt; 1 if 2 * mid * (mid + 1) * (2 * mid + 1) &amp;gt;= neededApples: r = mid else: l = mid + 1 return l * 8</description></item><item><title>1955. Count Number of Special Subsequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1955/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1955/</guid><description>LeetCode problem 1955
class Solution: def countSpecialSubsequences(self, nums: List[int]) -&amp;gt; int: mod = 10**9 + 7 n = len(nums) f = [0] * 3 f[0] = nums[0] == 0 for i in range(1, n): if nums[i] == 0: f[0] = (2 * f[0] + 1) % mod elif nums[i] == 1: f[1] = (f[0] + 2 * f[1]) % mod else: f[2] = (f[1] + 2 * f[2]) % mod return f[2]</description></item><item><title>1957. Delete Characters to Make Fancy String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1957/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1957/</guid><description>LeetCode problem 1957
class Solution: def makeFancyString(self, s: str) -&amp;gt; str: res = [] for c in s: if len(res) &amp;gt; 1 and res[-1] == res[-2] == c: continue res.append(c) return &amp;#39;&amp;#39;.join(res)</description></item><item><title>1958. Check if Move is Legal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1958/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1958/</guid><description>LeetCode problem 1958
class Solution: def checkMove( self, board: List[List[str]], rMove: int, cMove: int, color: str ) -&amp;gt; bool: dirs = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)] n = 8 for a, b in dirs: i, j = rMove, cMove t = 0 while 0 &amp;lt;= i + a &amp;lt; n and 0 &amp;lt;= j + b &amp;lt; n: t += 1 i, j = i + a, j + b if board[i][j] in [&amp;#39;.</description></item><item><title>1959. Minimum Total Space Wasted With K Resizing Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1959/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1959/</guid><description>LeetCode problem 1959
class Solution: def minSpaceWastedKResizing(self, nums: List[int], k: int) -&amp;gt; int: k += 1 n = len(nums) g = [[0] * n for _ in range(n)] for i in range(n): s = mx = 0 for j in range(i, n): s += nums[j] mx = max(mx, nums[j]) g[i][j] = mx * (j - i + 1) - s f = [[inf] * (k + 1) for _ in range(n + 1)] f[0][0] = 0 for i in range(1, n + 1): for j in range(1, k + 1): for h in range(i): f[i][j] = min(f[i][j], f[h][j - 1] + g[h][i - 1]) return f[-1][-1]</description></item><item><title>1961. Check If String Is a Prefix of Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1961/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1961/</guid><description>LeetCode problem 1961
class Solution: def isPrefixString(self, s: str, words: List[str]) -&amp;gt; bool: n, m = len(s), 0 for i, w in enumerate(words): m += len(w) if m == n: return &amp;#34;&amp;#34;.join(words[: i + 1]) == s return False</description></item><item><title>1962. Remove Stones to Minimize the Total</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1962/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1962/</guid><description>LeetCode problem 1962
class Solution: def minStoneSum(self, piles: List[int], k: int) -&amp;gt; int: pq = [-x for x in piles] heapify(pq) for _ in range(k): heapreplace(pq, pq[0] // 2) return -sum(pq)</description></item><item><title>1963. Minimum Number of Swaps to Make the String Balanced</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1963/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1963/</guid><description>LeetCode problem 1963
class Solution: def minSwaps(self, s: str) -&amp;gt; int: x = 0 for c in s: if c == &amp;#34;[&amp;#34;: x += 1 elif x: x -= 1 return (x + 1) &amp;gt;&amp;gt; 1</description></item><item><title>1964. Find the Longest Valid Obstacle Course at Each Position</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1964/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1964/</guid><description>LeetCode problem 1964
class BinaryIndexedTree: __slots__ = [&amp;#34;n&amp;#34;, &amp;#34;c&amp;#34;] def __init__(self, n: int): self.n = n self.c = [0] * (n + 1) def update(self, x: int, v: int): while x &amp;lt;= self.n: self.c[x] = max(self.c[x], v) x += x &amp;amp; -x def query(self, x: int) -&amp;gt; int: s = 0 while x: s = max(s, self.c[x]) x -= x &amp;amp; -x return s class Solution: def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -&amp;gt; List[int]: nums = sorted(set(obstacles)) n = len(nums) tree = BinaryIndexedTree(n) res = [] for x in obstacles: i = bisect_left(nums, x) + 1 res.</description></item><item><title>1966. Binary Searchable Numbers in an Unsorted Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1966/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1966/</guid><description>LeetCode problem 1966
class Solution: def binarySearchableNumbers(self, nums: List[int]) -&amp;gt; int: n = len(nums) ok = [1] * n mx, mi = -1000000, 1000000 for i, x in enumerate(nums): if x &amp;lt; mx: ok[i] = 0 else: mx = x for i in range(n - 1, -1, -1): if nums[i] &amp;gt; mi: ok[i] = 0 else: mi = nums[i] return sum(ok)</description></item><item><title>1967. Number of Strings That Appear as Substrings in Word</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1967/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1967/</guid><description>LeetCode problem 1967
class Solution: def numOfStrings(self, patterns: List[str], word: str) -&amp;gt; int: return sum(p in word for p in patterns)</description></item><item><title>1968. Array With Elements Not Equal to Average of Neighbors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1968/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1968/</guid><description>LeetCode problem 1968
class Solution: def rearrangeArray(self, nums: List[int]) -&amp;gt; List[int]: nums.sort() n = len(nums) m = (n + 1) &amp;gt;&amp;gt; 1 res = [] for i in range(m): res.append(nums[i]) if i + m &amp;lt; n: res.append(nums[i + m]) return res</description></item><item><title>1969. Minimum Non-Zero Product of the Array Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1969/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1969/</guid><description>LeetCode problem 1969
class Solution: def minNonZeroProduct(self, p: int) -&amp;gt; int: mod = 10**9 + 7 return (2**p - 1) * pow(2**p - 2, 2 ** (p - 1) - 1, mod) % mod</description></item><item><title>1970. Last Day Where You Can Still Cross</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1970/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1970/</guid><description>LeetCode problem 1970
class Solution: def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -&amp;gt; int: n = row * col p = list(range(n + 2)) grid = [[False] * col for _ in range(row)] top, bottom = n, n + 1 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def check(i, j): return 0 &amp;lt;= i &amp;lt; row and 0 &amp;lt;= j &amp;lt; col and grid[i][j] for k in range(len(cells) - 1, -1, -1): i, j = cells[k][0] - 1, cells[k][1] - 1 grid[i][j] = True for x, y in [[0, 1], [0, -1], [1, 0], [-1, 0]]: if check(i + x, j + y): p[find(i * col + j)] = find((i + x) * col + j + y) if i == 0: p[find(i * col + j)] = find(top) if i == row - 1: p[find(i * col + j)] = find(bottom) if find(top) == find(bottom): return k return 0</description></item><item><title>1971. Find if Path Exists in Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1971/</guid><description>LeetCode problem 1971
class Solution: def validPath( self, n: int, edges: List[List[int]], source: int, destination: int ) -&amp;gt; bool: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] p = list(range(n)) for u, v in edges: p[find(u)] = find(v) return find(source) == find(destination)</description></item><item><title>1973. Count Nodes Equal to Sum of Descendants</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1973/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1973/</guid><description>LeetCode problem 1973
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def equalToDescendants(self, root: Optional[TreeNode]) -&amp;gt; int: def dfs(root): if root is None: return 0 l, r = dfs(root.left), dfs(root.right) if l + r == root.val: nonlocal res res += 1 return root.val + l + r res = 0 dfs(root) return res</description></item><item><title>1974. Minimum Time to Type Word Using Special Typewriter</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1974/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1974/</guid><description>LeetCode problem 1974
class Solution: def minTimeToType(self, word: str) -&amp;gt; int: res = prev = 0 for c in word: curr = ord(c) - ord(&amp;#39;a&amp;#39;) t = abs(prev - curr) t = min(t, 26 - t) res += t + 1 prev = curr return res</description></item><item><title>1975. Maximum Matrix Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1975/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1975/</guid><description>LeetCode problem 1975
class Solution: def maxMatrixSum(self, matrix: List[List[int]]) -&amp;gt; int: s = cnt = 0 mi = inf for row in matrix: for v in row: s += abs(v) mi = min(mi, abs(v)) if v &amp;lt; 0: cnt += 1 if cnt % 2 == 0 or mi == 0: return s return s - mi * 2</description></item><item><title>1976. Number of Ways to Arrive at Destination</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1976/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1976/</guid><description>LeetCode problem 1976
class Solution: def countPaths(self, n: int, roads: List[List[int]]) -&amp;gt; int: INF = inf MOD = 10**9 + 7 g = [[INF] * n for _ in range(n)] for u, v, t in roads: g[u][v] = t g[v][u] = t g[0][0] = 0 dist = [INF] * n w = [0] * n dist[0] = 0 w[0] = 1 vis = [False] * n for _ in range(n): t = -1 for i in range(n): if not vis[i] and (t == -1 or dist[i] &amp;lt; dist[t]): t = i vis[t] = True for i in range(n): if i == t: continue ne = dist[t] + g[t][i] if dist[i] &amp;gt; ne: dist[i] = ne w[i] = w[t] elif dist[i] == ne: w[i] += w[t] return w[-1] % MOD</description></item><item><title>1977. Number of Ways to Separate Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1977/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1977/</guid><description>LeetCode problem 1977
class Solution: def numberOfCombinations(self, num: str) -&amp;gt; int: def cmp(i, j, k): x = lcp[i][j] return x &amp;gt;= k or num[i + x] &amp;gt;= num[j + x] mod = 10**9 + 7 n = len(num) lcp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n - 1, -1, -1): for j in range(n - 1, -1, -1): if num[i] == num[j]: lcp[i][j] = 1 + lcp[i + 1][j + 1] dp = [[0] * (n + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(1, i + 1): v = 0 if num[i - j] !</description></item><item><title>1979. Find Greatest Common Divisor of Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1979/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1979/</guid><description>LeetCode problem 1979
class Solution: def findGCD(self, nums: List[int]) -&amp;gt; int: return gcd(max(nums), min(nums))</description></item><item><title>1980. Find Unique Binary String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1980/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1980/</guid><description>LeetCode problem 1980
class Solution: def findDifferentBinaryString(self, nums: List[str]) -&amp;gt; str: mask = 0 for x in nums: mask |= 1 &amp;lt;&amp;lt; x.count(&amp;#34;1&amp;#34;) n = len(nums) for i in range(n + 1): if mask &amp;gt;&amp;gt; i &amp;amp; 1 ^ 1: return &amp;#34;1&amp;#34; * i + &amp;#34;0&amp;#34; * (n - i)</description></item><item><title>1981. Minimize the Difference Between Target and Chosen Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1981/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1981/</guid><description>LeetCode problem 1981
class Solution: def minimizeTheDifference(self, mat: List[List[int]], target: int) -&amp;gt; int: f = {0} for row in mat: f = set(a + b for a in f for b in row) return min(abs(v - target) for v in f)</description></item><item><title>1982. Find Array Given Subset Sums</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1982/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1982/</guid><description>LeetCode problem 1982
class Solution: def recoverArray(self, n: int, sums: List[int]) -&amp;gt; List[int]: sums.sort() res = [] for i in range(n, 0, -1): k = 1 &amp;lt;&amp;lt; i d = sums[k - 1] - sums[k - 2] cnt = Counter(sums[:k]) sums1, sums2 = [], [] sign = 1 for s in sums[:k]: if not cnt[s]: continue cnt[s] -= 1 cnt[s + d] -= 1 sums1.append(s) sums2.append(s + d) if s + d == 0: sign = -1 res.append(sign * d) sums = sums1 if sign == 1 else sums2 return res</description></item><item><title>1983. Widest Pair of Indices With Equal Range Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1983/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1983/</guid><description>LeetCode problem 1983
class Solution: def widestPairOfIndices(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: d = {0: -1} res = s = 0 for i, (a, b) in enumerate(zip(nums1, nums2)): s += a - b if s in d: res = max(res, i - d[s]) else: d[s] = i return res</description></item><item><title>1984. Minimum Difference Between Highest and Lowest of K Scores</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1984/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1984/</guid><description>LeetCode problem 1984
class Solution: def minimumDifference(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() return min(nums[i + k - 1] - nums[i] for i in range(len(nums) - k + 1))</description></item><item><title>1985. Find the Kth Largest Integer in the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1985/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1985/</guid><description>LeetCode problem 1985
class Solution: def kthLargestNumber(self, nums: List[str], k: int) -&amp;gt; str: def cmp(a, b): if len(a) != len(b): return len(b) - len(a) return 1 if b &amp;gt; a else -1 nums.sort(key=cmp_to_key(cmp)) return nums[k - 1]</description></item><item><title>1986. Minimum Number of Work Sessions to Finish the Tasks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1986/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1986/</guid><description>LeetCode problem 1986
class Solution: def minSessions(self, tasks: List[int], sessionTime: int) -&amp;gt; int: n = len(tasks) ok = [False] * (1 &amp;lt;&amp;lt; n) for i in range(1, 1 &amp;lt;&amp;lt; n): t = sum(tasks[j] for j in range(n) if i &amp;gt;&amp;gt; j &amp;amp; 1) ok[i] = t &amp;lt;= sessionTime f = [inf] * (1 &amp;lt;&amp;lt; n) f[0] = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): j = i while j: if ok[j]: f[i] = min(f[i], f[i ^ j] + 1) j = (j - 1) &amp;amp; i return f[-1]</description></item><item><title>1987. Number of Unique Good Subsequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1987/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1987/</guid><description>LeetCode problem 1987
class Solution: def numberOfUniqueGoodSubsequences(self, binary: str) -&amp;gt; int: f = g = 0 res = 0 mod = 10**9 + 7 for c in binary: if c == &amp;#34;0&amp;#34;: g = (g + f) % mod res = 1 else: f = (f + g + 1) % mod res = (res + f + g) % mod return res</description></item><item><title>1989. Maximum Number of People That Can Be Caught in Tag</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1989/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1989/</guid><description>LeetCode problem 1989
class Solution: def catchMaximumAmountofPeople(self, team: List[int], dist: int) -&amp;gt; int: res = j = 0 n = len(team) for i, x in enumerate(team): if x: while j &amp;lt; n and (team[j] or i - j &amp;gt; dist): j += 1 if j &amp;lt; n and abs(i - j) &amp;lt;= dist: res += 1 j += 1 return res</description></item><item><title>1991. Find the Middle Index in Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1991/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1991/</guid><description>LeetCode problem 1991
class Solution: def findMiddleIndex(self, nums: List[int]) -&amp;gt; int: left, right = 0, sum(nums) for i, x in enumerate(nums): right -= x if left == right: return i left += x return -1</description></item><item><title>1992. Find All Groups of Farmland</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1992/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1992/</guid><description>LeetCode problem 1992
class Solution: def findFarmland(self, land: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(land), len(land[0]) res = [] for i in range(m): for j in range(n): if ( land[i][j] == 0 or (j &amp;gt; 0 and land[i][j - 1] == 1) or (i &amp;gt; 0 and land[i - 1][j] == 1) ): continue x, y = i, j while x + 1 &amp;lt; m and land[x + 1][j] == 1: x += 1 while y + 1 &amp;lt; n and land[x][y + 1] == 1: y += 1 res.</description></item><item><title>1993. Operations on Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1993/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1993/</guid><description>LeetCode problem 1993
class LockingTree: def __init__(self, parent: List[int]): n = len(parent) self.locked = [-1] * n self.parent = parent self.children = [[] for _ in range(n)] for son, fa in enumerate(parent[1:], 1): self.children[fa].append(son) def lock(self, num: int, user: int) -&amp;gt; bool: if self.locked[num] == -1: self.locked[num] = user return True return False def unlock(self, num: int, user: int) -&amp;gt; bool: if self.locked[num] == user: self.locked[num] = -1 return True return False def upgrade(self, num: int, user: int) -&amp;gt; bool: def dfs(x: int): nonlocal find for y in self.</description></item><item><title>1994. The Number of Good Subsets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1994/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1994/</guid><description>LeetCode problem 1994
class Solution: def numberOfGoodSubsets(self, nums: List[int]) -&amp;gt; int: primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] cnt = Counter(nums) mod = 10**9 + 7 n = len(primes) f = [0] * (1 &amp;lt;&amp;lt; n) f[0] = pow(2, cnt[1]) for x in range(2, 31): if cnt[x] == 0 or x % 4 == 0 or x % 9 == 0 or x % 25 == 0: continue mask = 0 for i, p in enumerate(primes): if x % p == 0: mask |= 1 &amp;lt;&amp;lt; i for state in range((1 &amp;lt;&amp;lt; n) - 1, 0, -1): if state &amp;amp; mask == mask: f[state] = (f[state] + cnt[x] * f[state ^ mask]) % mod return sum(f[i] for i in range(1, 1 &amp;lt;&amp;lt; n)) % mod</description></item><item><title>1995. Count Special Quadruplets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1995/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/1995/</guid><description>LeetCode problem 1995
class Solution: def countQuadruplets(self, nums: List[int]) -&amp;gt; int: res, n = 0, len(nums) counter = Counter() for b in range(n - 3, 0, -1): c = b + 1 for d in range(c + 1, n): counter[nums[d] - nums[c]] += 1 for a in range(b): res += counter[nums[a] + nums[b]] return res</description></item><item><title>1996. The Number of Weak Characters in the Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1996/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1996/</guid><description>LeetCode problem 1996
class Solution: def numberOfWeakCharacters(self, properties: List[List[int]]) -&amp;gt; int: properties.sort(key=lambda x: (-x[0], x[1])) res = mx = 0 for _, x in properties: res += x &amp;lt; mx mx = max(mx, x) return res</description></item><item><title>1997. First Day Where You Have Been in All the Rooms</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1997/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1997/</guid><description>LeetCode problem 1997
class Solution: def firstDayBeenInAllRooms(self, nextVisit: List[int]) -&amp;gt; int: n = len(nextVisit) f = [0] * n mod = 10**9 + 7 for i in range(1, n): f[i] = (f[i - 1] + 1 + f[i - 1] - f[nextVisit[i - 1]] + 1) % mod return f[-1]</description></item><item><title>1998. GCD Sort of an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1998/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/1998/</guid><description>LeetCode problem 1998
class Solution: def gcdSort(self, nums: List[int]) -&amp;gt; bool: n = 10**5 + 10 p = list(range(n)) f = defaultdict(list) mx = max(nums) for i in range(2, mx + 1): if f[i]: continue for j in range(i, mx + 1, i): f[j].append(i) def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] for i in nums: for j in f[i]: p[find(i)] = find(j) s = sorted(nums) for i, num in enumerate(nums): if s[i] != num and find(num) !</description></item><item><title>1999. Smallest Greater Multiple Made of Two Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1999/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/1999/</guid><description>LeetCode problem 1999
class Solution: def findInteger(self, k: int, digit1: int, digit2: int) -&amp;gt; int: if digit1 == 0 and digit2 == 0: return -1 if digit1 &amp;gt; digit2: return self.findInteger(k, digit2, digit1) q = deque([0]) while 1: x = q.popleft() if x &amp;gt; 2**31 - 1: return -1 if x &amp;gt; k and x % k == 0: return x q.append(x * 10 + digit1) if digit1 != digit2: q.append(x * 10 + digit2)</description></item><item><title>2000. Reverse Prefix of Word</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2000/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2000/</guid><description>LeetCode problem 2000
class Solution: def reversePrefix(self, word: str, ch: str) -&amp;gt; str: i = word.find(ch) return word if i == -1 else word[i::-1] + word[i + 1 :]</description></item><item><title>2001. Number of Pairs of Interchangeable Rectangles</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2001/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2001/</guid><description>LeetCode problem 2001
class Solution: def interchangeableRectangles(self, rectangles: List[List[int]]) -&amp;gt; int: res = 0 cnt = Counter() for w, h in rectangles: g = gcd(w, h) w, h = w // g, h // g res += cnt[(w, h)] cnt[(w, h)] += 1 return res</description></item><item><title>2002. Maximum Product of the Length of Two Palindromic Subsequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2002/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2002/</guid><description>LeetCode problem 2002
class Solution: def maxProduct(self, s: str) -&amp;gt; int: n = len(s) p = [True] * (1 &amp;lt;&amp;lt; n) for k in range(1, 1 &amp;lt;&amp;lt; n): i, j = 0, n - 1 while i &amp;lt; j: while i &amp;lt; j and (k &amp;gt;&amp;gt; i &amp;amp; 1) == 0: i += 1 while i &amp;lt; j and (k &amp;gt;&amp;gt; j &amp;amp; 1) == 0: j -= 1 if i &amp;lt; j and s[i] != s[j]: p[k] = False break i, j = i + 1, j - 1 res = 0 for i in range(1, 1 &amp;lt;&amp;lt; n): if p[i]: mx = ((1 &amp;lt;&amp;lt; n) - 1) ^ i j = mx a = i.</description></item><item><title>2003. Smallest Missing Genetic Value in Each Subtree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2003/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2003/</guid><description>LeetCode problem 2003
class Solution: def smallestMissingValueSubtree( self, parents: List[int], nums: List[int] ) -&amp;gt; List[int]: def dfs(i: int): if vis[i]: return vis[i] = True if nums[i] &amp;lt; len(has): has[nums[i]] = True for j in g[i]: dfs(j) n = len(nums) res = [1] * n g = [[] for _ in range(n)] idx = -1 for i, p in enumerate(parents): if i: g[p].append(i) if nums[i] == 1: idx = i if idx == -1: return res vis = [False] * n has = [False] * (n + 2) i = 2 while idx !</description></item><item><title>2006. Count Number of Pairs With Absolute Difference K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2006/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2006/</guid><description>LeetCode problem 2006
class Solution: def countKDifference(self, nums: List[int], k: int) -&amp;gt; int: res = 0 cnt = Counter() for num in nums: res += cnt[num - k] + cnt[num + k] cnt[num] += 1 return res</description></item><item><title>2007. Find Original Array From Doubled Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2007/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2007/</guid><description>LeetCode problem 2007
class Solution: def findOriginalArray(self, changed: List[int]) -&amp;gt; List[int]: n = len(changed) if n &amp;amp; 1: return [] cnt = Counter(changed) changed.sort() res = [] for x in changed: if cnt[x] == 0: continue if cnt[x * 2] &amp;lt;= 0: return [] res.append(x) cnt[x] -= 1 cnt[x * 2] -= 1 return res if len(res) == n // 2 else []</description></item><item><title>2008. Maximum Earnings From Taxi</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2008/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2008/</guid><description>LeetCode problem 2008
class Solution: def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&amp;gt; int: rides.sort(key=lambda x: x[1]) f = [0] * (len(rides) + 1) for i, (st, ed, tip) in enumerate(rides, 1): j = bisect_left(rides, st + 1, hi=i, key=lambda x: x[1]) f[i] = max(f[i - 1], f[j] + ed - st + tip) return f[-1]</description></item><item><title>2009. Minimum Number of Operations to Make Array Continuous</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2009/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2009/</guid><description>LeetCode problem 2009
class Solution: def minOperations(self, nums: List[int]) -&amp;gt; int: n = len(nums) nums = sorted(set(nums)) res, j = n, 0 for i, v in enumerate(nums): while j &amp;lt; len(nums) and nums[j] - v &amp;lt;= n - 1: j += 1 res = min(res, n - (j - i)) return res</description></item><item><title>2011. Final Value of Variable After Performing Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2011/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2011/</guid><description>LeetCode problem 2011
class Solution: def finalValueAfterOperations(self, operations: List[str]) -&amp;gt; int: return sum(1 if s[1] == &amp;#39;+&amp;#39; else -1 for s in operations)</description></item><item><title>2012. Sum of Beauty in the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2012/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2012/</guid><description>LeetCode problem 2012
class Solution: def sumOfBeauties(self, nums: List[int]) -&amp;gt; int: n = len(nums) right = [nums[-1]] * n for i in range(n - 2, -1, -1): right[i] = min(right[i + 1], nums[i]) res = 0 l = nums[0] for i in range(1, n - 1): r = right[i + 1] if l &amp;lt; nums[i] &amp;lt; r: res += 2 elif nums[i - 1] &amp;lt; nums[i] &amp;lt; nums[i + 1]: res += 1 l = max(l, nums[i]) return res</description></item><item><title>2013. Detect Squares</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2013/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2013/</guid><description>LeetCode problem 2013
class DetectSquares: def __init__(self): self.cnt = defaultdict(Counter) def add(self, point: List[int]) -&amp;gt; None: x, y = point self.cnt[x][y] += 1 def count(self, point: List[int]) -&amp;gt; int: x1, y1 = point if x1 not in self.cnt: return 0 res = 0 for x2 in self.cnt.keys(): if x2 != x1: d = x2 - x1 res += self.cnt[x2][y1] * self.cnt[x1][y1 + d] * self.cnt[x2][y1 + d] res += self.cnt[x2][y1] * self.cnt[x1][y1 - d] * self.cnt[x2][y1 - d] return res # Your DetectSquares object will be instantiated and called as such: # obj = DetectSquares() # obj.</description></item><item><title>2015. Average Height of Buildings in Each Segment</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2015/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2015/</guid><description>LeetCode problem 2015
class Solution: def averageHeightOfBuildings(self, buildings: List[List[int]]) -&amp;gt; List[List[int]]: height = defaultdict(int) cnt = defaultdict(int) for s, e, h in buildings: cnt[s] += 1 cnt[e] -= 1 height[s] += h height[e] -= h res = [] i = h = n = 0 for j in sorted(cnt.keys()): if n: t = [i, j, h // n] if res and res[-1][1] == i and res[-1][2] == t[-1]: res[-1][1] = j else: res.append(t) i = j h += height[j] n += cnt[j] return res</description></item><item><title>2016. Maximum Difference Between Increasing Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2016/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2016/</guid><description>LeetCode problem 2016
class Solution: def maximumDifference(self, nums: List[int]) -&amp;gt; int: mi = inf res = -1 for x in nums: if x &amp;gt; mi: res = max(res, x - mi) else: mi = x return res</description></item><item><title>2017. Grid Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2017/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2017/</guid><description>LeetCode problem 2017
class Solution: def gridGame(self, grid: List[List[int]]) -&amp;gt; int: res = inf s1, s2 = sum(grid[0]), 0 for j, v in enumerate(grid[0]): s1 -= v res = min(res, max(s1, s2)) s2 += grid[1][j] return res</description></item><item><title>2018. Check if Word Can Be Placed In Crossword</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2018/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2018/</guid><description>LeetCode problem 2018
class Solution: def placeWordInCrossword(self, board: List[List[str]], word: str) -&amp;gt; bool: def check(i, j, a, b): x, y = i + a * k, j + b * k if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and board[x][y] != &amp;#39;#&amp;#39;: return False for c in word: if ( i &amp;lt; 0 or i &amp;gt;= m or j &amp;lt; 0 or j &amp;gt;= n or (board[i][j] != &amp;#39; &amp;#39; and board[i][j] != c) ): return False i, j = i + a, j + b return True m, n = len(board), len(board[0]) k = len(word) for i in range(m): for j in range(n): left_to_right = (j == 0 or board[i][j - 1] == &amp;#39;#&amp;#39;) and check(i, j, 0, 1) right_to_left = (j == n - 1 or board[i][j + 1] == &amp;#39;#&amp;#39;) and check( i, j, 0, -1 ) up_to_down = (i == 0 or board[i - 1][j] == &amp;#39;#&amp;#39;) and check(i, j, 1, 0) down_to_up = (i == m - 1 or board[i + 1][j] == &amp;#39;#&amp;#39;) and check( i, j, -1, 0 ) if left_to_right or right_to_left or up_to_down or down_to_up: return True return False</description></item><item><title>2019. The Score of Students Solving Math Expression</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2019/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2019/</guid><description>LeetCode problem 2019
class Solution: def scoreOfStudents(self, s: str, answers: List[int]) -&amp;gt; int: def cal(s: str) -&amp;gt; int: res, pre = 0, int(s[0]) for i in range(1, n, 2): if s[i] == &amp;#34;*&amp;#34;: pre *= int(s[i + 1]) else: res += pre pre = int(s[i + 1]) res += pre return res n = len(s) x = cal(s) m = (n + 1) &amp;gt;&amp;gt; 1 f = [[set() for _ in range(m)] for _ in range(m)] for i in range(m): f[i][i] = {int(s[i &amp;lt;&amp;lt; 1])} for i in range(m - 1, -1, -1): for j in range(i, m): for k in range(i, j): for l in f[i][k]: for r in f[k + 1][j]: if s[k &amp;lt;&amp;lt; 1 | 1] == &amp;#34;+&amp;#34; and l + r &amp;lt;= 1000: f[i][j].</description></item><item><title>2021. Brightest Position on Street</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2021/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2021/</guid><description>LeetCode problem 2021
class Solution: def brightestPosition(self, lights: List[List[int]]) -&amp;gt; int: d = defaultdict(int) for i, j in lights: l, r = i - j, i + j d[l] += 1 d[r + 1] -= 1 res = s = mx = 0 for k in sorted(d): s += d[k] if mx &amp;lt; s: mx = s res = k return res</description></item><item><title>2023. Number of Pairs of Strings With Concatenation Equal to Target</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2023/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2023/</guid><description>LeetCode problem 2023
class Solution: def numOfPairs(self, nums: List[str], target: str) -&amp;gt; int: cnt = Counter(nums) res = 0 for i in range(1, len(target)): a, b = target[:i], target[i:] if a != b: res += cnt[a] * cnt[b] else: res += cnt[a] * (cnt[a] - 1) return res</description></item><item><title>2024. Maximize the Confusion of an Exam</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2024/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2024/</guid><description>LeetCode problem 2024
class Solution: def maxConsecutiveAnswers(self, answerKey: str, k: int) -&amp;gt; int: def get(c, k): l = r = -1 while r &amp;lt; len(answerKey) - 1: r += 1 if answerKey[r] == c: k -= 1 if k &amp;lt; 0: l += 1 if answerKey[l] == c: k += 1 return r - l return max(get(&amp;#39;T&amp;#39;, k), get(&amp;#39;F&amp;#39;, k))</description></item><item><title>2025. Maximum Number of Ways to Partition an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2025/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2025/</guid><description>LeetCode problem 2025
class Solution: def waysToPartition(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) s = [nums[0]] * n right = defaultdict(int) for i in range(1, n): s[i] = s[i - 1] + nums[i] right[s[i - 1]] += 1 res = 0 if s[-1] % 2 == 0: res = right[s[-1] // 2] left = defaultdict(int) for v, x in zip(s, nums): d = k - x if (s[-1] + d) % 2 == 0: t = left[(s[-1] + d) // 2] + right[(s[-1] - d) // 2] if res &amp;lt; t: res = t left[v] += 1 right[v] -= 1 return res</description></item><item><title>2027. Minimum Moves to Convert String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2027/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2027/</guid><description>LeetCode problem 2027
class Solution: def minimumMoves(self, s: str) -&amp;gt; int: res = i = 0 while i &amp;lt; len(s): if s[i] == &amp;#34;X&amp;#34;: res += 1 i += 3 else: i += 1 return res</description></item><item><title>2028. Find Missing Observations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2028/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2028/</guid><description>LeetCode problem 2028
class Solution: def missingRolls(self, rolls: List[int], mean: int, n: int) -&amp;gt; List[int]: m = len(rolls) s = (n + m) * mean - sum(rolls) if s &amp;gt; n * 6 or s &amp;lt; n: return [] res = [s // n] * n for i in range(s % n): res[i] += 1 return res</description></item><item><title>2029. Stone Game IX</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2029/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2029/</guid><description>LeetCode problem 2029
class Solution: def stoneGameIX(self, stones: List[int]) -&amp;gt; bool: def check(c): if c[1] == 0: return False c[1] -= 1 turn = 1 + min(c[1], c[2]) * 2 + c[0] if c[1] &amp;gt; c[2]: turn += 1 c[1] -= 1 return turn % 2 == 1 and c[1] != c[2] c = [0] * 3 for s in stones: c[s % 3] += 1 c1 = [c[0], c[2], c[1]] return check(c) or check(c1)</description></item><item><title>2031. Count Subarrays With More Ones Than Zeros</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2031/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2031/</guid><description>LeetCode problem 2031
from sortedcontainers import SortedList class Solution: def subarraysWithMoreZerosThanOnes(self, nums: List[int]) -&amp;gt; int: sl = SortedList([0]) mod = 10**9 + 7 res = s = 0 for x in nums: s += x or -1 res += sl.bisect_left(s) res %= mod sl.add(s) return res</description></item><item><title>2032. Two Out of Three</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2032/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2032/</guid><description>LeetCode problem 2032
class Solution: def twoOutOfThree( self, nums1: List[int], nums2: List[int], nums3: List[int] ) -&amp;gt; List[int]: s1, s2, s3 = set(nums1), set(nums2), set(nums3) return [i for i in range(1, 101) if (i in s1) + (i in s2) + (i in s3) &amp;gt; 1]</description></item><item><title>2033. Minimum Operations to Make a Uni-Value Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2033/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2033/</guid><description>LeetCode problem 2033
class Solution: def minOperations(self, grid: List[List[int]], x: int) -&amp;gt; int: nums = [] mod = grid[0][0] % x for row in grid: for v in row: if v % x != mod: return -1 nums.append(v) nums.sort() mid = nums[len(nums) &amp;gt;&amp;gt; 1] return sum(abs(v - mid) // x for v in nums)</description></item><item><title>2034. Stock Price Fluctuation</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2034/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2034/</guid><description>LeetCode problem 2034
from sortedcontainers import SortedList class StockPrice: def __init__(self): self.d = {} self.ls = SortedList() self.last = 0 def update(self, timestamp: int, price: int) -&amp;gt; None: if timestamp in self.d: self.ls.remove(self.d[timestamp]) self.d[timestamp] = price self.ls.add(price) self.last = max(self.last, timestamp) def current(self) -&amp;gt; int: return self.d[self.last] def maximum(self) -&amp;gt; int: return self.ls[-1] def minimum(self) -&amp;gt; int: return self.ls[0] # Your StockPrice object will be instantiated and called as such: # obj = StockPrice() # obj.update(timestamp,price) # param_2 = obj.</description></item><item><title>2035. Partition Array Into Two Arrays to Minimize Sum Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2035/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2035/</guid><description>LeetCode problem 2035
class Solution: def minimumDifference(self, nums: List[int]) -&amp;gt; int: n = len(nums) &amp;gt;&amp;gt; 1 f = defaultdict(set) g = defaultdict(set) for i in range(1 &amp;lt;&amp;lt; n): s = cnt = 0 s1 = cnt1 = 0 for j in range(n): if (i &amp;amp; (1 &amp;lt;&amp;lt; j)) != 0: s += nums[j] cnt += 1 s1 += nums[n + j] cnt1 += 1 else: s -= nums[j] s1 -= nums[n + j] f[cnt].add(s) g[cnt1].add(s1) res = inf for i in range(n + 1): fi, gi = sorted(list(f[i])), sorted(list(g[n - i])) # min(abs(f[i] + g[n - i])) for a in fi: left, right = 0, len(gi) - 1 b = -a while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if gi[mid] &amp;gt;= b: right = mid else: left = mid + 1 res = min(res, abs(a + gi[left])) if left &amp;gt; 0: res = min(res, abs(a + gi[left - 1])) return res</description></item><item><title>2036. Maximum Alternating Subarray Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2036/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2036/</guid><description>LeetCode problem 2036
class Solution: def maximumAlternatingSubarraySum(self, nums: List[int]) -&amp;gt; int: res = f = g = -inf for x in nums: f, g = max(g, 0) + x, f - x res = max(res, f, g) return res</description></item><item><title>2037. Minimum Number of Moves to Seat Everyone</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2037/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2037/</guid><description>LeetCode problem 2037
class Solution: def minMovesToSeat(self, seats: List[int], students: List[int]) -&amp;gt; int: seats.sort() students.sort() return sum(abs(a - b) for a, b in zip(seats, students))</description></item><item><title>2038. Remove Colored Pieces if Both Neighbors are the Same Color</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2038/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2038/</guid><description>LeetCode problem 2038
class Solution: def winnerOfGame(self, colors: str) -&amp;gt; bool: a = b = 0 for c, v in groupby(colors): m = len(list(v)) - 2 if m &amp;gt; 0 and c == &amp;#39;A&amp;#39;: a += m elif m &amp;gt; 0 and c == &amp;#39;B&amp;#39;: b += m return a &amp;gt; b</description></item><item><title>2039. The Time When the Network Becomes Idle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2039/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2039/</guid><description>LeetCode problem 2039
class Solution: def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -&amp;gt; int: g = defaultdict(list) for u, v in edges: g[u].append(v) g[v].append(u) q = deque([0]) vis = {0} res = d = 0 while q: d += 1 t = d * 2 for _ in range(len(q)): u = q.popleft() for v in g[u]: if v not in vis: vis.add(v) q.append(v) res = max(res, (t - 1) // patience[v] * patience[v] + t + 1) return res</description></item><item><title>2042. Check if Numbers Are Ascending in a Sentence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2042/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2042/</guid><description>LeetCode problem 2042
class Solution: def areNumbersAscending(self, s: str) -&amp;gt; bool: pre = i = 0 n = len(s) while i &amp;lt; n: if s[i].isdigit(): cur = 0 while i &amp;lt; n and s[i].isdigit(): cur = cur * 10 + int(s[i]) i += 1 if pre &amp;gt;= cur: return False pre = cur else: i += 1 return True</description></item><item><title>2043. Simple Bank System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2043/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2043/</guid><description>LeetCode problem 2043
class Bank: def __init__(self, balance: List[int]): self.balance = balance self.n = len(balance) def transfer(self, account1: int, account2: int, money: int) -&amp;gt; bool: if account1 &amp;gt; self.n or account2 &amp;gt; self.n or self.balance[account1 - 1] &amp;lt; money: return False self.balance[account1 - 1] -= money self.balance[account2 - 1] += money return True def deposit(self, account: int, money: int) -&amp;gt; bool: if account &amp;gt; self.n: return False self.balance[account - 1] += money return True def withdraw(self, account: int, money: int) -&amp;gt; bool: if account &amp;gt; self.</description></item><item><title>2044. Count Number of Maximum Bitwise-OR Subsets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2044/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2044/</guid><description>LeetCode problem 2044
class Solution: def countMaxOrSubsets(self, nums: List[int]) -&amp;gt; int: n = len(nums) res = 0 mx = 0 for mask in range(1 &amp;lt;&amp;lt; n): t = 0 for i, v in enumerate(nums): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: t |= v if mx &amp;lt; t: mx = t res = 1 elif mx == t: res += 1 return res</description></item><item><title>2045. Second Minimum Time to Reach Destination</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2045/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2045/</guid><description>LeetCode problem 2045
class Solution: def secondMinimum( self, n: int, edges: List[List[int]], time: int, change: int ) -&amp;gt; int: g = defaultdict(set) for u, v in edges: g[u].add(v) g[v].add(u) q = deque([(1, 0)]) dist = [[inf] * 2 for _ in range(n + 1)] dist[1][1] = 0 while q: u, d = q.popleft() for v in g[u]: if d + 1 &amp;lt; dist[v][0]: dist[v][0] = d + 1 q.append((v, d + 1)) elif dist[v][0] &amp;lt; d + 1 &amp;lt; dist[v][1]: dist[v][1] = d + 1 if v == n: break q.</description></item><item><title>2046. Sort Linked List Already Sorted Using Absolute Values</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2046/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2046/</guid><description>LeetCode problem 2046
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortLinkedList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, curr = head, head.next while curr: if curr.val &amp;lt; 0: t = curr.next prev.next = t curr.next = head head = curr curr = t else: prev, curr = curr, curr.next return head</description></item><item><title>2047. Number of Valid Words in a Sentence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2047/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2047/</guid><description>LeetCode problem 2047
class Solution: def countValidWords(self, sentence: str) -&amp;gt; int: def check(token): hyphen = False for i, c in enumerate(token): if c.isdigit() or (c in &amp;#39;!.,&amp;#39; and i &amp;lt; len(token) - 1): return False if c == &amp;#39;-&amp;#39;: if ( hyphen or i == 0 or i == len(token) - 1 or not token[i - 1].islower() or not token[i + 1].islower() ): return False hyphen = True return True return sum(check(token) for token in sentence.split())</description></item><item><title>2048. Next Greater Numerically Balanced Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2048/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2048/</guid><description>LeetCode problem 2048
class Solution: def nextBeautifulNumber(self, n: int) -&amp;gt; int: for x in count(n + 1): y = x cnt = [0] * 10 while y: y, v = divmod(y, 10) cnt[v] += 1 if all(v == 0 or i == v for i, v in enumerate(cnt)): return x</description></item><item><title>2049. Count Nodes With the Highest Score</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2049/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2049/</guid><description>LeetCode problem 2049
class Solution: def countHighestScoreNodes(self, parents: List[int]) -&amp;gt; int: def dfs(i: int, fa: int): cnt = score = 1 for j in g[i]: if j != fa: t = dfs(j, i) score *= t cnt += t if n - cnt: score *= n - cnt nonlocal res, mx if mx &amp;lt; score: mx = score res = 1 elif mx == score: res += 1 return cnt n = len(parents) g = [[] for _ in range(n)] for i in range(1, n): g[parents[i]].</description></item><item><title>2050. Parallel Courses III</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2050/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2050/</guid><description>LeetCode problem 2050
class Solution: def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -&amp;gt; int: g = defaultdict(list) indeg = [0] * n for a, b in relations: g[a - 1].append(b - 1) indeg[b - 1] += 1 q = deque() f = [0] * n res = 0 for i, (v, t) in enumerate(zip(indeg, time)): if v == 0: q.append(i) f[i] = t res = max(res, t) while q: i = q.popleft() for j in g[i]: f[j] = max(f[j], f[i] + time[j]) res = max(res, f[j]) indeg[j] -= 1 if indeg[j] == 0: q.</description></item><item><title>2052. Minimum Cost to Separate Sentence Into Rows</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2052/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2052/</guid><description>LeetCode problem 2052
class Solution: def minimumCost(self, sentence: str, k: int) -&amp;gt; int: @cache def dfs(i): if s[-1] - s[i] + n - i - 1 &amp;lt;= k: return 0 res, j = inf, i + 1 while j &amp;lt; n and (t := s[j] - s[i] + j - i - 1) &amp;lt;= k: res = min(res, (k - t) ** 2 + dfs(j)) j += 1 return res t = [len(w) for w in sentence.split()] n = len(t) s = list(accumulate(t, initial=0)) return dfs(0)</description></item><item><title>2053. Kth Distinct String in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2053/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2053/</guid><description>LeetCode problem 2053
class Solution: def kthDistinct(self, arr: List[str], k: int) -&amp;gt; str: counter = Counter(arr) for v in arr: if counter[v] == 1: k -= 1 if k == 0: return v return &amp;#39;&amp;#39;</description></item><item><title>2054. Two Best Non-Overlapping Events</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2054/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2054/</guid><description>LeetCode problem 2054
class Solution: def maxTwoEvents(self, events: List[List[int]]) -&amp;gt; int: events.sort() n = len(events) f = [events[-1][2]] * n for i in range(n - 2, -1, -1): f[i] = max(f[i + 1], events[i][2]) res = 0 for _, e, v in events: idx = bisect_right(events, e, key=lambda x: x[0]) if idx &amp;lt; n: v += f[idx] res = max(res, v) return res</description></item><item><title>2055. Plates Between Candles</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2055/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2055/</guid><description>LeetCode problem 2055
class Solution: def platesBetweenCandles(self, s: str, queries: List[List[int]]) -&amp;gt; List[int]: n = len(s) presum = [0] * (n + 1) for i, c in enumerate(s): presum[i + 1] = presum[i] + (c == &amp;#39;*&amp;#39;) left, right = [0] * n, [0] * n l = r = -1 for i, c in enumerate(s): if c == &amp;#39;|&amp;#39;: l = i left[i] = l for i in range(n - 1, -1, -1): if s[i] == &amp;#39;|&amp;#39;: r = i right[i] = r res = [0] * len(queries) for k, (l, r) in enumerate(queries): i, j = right[l], left[r] if i &amp;gt;= 0 and j &amp;gt;= 0 and i &amp;lt; j: res[k] = presum[j] - presum[i + 1] return res</description></item><item><title>2057. Smallest Index With Equal Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2057/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2057/</guid><description>LeetCode problem 2057
class Solution: def smallestEqual(self, nums: List[int]) -&amp;gt; int: for i, v in enumerate(nums): if i % 10 == v: return i return -1</description></item><item><title>2058. Find the Minimum and Maximum Number of Nodes Between Critical Points</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2058/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2058/</guid><description>LeetCode problem 2058
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -&amp;gt; List[int]: prev, curr = head, head.next first = last = None i = 1 res = [inf, -inf] while curr.next: if curr.val &amp;lt; min(prev.val, curr.next.val) or curr.val &amp;gt; max( prev.val, curr.next.val ): if last is None: first = last = i else: res[0] = min(res[0], i - last) res[1] = i - first last = i i += 1 prev, curr = curr, curr.</description></item><item><title>2059. Minimum Operations to Convert Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2059/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2059/</guid><description>LeetCode problem 2059
class Solution: def minimumOperations(self, nums: List[int], start: int, goal: int) -&amp;gt; int: def next(x): res = [] for num in nums: res.append(x + num) res.append(x - num) res.append(x ^ num) return res def extend(m1, m2, q): for _ in range(len(q)): x = q.popleft() step = m1[x] for y in next(x): if y in m1: continue if y in m2: return step + 1 + m2[y] if 0 &amp;lt;= y &amp;lt;= 1000: m1[y] = step + 1 q.</description></item><item><title>2061. Number of Spaces Cleaning Robot Cleaned</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2061/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2061/</guid><description>LeetCode problem 2061
class Solution: def numberOfCleanRooms(self, room: List[List[int]]) -&amp;gt; int: dirs = (0, 1, 0, -1, 0) i = j = k = 0 res = 0 vis = set() while (i, j, k) not in vis: vis.add((i, j, k)) res += room[i][j] == 0 room[i][j] = -1 x, y = i + dirs[k], j + dirs[k + 1] if 0 &amp;lt;= x &amp;lt; len(room) and 0 &amp;lt;= y &amp;lt; len(room[0]) and room[x][y] != 1: i, j = x, y else: k = (k + 1) % 4 return res</description></item><item><title>2062. Count Vowel Substrings of a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2062/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2062/</guid><description>LeetCode problem 2062
class Solution: def countVowelSubstrings(self, word: str) -&amp;gt; int: s = set(&amp;#39;aeiou&amp;#39;) res, n = 0, len(word) for i in range(n): t = set() for c in word[i:]: if c not in s: break t.add(c) res += len(t) == 5 return res</description></item><item><title>2063. Vowels of All Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2063/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2063/</guid><description>LeetCode problem 2063
class Solution: def countVowels(self, word: str) -&amp;gt; int: n = len(word) return sum((i + 1) * (n - i) for i, c in enumerate(word) if c in &amp;#39;aeiou&amp;#39;)</description></item><item><title>2064. Minimized Maximum of Products Distributed to Any Store</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2064/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2064/</guid><description>LeetCode problem 2064
class Solution: def minimizedMaximum(self, n: int, quantities: List[int]) -&amp;gt; int: def check(x): return sum((v + x - 1) // x for v in quantities) &amp;lt;= n return 1 + bisect_left(range(1, 10**6), True, key=check)</description></item><item><title>2067. Number of Equal Count Substrings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2067/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2067/</guid><description>LeetCode problem 2067
class Solution: def equalCountSubstrings(self, s: str, count: int) -&amp;gt; int: res = 0 for x in range(1, 27): m = count * x if m &amp;gt; len(s): break cnt = Counter() y = 0 for i, c in enumerate(s): cnt[c] += 1 y += cnt[c] == count y -= cnt[c] == count + 1 j = i - m if j &amp;gt;= 0: cnt[s[j]] -= 1 y += cnt[s[j]] == count y -= cnt[s[j]] == count - 1 res += x == y return res</description></item><item><title>2068. Check Whether Two Strings are Almost Equivalent</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2068/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2068/</guid><description>LeetCode problem 2068
class Solution: def checkAlmostEquivalent(self, word1: str, word2: str) -&amp;gt; bool: cnt = Counter(word1) for c in word2: cnt[c] -= 1 return all(abs(x) &amp;lt;= 3 for x in cnt.values())</description></item><item><title>2070. Most Beautiful Item for Each Query</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2070/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2070/</guid><description>LeetCode problem 2070
class Solution: def maximumBeauty(self, items: List[List[int]], queries: List[int]) -&amp;gt; List[int]: items.sort() prices = [p for p, _ in items] mx = [items[0][1]] for _, b in items[1:]: mx.append(max(mx[-1], b)) res = [0] * len(queries) for i, q in enumerate(queries): j = bisect_right(prices, q) if j: res[i] = mx[j - 1] return res</description></item><item><title>2071. Maximum Number of Tasks You Can Assign</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2071/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2071/</guid><description>LeetCode problem 2071
class Solution: def maxTaskAssign( self, tasks: List[int], workers: List[int], pills: int, strength: int ) -&amp;gt; int: def check(x): i = 0 q = deque() p = pills for j in range(m - x, m): while i &amp;lt; x and tasks[i] &amp;lt;= workers[j] + strength: q.append(tasks[i]) i += 1 if not q: return False if q[0] &amp;lt;= workers[j]: q.popleft() elif p == 0: return False else: p -= 1 q.pop() return True n, m = len(tasks), len(workers) tasks.</description></item><item><title>2073. Time Needed to Buy Tickets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2073/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2073/</guid><description>LeetCode problem 2073
class Solution: def timeRequiredToBuy(self, tickets: List[int], k: int) -&amp;gt; int: res = 0 for i, t in enumerate(tickets): if i &amp;lt;= k: res += min(tickets[k], t) else: res += min(tickets[k] - 1, t) return res</description></item><item><title>2074. Reverse Nodes in Even Length Groups</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2074/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2074/</guid><description>LeetCode problem 2074
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseEvenLengthGroups(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: def reverse(head, l): prev, cur, tail = None, head, head i = 0 while cur and i &amp;lt; l: t = cur.next cur.next = prev prev = cur cur = t i += 1 tail.next = cur return prev n = 0 t = head while t: t = t.</description></item><item><title>2075. Decode the Slanted Ciphertext</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2075/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2075/</guid><description>LeetCode problem 2075
class Solution: def decodeCiphertext(self, encodedText: str, rows: int) -&amp;gt; str: res = [] cols = len(encodedText) // rows for j in range(cols): x, y = 0, j while x &amp;lt; rows and y &amp;lt; cols: res.append(encodedText[x * cols + y]) x, y = x + 1, y + 1 return &amp;#39;&amp;#39;.join(res).rstrip()</description></item><item><title>2076. Process Restricted Friend Requests</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2076/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2076/</guid><description>LeetCode problem 2076
class Solution: def friendRequests( self, n: int, restrictions: List[List[int]], requests: List[List[int]] ) -&amp;gt; List[bool]: p = list(range(n)) def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] res = [] i = 0 for u, v in requests: if find(u) == find(v): res.append(True) else: valid = True for x, y in restrictions: if (find(u) == find(x) and find(v) == find(y)) or ( find(u) == find(y) and find(v) == find(x) ): valid = False break res.</description></item><item><title>2077. Paths in Maze That Lead to Same Room</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2077/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2077/</guid><description>LeetCode problem 2077
class Solution: def numberOfPaths(self, n: int, corridors: List[List[int]]) -&amp;gt; int: g = defaultdict(set) for a, b in corridors: g[a].add(b) g[b].add(a) res = 0 for i in range(1, n + 1): for j, k in combinations(g[i], 2): if j in g[k]: res += 1 return res // 3</description></item><item><title>2078. Two Furthest Houses With Different Colors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2078/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2078/</guid><description>LeetCode problem 2078
class Solution: def maxDistance(self, colors: List[int]) -&amp;gt; int: n = len(colors) if colors[0] != colors[-1]: return n - 1 i, j = 1, n - 2 while colors[i] == colors[0]: i += 1 while colors[j] == colors[0]: j -= 1 return max(n - i - 1, j)</description></item><item><title>2079. Watering Plants</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2079/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2079/</guid><description>LeetCode problem 2079
class Solution: def wateringPlants(self, plants: List[int], capacity: int) -&amp;gt; int: res, cap = 0, capacity for i, x in enumerate(plants): if cap &amp;gt;= x: cap -= x res += 1 else: cap = capacity - x res += i * 2 + 1 return res</description></item><item><title>2080. Range Frequency Queries</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2080/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2080/</guid><description>LeetCode problem 2080
class RangeFreqQuery: def __init__(self, arr: List[int]): self.mp = defaultdict(list) for i, x in enumerate(arr): self.mp[x].append(i) def query(self, left: int, right: int, value: int) -&amp;gt; int: if value not in self.mp: return 0 arr = self.mp[value] l, r = bisect_right(arr, left - 1), bisect_right(arr, right) return r - l # Your RangeFreqQuery object will be instantiated and called as such: # obj = RangeFreqQuery(arr) # param_1 = obj.query(left,right,value)</description></item><item><title>2083. Substrings That Begin and End With the Same Letter</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2083/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2083/</guid><description>LeetCode problem 2083
class Solution: def numberOfSubstrings(self, s: str) -&amp;gt; int: cnt = Counter() res = 0 for c in s: cnt[c] += 1 res += cnt[c] return res</description></item><item><title>2085. Count Common Words With One Occurrence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2085/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2085/</guid><description>LeetCode problem 2085
class Solution: def countWords(self, words1: List[str], words2: List[str]) -&amp;gt; int: cnt1 = Counter(words1) cnt2 = Counter(words2) return sum(v == 1 and cnt2[w] == 1 for w, v in cnt1.items())</description></item><item><title>2086. Minimum Number of Food Buckets to Feed the Hamsters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2086/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2086/</guid><description>LeetCode problem 2086
class Solution: def minimumBuckets(self, street: str) -&amp;gt; int: res = 0 i, n = 0, len(street) while i &amp;lt; n: if street[i] == &amp;#39;H&amp;#39;: if i + 1 &amp;lt; n and street[i + 1] == &amp;#39;.&amp;#39;: i += 2 res += 1 elif i and street[i - 1] == &amp;#39;.&amp;#39;: res += 1 else: return -1 i += 1 return res</description></item><item><title>2087. Minimum Cost Homecoming of a Robot in a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2087/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2087/</guid><description>LeetCode problem 2087
class Solution: def minCost( self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int], ) -&amp;gt; int: i, j = startPos x, y = homePos res = 0 if i &amp;lt; x: res += sum(rowCosts[i + 1 : x + 1]) else: res += sum(rowCosts[x:i]) if j &amp;lt; y: res += sum(colCosts[j + 1 : y + 1]) else: res += sum(colCosts[y:j]) return res</description></item><item><title>2088. Count Fertile Pyramids in a Land</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2088/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2088/</guid><description>LeetCode problem 2088
class Solution: def countPyramids(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) f = [[0] * n for _ in range(m)] res = 0 for i in range(m - 1, -1, -1): for j in range(n): if grid[i][j] == 0: f[i][j] = -1 elif not (i == m - 1 or j == 0 or j == n - 1): f[i][j] = min(f[i + 1][j - 1], f[i + 1][j], f[i + 1][j + 1]) + 1 res += f[i][j] for i in range(m): for j in range(n): if grid[i][j] == 0: f[i][j] = -1 elif i == 0 or j == 0 or j == n - 1: f[i][j] = 0 else: f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i - 1][j + 1]) + 1 res += f[i][j] return res</description></item><item><title>2089. Find Target Indices After Sorting Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2089/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2089/</guid><description>LeetCode problem 2089
class Solution: def targetIndices(self, nums: List[int], target: int) -&amp;gt; List[int]: nums.sort() return [i for i, v in enumerate(nums) if v == target]</description></item><item><title>2090. K Radius Subarray Averages</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2090/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2090/</guid><description>LeetCode problem 2090
class Solution: def getAverages(self, nums: List[int], k: int) -&amp;gt; List[int]: s = 0 res = [-1] * len(nums) for i, v in enumerate(nums): s += v if i &amp;gt;= k * 2: res[i - k] = s // (k * 2 + 1) s -= nums[i - k * 2] return res</description></item><item><title>2091. Removing Minimum and Maximum From Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2091/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2091/</guid><description>LeetCode problem 2091
class Solution: def minimumDeletions(self, nums: List[int]) -&amp;gt; int: mi = mx = 0 for i, num in enumerate(nums): if num &amp;lt; nums[mi]: mi = i if num &amp;gt; nums[mx]: mx = i if mi &amp;gt; mx: mi, mx = mx, mi return min(mx + 1, len(nums) - mi, mi + 1 + len(nums) - mx)</description></item><item><title>2092. Find All People With Secret</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2092/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2092/</guid><description>LeetCode problem 2092
class Solution: def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -&amp;gt; List[int]: vis = [False] * n vis[0] = vis[firstPerson] = True meetings.sort(key=lambda x: x[2]) i, m = 0, len(meetings) while i &amp;lt; m: j = i while j + 1 &amp;lt; m and meetings[j + 1][2] == meetings[i][2]: j += 1 s = set() g = defaultdict(list) for x, y, _ in meetings[i : j + 1]: g[x].append(y) g[y].append(x) s.update([x, y]) q = deque([u for u in s if vis[u]]) while q: u = q.</description></item><item><title>2093. Minimum Cost to Reach City With Discounts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2093/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2093/</guid><description>LeetCode problem 2093
class Solution: def minimumCost(self, n: int, highways: List[List[int]], discounts: int) -&amp;gt; int: g = defaultdict(list) for a, b, c in highways: g[a].append((b, c)) g[b].append((a, c)) q = [(0, 0, 0)] dist = [[inf] * (discounts + 1) for _ in range(n)] while q: cost, i, k = heappop(q) if k &amp;gt; discounts: continue if i == n - 1: return cost if dist[i][k] &amp;gt; cost: dist[i][k] = cost for j, v in g[i]: heappush(q, (cost + v, j, k)) heappush(q, (cost + v // 2, j, k + 1)) return -1</description></item><item><title>2096. Step-By-Step Directions From a Binary Tree Node to Another</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2096/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2096/</guid><description>LeetCode problem 2096
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getDirections( self, root: Optional[TreeNode], startValue: int, destValue: int ) -&amp;gt; str: edges = defaultdict(list) res = None visited = set() def traverse(root): if not root: return if root.left: edges[root.val].append([root.left.val, &amp;#39;L&amp;#39;]) edges[root.left.val].append([root.val, &amp;#39;U&amp;#39;]) if root.right: edges[root.val].append([root.right.val, &amp;#39;R&amp;#39;]) edges[root.right.val].append([root.val, &amp;#39;U&amp;#39;]) traverse(root.left) traverse(root.right) def dfs(start, dest, t): nonlocal res if start in visited: return if start == dest: if res is None or len(res) &amp;gt; len(t): res = &amp;#39;&amp;#39;.</description></item><item><title>2098. Subsequence of Size K With the Largest Even Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2098/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2098/</guid><description>LeetCode problem 2098
class Solution: def largestEvenSum(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() res = sum(nums[-k:]) if res % 2 == 0: return res n = len(nums) mx1 = mx2 = -inf for x in nums[: n - k]: if x &amp;amp; 1: mx1 = x else: mx2 = x mi1 = mi2 = inf for x in nums[-k:][::-1]: if x &amp;amp; 1: mi2 = x else: mi1 = x res = max(res - mi1 + mx1, res - mi2 + mx2, -1) return -1 if res % 2 else res</description></item><item><title>2099. Find Subsequence of Length K With the Largest Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2099/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2099/</guid><description>LeetCode problem 2099
class Solution: def maxSubsequence(self, nums: List[int], k: int) -&amp;gt; List[int]: idx = list(range(len(nums))) idx.sort(key=lambda i: nums[i]) return [nums[i] for i in sorted(idx[-k:])]</description></item><item><title>2100. Find Good Days to Rob the Bank</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2100/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2100/</guid><description>LeetCode problem 2100
class Solution: def goodDaysToRobBank(self, security: List[int], time: int) -&amp;gt; List[int]: n = len(security) if n &amp;lt;= time * 2: return [] left, right = [0] * n, [0] * n for i in range(1, n): if security[i] &amp;lt;= security[i - 1]: left[i] = left[i - 1] + 1 for i in range(n - 2, -1, -1): if security[i] &amp;lt;= security[i + 1]: right[i] = right[i + 1] + 1 return [i for i in range(n) if time &amp;lt;= min(left[i], right[i])]</description></item><item><title>2101. Detonate the Maximum Bombs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2101/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2101/</guid><description>LeetCode problem 2101
class Solution: def maximumDetonation(self, bombs: List[List[int]]) -&amp;gt; int: def check(i, j): if i == j: return False x, y = bombs[i][0] - bombs[j][0], bombs[i][1] - bombs[j][1] r = bombs[i][2] return r * r &amp;gt;= x * x + y * y g = defaultdict(list) n = len(bombs) for i in range(n): for j in range(n): if check(i, j): g[i].append(j) res = 0 for k in range(n): q = deque([k]) vis = [False] * n vis[k] = True cnt = 0 while q: i = q.</description></item><item><title>2103. Rings and Rods</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2103/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2103/</guid><description>LeetCode problem 2103
class Solution: def countPoints(self, rings: str) -&amp;gt; int: mask = [0] * 10 d = {&amp;#34;R&amp;#34;: 1, &amp;#34;G&amp;#34;: 2, &amp;#34;B&amp;#34;: 4} for i in range(0, len(rings), 2): c = rings[i] j = int(rings[i + 1]) mask[j] |= d[c] return mask.count(7)</description></item><item><title>2104. Sum of Subarray Ranges</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2104/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2104/</guid><description>LeetCode problem 2104
class Solution: def subArrayRanges(self, nums: List[int]) -&amp;gt; int: def f(nums): stk = [] n = len(nums) left = [-1] * n right = [n] * n for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;lt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) return sum((i - left[i]) * (right[i] - i) * v for i, v in enumerate(nums)) mx = f(nums) mi = f([-v for v in nums]) return mx + mi</description></item><item><title>2105. Watering Plants II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2105/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2105/</guid><description>LeetCode problem 2105
class Solution: def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -&amp;gt; int: i, j = 0, len(plants) - 1 res = 0 a, b = capacityA, capacityB while i &amp;lt;= j: if i == j: if max(capacityA, capacityB) &amp;lt; plants[i]: res += 1 break if capacityA &amp;lt; plants[i]: capacityA = a - plants[i] res += 1 else: capacityA -= plants[i] if capacityB &amp;lt; plants[j]: capacityB = b - plants[j] res += 1 else: capacityB -= plants[j] i += 1 j -= 1 return res</description></item><item><title>2106. Maximum Fruits Harvested After at Most K Steps</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2106/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2106/</guid><description>LeetCode problem 2106
class Solution: def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -&amp;gt; int: res = i = s = 0 for j, (pj, fj) in enumerate(fruits): s += fj while ( i &amp;lt;= j and pj - fruits[i][0] + min(abs(startPos - fruits[i][0]), abs(startPos - fruits[j][0])) &amp;gt; k ): s -= fruits[i][1] i += 1 res = max(res, s) return res</description></item><item><title>2107. Number of Unique Flavors After Sharing K Candies</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2107/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2107/</guid><description>LeetCode problem 2107
class Solution: def shareCandies(self, candies: List[int], k: int) -&amp;gt; int: cnt = Counter(candies[k:]) res = len(cnt) for i in range(k, len(candies)): cnt[candies[i - k]] += 1 cnt[candies[i]] -= 1 if cnt[candies[i]] == 0: cnt.pop(candies[i]) res = max(res, len(cnt)) return res</description></item><item><title>2108. Find First Palindromic String in the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2108/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2108/</guid><description>LeetCode problem 2108
class Solution: def firstPalindrome(self, words: List[str]) -&amp;gt; str: return next((w for w in words if w == w[::-1]), &amp;#34;&amp;#34;)</description></item><item><title>2109. Adding Spaces to a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2109/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2109/</guid><description>LeetCode problem 2109
class Solution: def addSpaces(self, s: str, spaces: List[int]) -&amp;gt; str: res = [] i, j = len(s) - 1, len(spaces) - 1 while i &amp;gt;= 0: res.append(s[i]) if j &amp;gt;= 0 and i == spaces[j]: res.append(&amp;#39; &amp;#39;) j -= 1 i -= 1 return &amp;#39;&amp;#39;.join(res[::-1])</description></item><item><title>2110. Number of Smooth Descent Periods of a Stock</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2110/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2110/</guid><description>LeetCode problem 2110
class Solution: def getDescentPeriods(self, prices: List[int]) -&amp;gt; int: res = 0 i, n = 0, len(prices) while i &amp;lt; n: j = i + 1 while j &amp;lt; n and prices[j - 1] - prices[j] == 1: j += 1 cnt = j - i res += (1 + cnt) * cnt // 2 i = j return res</description></item><item><title>2111. Minimum Operations to Make the Array K-Increasing</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2111/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2111/</guid><description>LeetCode problem 2111
class Solution: def kIncreasing(self, arr: List[int], k: int) -&amp;gt; int: def lis(arr): t = [] for x in arr: idx = bisect_right(t, x) if idx == len(t): t.append(x) else: t[idx] = x return len(arr) - len(t) return sum(lis(arr[i::k]) for i in range(k))</description></item><item><title>2113. Elements in Array After Removing and Replacing Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2113/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2113/</guid><description>LeetCode problem 2113
class Solution: def elementInNums(self, nums: List[int], queries: List[List[int]]) -&amp;gt; List[int]: n, m = len(nums), len(queries) res = [-1] * m for j, (t, i) in enumerate(queries): t %= 2 * n if t &amp;lt; n and i &amp;lt; n - t: res[j] = nums[i + t] elif t &amp;gt; n and i &amp;lt; t - n: res[j] = nums[i] return res</description></item><item><title>2114. Maximum Number of Words Found in Sentences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2114/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2114/</guid><description>LeetCode problem 2114
class Solution: def mostWordsFound(self, sentences: List[str]) -&amp;gt; int: return 1 + max(s.count(&amp;#39; &amp;#39;) for s in sentences)</description></item><item><title>2115. Find All Possible Recipes from Given Supplies</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2115/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2115/</guid><description>LeetCode problem 2115
class Solution: def findAllRecipes( self, recipes: List[str], ingredients: List[List[str]], supplies: List[str] ) -&amp;gt; List[str]: g = defaultdict(list) indeg = defaultdict(int) for a, b in zip(recipes, ingredients): for v in b: g[v].append(a) indeg[a] += len(b) q = deque(supplies) res = [] while q: for _ in range(len(q)): i = q.popleft() for j in g[i]: indeg[j] -= 1 if indeg[j] == 0: res.append(j) q.append(j) return res</description></item><item><title>2116. Check if a Parentheses String Can Be Valid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2116/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2116/</guid><description>LeetCode problem 2116
class Solution: def canBeValid(self, s: str, locked: str) -&amp;gt; bool: n = len(s) if n &amp;amp; 1: return False x = 0 for i in range(n): if s[i] == &amp;#39;(&amp;#39; or locked[i] == &amp;#39;0&amp;#39;: x += 1 elif x: x -= 1 else: return False x = 0 for i in range(n - 1, -1, -1): if s[i] == &amp;#39;)&amp;#39; or locked[i] == &amp;#39;0&amp;#39;: x += 1 elif x: x -= 1 else: return False return True</description></item><item><title>2117. Abbreviating the Product of a Range</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2117/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2117/</guid><description>LeetCode problem 2117
class Solution: def abbreviateProduct(self, left: int, right: int) -&amp;gt; str: cnt2 = cnt5 = 0 for x in range(left, right + 1): while x % 2 == 0: cnt2 += 1 x //= 2 while x % 5 == 0: cnt5 += 1 x //= 5 c = cnt2 = cnt5 = min(cnt2, cnt5) pre = suf = 1 gt = False for x in range(left, right + 1): suf *= x while cnt2 and suf % 2 == 0: suf //= 2 cnt2 -= 1 while cnt5 and suf % 5 == 0: suf //= 5 cnt5 -= 1 if suf &amp;gt;= 1e10: gt = True suf %= int(1e10) pre *= x while pre &amp;gt; 1e5: pre /= 10 if gt: return str(int(pre)) + &amp;#34;.</description></item><item><title>2119. A Number After a Double Reversal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2119/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2119/</guid><description>LeetCode problem 2119
class Solution: def isSameAfterReversals(self, num: int) -&amp;gt; bool: return num == 0 or num % 10 != 0</description></item><item><title>2120. Execution of All Suffix Instructions Staying in a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2120/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2120/</guid><description>LeetCode problem 2120
class Solution: def executeInstructions(self, n: int, startPos: List[int], s: str) -&amp;gt; List[int]: res = [] m = len(s) mp = {&amp;#34;L&amp;#34;: [0, -1], &amp;#34;R&amp;#34;: [0, 1], &amp;#34;U&amp;#34;: [-1, 0], &amp;#34;D&amp;#34;: [1, 0]} for i in range(m): x, y = startPos t = 0 for j in range(i, m): a, b = mp[s[j]] if 0 &amp;lt;= x + a &amp;lt; n and 0 &amp;lt;= y + b &amp;lt; n: x, y, t = x + a, y + b, t + 1 else: break res.</description></item><item><title>2121. Intervals Between Identical Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2121/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2121/</guid><description>LeetCode problem 2121
class Solution: def getDistances(self, arr: List[int]) -&amp;gt; List[int]: d = defaultdict(list) n = len(arr) for i, v in enumerate(arr): d[v].append(i) res = [0] * n for v in d.values(): m = len(v) val = sum(v) - v[0] * m for i, p in enumerate(v): delta = v[i] - v[i - 1] if i &amp;gt;= 1 else 0 val += i * delta - (m - i) * delta res[p] = val return res</description></item><item><title>2122. Recover the Original Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2122/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2122/</guid><description>LeetCode problem 2122
class Solution: def recoverArray(self, nums: List[int]) -&amp;gt; List[int]: nums.sort() n = len(nums) for i in range(1, n): d = nums[i] - nums[0] if d == 0 or d % 2 == 1: continue vis = [False] * n vis[i] = True res = [(nums[0] + nums[i]) &amp;gt;&amp;gt; 1] l, r = 1, i + 1 while r &amp;lt; n: while l &amp;lt; n and vis[l]: l += 1 while r &amp;lt; n and nums[r] - nums[l] &amp;lt; d: r += 1 if r == n or nums[r] - nums[l] &amp;gt; d: break vis[r] = True res.</description></item><item><title>2123. Minimum Operations to Remove Adjacent Ones in Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2123/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2123/</guid><description>LeetCode problem 2123
class Solution: def minimumOperations(self, grid: List[List[int]]) -&amp;gt; int: def find(i: int) -&amp;gt; int: for j in g[i]: if j not in vis: vis.add(j) if match[j] == -1 or find(match[j]): match[j] = i return 1 return 0 g = defaultdict(list) m, n = len(grid), len(grid[0]) for i, row in enumerate(grid): for j, v in enumerate(row): if (i + j) % 2 and v: x = i * n + j if i &amp;lt; m - 1 and grid[i + 1][j]: g[x].</description></item><item><title>2124. Check if All A's Appears Before All B's</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2124/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2124/</guid><description>LeetCode problem 2124
class Solution: def checkString(self, s: str) -&amp;gt; bool: return &amp;#34;ba&amp;#34; not in s</description></item><item><title>2125. Number of Laser Beams in a Bank</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2125/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2125/</guid><description>LeetCode problem 2125
class Solution: def numberOfBeams(self, bank: List[str]) -&amp;gt; int: last = res = 0 for b in bank: if (t := b.count(&amp;#39;1&amp;#39;)) &amp;gt; 0: res += last * t last = t return res</description></item><item><title>2126. Destroying Asteroids</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2126/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2126/</guid><description>LeetCode problem 2126
class Solution: def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -&amp;gt; bool: asteroids.sort() for v in asteroids: if mass &amp;lt; v: return False mass += v return True</description></item><item><title>2127. Maximum Employees to Be Invited to a Meeting</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2127/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2127/</guid><description>LeetCode problem 2127
class Solution: def maximumInvitations(self, favorite: List[int]) -&amp;gt; int: def max_cycle(fa: List[int]) -&amp;gt; int: n = len(fa) vis = [False] * n res = 0 for i in range(n): if vis[i]: continue cycle = [] j = i while not vis[j]: cycle.append(j) vis[j] = True j = fa[j] for k, v in enumerate(cycle): if v == j: res = max(res, len(cycle) - k) break return res def topological_sort(fa: List[int]) -&amp;gt; int: n = len(fa) indeg = [0] * n dist = [1] * n for v in fa: indeg[v] += 1 q = deque(i for i, v in enumerate(indeg) if v == 0) while q: i = q.</description></item><item><title>2128. Remove All Ones With Row and Column Flips</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2128/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2128/</guid><description>LeetCode problem 2128
class Solution: def removeOnes(self, grid: List[List[int]]) -&amp;gt; bool: s = set() for row in grid: t = tuple(row) if row[0] == grid[0][0] else tuple(x ^ 1 for x in row) s.add(t) return len(s) == 1</description></item><item><title>2129. Capitalize the Title</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2129/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2129/</guid><description>LeetCode problem 2129
class Solution: def capitalizeTitle(self, title: str) -&amp;gt; str: words = [w.lower() if len(w) &amp;lt; 3 else w.capitalize() for w in title.split()] return &amp;#34; &amp;#34;.join(words)</description></item><item><title>2130. Maximum Twin Sum of a Linked List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2130/</guid><description>LeetCode задача 2130
Задача Дан односвязный список четной длины. Узлы в этом списке имеют &amp;ldquo;близнецов&amp;rdquo; по определенным правилам. Задача — найти максимальную сумму &amp;ldquo;близнецов&amp;rdquo;.
Т.е. у первой половины узлов списка есть свой близнец из второй половины.
Пример: для списка длиной n = 8 i = 0, twin = n-1-i = 8-1-0 = 7 i = 1, twin = n-1-1 = 6 i = 2, twin = n-1-2 = 5 &amp;hellip;
Подсказки У первой половины узлов списка есть свой близнец из второй половины, т.</description></item><item><title>2131. Longest Palindrome by Concatenating Two Letter Words</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2131/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2131/</guid><description>LeetCode problem 2131
class Solution: def longestPalindrome(self, words: List[str]) -&amp;gt; int: cnt = Counter(words) res = x = 0 for k, v in cnt.items(): if k[0] == k[1]: x += v &amp;amp; 1 res += v // 2 * 2 * 2 else: res += min(v, cnt[k[::-1]]) * 2 res += 2 if x else 0 return res</description></item><item><title>2132. Stamping the Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2132/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2132/</guid><description>LeetCode problem 2132
class Solution: def possibleToStamp( self, grid: List[List[int]], stampHeight: int, stampWidth: int ) -&amp;gt; bool: m, n = len(grid), len(grid[0]) s = [[0] * (n + 1) for _ in range(m + 1)] for i, row in enumerate(grid, 1): for j, v in enumerate(row, 1): s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + v d = [[0] * (n + 2) for _ in range(m + 2)] for i in range(1, m - stampHeight + 2): for j in range(1, n - stampWidth + 2): x, y = i + stampHeight - 1, j + stampWidth - 1 if s[x][y] - s[x][j - 1] - s[i - 1][y] + s[i - 1][j - 1] == 0: d[i][j] += 1 d[i][y + 1] -= 1 d[x + 1][j] -= 1 d[x + 1][y + 1] += 1 for i, row in enumerate(grid, 1): for j, v in enumerate(row, 1): d[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1] if v == 0 and d[i][j] == 0: return False return True</description></item><item><title>2133. Check if Every Row and Column Contains All Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2133/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2133/</guid><description>LeetCode problem 2133
class Solution: def checkValid(self, matrix: List[List[int]]) -&amp;gt; bool: n = len(matrix) for i in range(n): seen = [False] * n for j in range(n): v = matrix[i][j] - 1 if seen[v]: return False seen[v] = True for j in range(n): seen = [False] * n for i in range(n): v = matrix[i][j] - 1 if seen[v]: return False seen[v] = True return True</description></item><item><title>2135. Count Words Obtained After Adding a Letter</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2135/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2135/</guid><description>LeetCode problem 2135
class Solution: def wordCount(self, startWords: List[str], targetWords: List[str]) -&amp;gt; int: s = set() for word in startWords: mask = 0 for c in word: mask |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) s.add(mask) res = 0 for word in targetWords: mask = 0 for c in word: mask |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) for c in word: t = mask ^ (1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;))) if t in s: res += 1 break return res</description></item><item><title>2136. Earliest Possible Day of Full Bloom</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2136/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2136/</guid><description>LeetCode problem 2136
class Solution: def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -&amp;gt; int: res = t = 0 for pt, gt in sorted(zip(plantTime, growTime), key=lambda x: -x[1]): t += pt res = max(res, t + gt) return res</description></item><item><title>2137. Pour Water Between Buckets to Make Water Levels Equal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2137/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2137/</guid><description>LeetCode problem 2137
class Solution: def equalizeWater(self, buckets: List[int], loss: int) -&amp;gt; float: def check(v): a = b = 0 for x in buckets: if x &amp;gt;= v: a += x - v else: b += (v - x) * 100 / (100 - loss) return a &amp;gt;= b l, r = 0, max(buckets) while r - l &amp;gt; 1e-5: mid = (l + r) / 2 if check(mid): l = mid else: r = mid return l</description></item><item><title>2138. Divide a String Into Groups of Size k</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2138/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2138/</guid><description>LeetCode problem 2138
class Solution: def divideString(self, s: str, k: int, fill: str) -&amp;gt; List[str]: return [s[i : i + k].ljust(k, fill) for i in range(0, len(s), k)]</description></item><item><title>2139. Minimum Moves to Reach Target Score</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2139/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2139/</guid><description>LeetCode problem 2139
class Solution: def minMoves(self, target: int, maxDoubles: int) -&amp;gt; int: res = 0 while maxDoubles and target &amp;gt; 1: res += 1 if target % 2 == 1: target -= 1 else: maxDoubles -= 1 target &amp;gt;&amp;gt;= 1 res += target - 1 return res</description></item><item><title>2140. Solving Questions With Brainpower</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2140/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2140/</guid><description>LeetCode problem 2140
class Solution: def mostPoints(self, questions: List[List[int]]) -&amp;gt; int: n = len(questions) f = [0] * (n + 1) for i in range(n - 1, -1, -1): p, b = questions[i] j = i + b + 1 f[i] = max(f[i + 1], p + (0 if j &amp;gt; n else f[j])) return f[0]</description></item><item><title>2141. Maximum Running Time of N Computers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2141/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2141/</guid><description>LeetCode problem 2141
class Solution: def maxRunTime(self, n: int, batteries: List[int]) -&amp;gt; int: l, r = 0, sum(batteries) while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 if sum(min(x, mid) for x in batteries) &amp;gt;= n * mid: l = mid else: r = mid - 1 return l</description></item><item><title>2143. Choose Numbers From Two Arrays in Range</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2143/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2143/</guid><description>LeetCode problem 2143
class Solution: def countSubranges(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: n = len(nums1) s1, s2 = sum(nums1), sum(nums2) f = [[0] * (s1 + s2 + 1) for _ in range(n)] res = 0 mod = 10**9 + 7 for i, (a, b) in enumerate(zip(nums1, nums2)): f[i][a + s2] += 1 f[i][-b + s2] += 1 if i: for j in range(s1 + s2 + 1): if j &amp;gt;= a: f[i][j] = (f[i][j] + f[i - 1][j - a]) % mod if j + b &amp;lt; s1 + s2 + 1: f[i][j] = (f[i][j] + f[i - 1][j + b]) % mod res = (res + f[i][s2]) % mod return res</description></item><item><title>2144. Minimum Cost of Buying Candies With Discount</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2144/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2144/</guid><description>LeetCode problem 2144
class Solution: def minimumCost(self, cost: List[int]) -&amp;gt; int: cost.sort(reverse=True) return sum(cost) - sum(cost[2::3])</description></item><item><title>2145. Count the Hidden Sequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2145/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2145/</guid><description>LeetCode problem 2145
class Solution: def numberOfArrays(self, differences: List[int], lower: int, upper: int) -&amp;gt; int: num = mi = mx = 0 for d in differences: num += d mi = min(mi, num) mx = max(mx, num) return max(0, upper - lower - (mx - mi) + 1)</description></item><item><title>2146. K Highest Ranked Items Within a Price Range</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2146/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2146/</guid><description>LeetCode problem 2146
class Solution: def highestRankedKItems( self, grid: List[List[int]], pricing: List[int], start: List[int], k: int ) -&amp;gt; List[List[int]]: m, n = len(grid), len(grid[0]) row, col, low, high = start + pricing items = [] if low &amp;lt;= grid[row][col] &amp;lt;= high: items.append([0, grid[row][col], row, col]) q = deque([(row, col, 0)]) grid[row][col] = 0 while q: i, j, d = q.popleft() for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]: x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and grid[x][y]: if low &amp;lt;= grid[x][y] &amp;lt;= high: items.</description></item><item><title>2147. Number of Ways to Divide a Long Corridor</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2147/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2147/</guid><description>LeetCode problem 2147
class Solution: def numberOfWays(self, corridor: str) -&amp;gt; int: @cache def dfs(i, cnt): if i == n: return int(cnt == 2) cnt += corridor[i] == &amp;#39;S&amp;#39; if cnt &amp;gt; 2: return 0 res = dfs(i + 1, cnt) if cnt == 2: res += dfs(i + 1, 0) res %= mod return res n = len(corridor) mod = 10**9 + 7 res = dfs(0, 0) dfs.cache_clear() return res</description></item><item><title>2148. Count Elements With Strictly Smaller and Greater Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2148/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2148/</guid><description>LeetCode problem 2148
class Solution: def countElements(self, nums: List[int]) -&amp;gt; int: mi, mx = min(nums), max(nums) return sum(mi &amp;lt; num &amp;lt; mx for num in nums)</description></item><item><title>2149. Rearrange Array Elements by Sign</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2149/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2149/</guid><description>LeetCode problem 2149
class Solution: def rearrangeArray(self, nums: List[int]) -&amp;gt; List[int]: res = [0] * len(nums) i, j = 0, 1 for num in nums: if num &amp;gt; 0: res[i] = num i += 2 else: res[j] = num j += 2 return res</description></item><item><title>2150. Find All Lonely Numbers in the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2150/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2150/</guid><description>LeetCode problem 2150
class Solution: def findLonely(self, nums: List[int]) -&amp;gt; List[int]: counter = Counter(nums) res = [] for num, cnt in counter.items(): if cnt == 1 and counter[num - 1] == 0 and counter[num + 1] == 0: res.append(num) return res</description></item><item><title>2151. Maximum Good People Based on Statements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2151/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2151/</guid><description>LeetCode problem 2151
class Solution: def maximumGood(self, statements: List[List[int]]) -&amp;gt; int: def check(mask): cnt = 0 for i, s in enumerate(statements): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: for j, v in enumerate(s): if v &amp;lt; 2 and ((mask &amp;gt;&amp;gt; j) &amp;amp; 1) != v: return 0 cnt += 1 return cnt return max(check(mask) for mask in range(1, 1 &amp;lt;&amp;lt; len(statements)))</description></item><item><title>2152. Minimum Number of Lines to Cover Points</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2152/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2152/</guid><description>LeetCode problem 2152
class Solution: def minimumLines(self, points: List[List[int]]) -&amp;gt; int: def check(i, j, k): x1, y1 = points[i] x2, y2 = points[j] x3, y3 = points[k] return (x2 - x1) * (y3 - y1) == (x3 - x1) * (y2 - y1) @cache def dfs(state): if state == (1 &amp;lt;&amp;lt; n) - 1: return 0 res = inf for i in range(n): if not (state &amp;gt;&amp;gt; i &amp;amp; 1): for j in range(i + 1, n): nxt = state | 1 &amp;lt;&amp;lt; i | 1 &amp;lt;&amp;lt; j for k in range(j + 1, n): if not (nxt &amp;gt;&amp;gt; k &amp;amp; 1) and check(i, j, k): nxt |= 1 &amp;lt;&amp;lt; k res = min(res, dfs(nxt) + 1) if i == n - 1: res = min(res, dfs(state | 1 &amp;lt;&amp;lt; i) + 1) return res n = len(points) return dfs(0)</description></item><item><title>2154. Keep Multiplying Found Values by Two</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2154/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2154/</guid><description>LeetCode problem 2154
class Solution: def findFinalValue(self, nums: List[int], original: int) -&amp;gt; int: s = set(nums) while original in s: original &amp;lt;&amp;lt;= 1 return original</description></item><item><title>2155. All Divisions With the Highest Score of a Binary Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2155/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2155/</guid><description>LeetCode problem 2155
class Solution: def maxScoreIndices(self, nums: List[int]) -&amp;gt; List[int]: left, right = 0, sum(nums) mx = right res = [0] for i, num in enumerate(nums): if num == 0: left += 1 else: right -= 1 t = left + right if mx == t: res.append(i + 1) elif mx &amp;lt; t: mx = t res = [i + 1] return res</description></item><item><title>2157. Groups of Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2157/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2157/</guid><description>LeetCode problem 2157
class Solution: def groupStrings(self, words: List[str]) -&amp;gt; List[int]: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def union(a, b): nonlocal mx, n if b not in p: return pa, pb = find(a), find(b) if pa == pb: return p[pa] = pb size[pb] += size[pa] mx = max(mx, size[pb]) n -= 1 p = {} size = Counter() n = len(words) mx = 0 for word in words: x = 0 for c in word: x |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#39;a&amp;#39;)) p[x] = x size[x] += 1 mx = max(mx, size[x]) if size[x] &amp;gt; 1: n -= 1 for x in p.</description></item><item><title>2158. Amount of New Area Painted Each Day</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2158/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2158/</guid><description>LeetCode problem 2158
class Node: def __init__(self, l, r): self.left = None self.right = None self.l = l self.r = r self.mid = (l + r) &amp;gt;&amp;gt; 1 self.v = 0 self.add = 0 class SegmentTree: def __init__(self): self.root = Node(1, 10**5 + 10) def modify(self, l, r, v, node=None): if l &amp;gt; r: return if node is None: node = self.root if node.l &amp;gt;= l and node.r &amp;lt;= r: node.v = node.r - node.l + 1 node.add = v return self.</description></item><item><title>2160. Minimum Sum of Four Digit Number After Splitting Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2160/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2160/</guid><description>LeetCode problem 2160
class Solution: def minimumSum(self, num: int) -&amp;gt; int: nums = [] while num: nums.append(num % 10) num //= 10 nums.sort() return 10 * (nums[0] + nums[1]) + nums[2] + nums[3]</description></item><item><title>2161. Partition Array According to Given Pivot</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2161/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2161/</guid><description>LeetCode problem 2161
class Solution: def pivotArray(self, nums: List[int], pivot: int) -&amp;gt; List[int]: a, b, c = [], [], [] for x in nums: if x &amp;lt; pivot: a.append(x) elif x == pivot: b.append(x) else: c.append(x) return a + b + c</description></item><item><title>2162. Minimum Cost to Set Cooking Time</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2162/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2162/</guid><description>LeetCode problem 2162
class Solution: def minCostSetTime( self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int ) -&amp;gt; int: def f(m, s): if not 0 &amp;lt;= m &amp;lt; 100 or not 0 &amp;lt;= s &amp;lt; 100: return inf arr = [m // 10, m % 10, s // 10, s % 10] i = 0 while i &amp;lt; 4 and arr[i] == 0: i += 1 t = 0 prev = startAt for v in arr[i:]: if v !</description></item><item><title>2163. Minimum Difference in Sums After Removal of Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2163/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2163/</guid><description>LeetCode problem 2163
class Solution: def minimumDifference(self, nums: List[int]) -&amp;gt; int: m = len(nums) n = m // 3 s = 0 pre = [0] * (m + 1) q1 = [] for i, x in enumerate(nums[: n * 2], 1): s += x heappush(q1, -x) if len(q1) &amp;gt; n: s -= -heappop(q1) pre[i] = s s = 0 suf = [0] * (m + 1) q2 = [] for i in range(m, n, -1): x = nums[i - 1] s += x heappush(q2, x) if len(q2) &amp;gt; n: s -= heappop(q2) suf[i] = s return min(pre[i] - suf[i + 1] for i in range(n, n * 2 + 1))</description></item><item><title>2164. Sort Even and Odd Indices Independently</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2164/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2164/</guid><description>LeetCode problem 2164
class Solution: def sortEvenOdd(self, nums: List[int]) -&amp;gt; List[int]: a = sorted(nums[::2]) b = sorted(nums[1::2], reverse=True) nums[::2] = a nums[1::2] = b return nums</description></item><item><title>2165. Smallest Value of the Rearranged Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2165/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2165/</guid><description>LeetCode problem 2165
class Solution: def smallestNumber(self, num: int) -&amp;gt; int: if num == 0: return 0 cnt = [0] * 10 neg = num &amp;lt; 0 num = abs(num) while num: num, v = divmod(num, 10) cnt[v] += 1 res = &amp;#34;&amp;#34; if neg: for i in range(9, -1, -1): if cnt[i]: res += str(i) * cnt[i] return -int(res) if cnt[0]: for i in range(1, 10): if cnt[i]: res += str(i) cnt[i] -= 1 break for i in range(10): if cnt[i]: res += str(i) * cnt[i] return int(res)</description></item><item><title>2166. Design Bitset</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2166/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2166/</guid><description>LeetCode problem 2166
class Bitset: def __init__(self, size: int): self.a = [&amp;#39;0&amp;#39;] * size self.b = [&amp;#39;1&amp;#39;] * size self.cnt = 0 def fix(self, idx: int) -&amp;gt; None: if self.a[idx] == &amp;#39;0&amp;#39;: self.a[idx] = &amp;#39;1&amp;#39; self.cnt += 1 self.b[idx] = &amp;#39;0&amp;#39; def unfix(self, idx: int) -&amp;gt; None: if self.a[idx] == &amp;#39;1&amp;#39;: self.a[idx] = &amp;#39;0&amp;#39; self.cnt -= 1 self.b[idx] = &amp;#39;1&amp;#39; def flip(self) -&amp;gt; None: self.a, self.b = self.b, self.a self.cnt = len(self.a) - self.cnt def all(self) -&amp;gt; bool: return self.</description></item><item><title>2167. Minimum Time to Remove All Cars Containing Illegal Goods</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2167/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2167/</guid><description>LeetCode problem 2167
class Solution: def minimumTime(self, s: str) -&amp;gt; int: n = len(s) pre = [0] * (n + 1) suf = [0] * (n + 1) for i, c in enumerate(s): pre[i + 1] = pre[i] if c == &amp;#39;0&amp;#39; else min(pre[i] + 2, i + 1) for i in range(n - 1, -1, -1): suf[i] = suf[i + 1] if s[i] == &amp;#39;0&amp;#39; else min(suf[i + 1] + 2, n - i) return min(a + b for a, b in zip(pre[1:], suf[1:]))</description></item><item><title>2168. Unique Substrings With Equal Digit Frequency</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2168/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2168/</guid><description>LeetCode problem 2168
class Solution: def equalDigitFrequency(self, s: str) -&amp;gt; int: def check(i, j): v = set() for k in range(10): cnt = presum[j + 1][k] - presum[i][k] if cnt &amp;gt; 0: v.add(cnt) if len(v) &amp;gt; 1: return False return True n = len(s) presum = [[0] * 10 for _ in range(n + 1)] for i, c in enumerate(s): presum[i + 1][int(c)] += 1 for j in range(10): presum[i + 1][j] += presum[i][j] vis = set(s[i : j + 1] for i in range(n) for j in range(i, n) if check(i, j)) return len(vis)</description></item><item><title>2169. Count Operations to Obtain Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2169/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2169/</guid><description>LeetCode problem 2169
class Solution: def countOperations(self, num1: int, num2: int) -&amp;gt; int: res = 0 while num1 and num2: if num1 &amp;gt;= num2: num1, num2 = num2, num1 num2 -= num1 res += 1 return res</description></item><item><title>2170. Minimum Operations to Make the Array Alternating</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2170/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2170/</guid><description>LeetCode problem 2170
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: def get(i): c = Counter(nums[i::2]).most_common(2) if not c: return [(0, 0), (0, 0)] if len(c) == 1: return [c[0], (0, 0)] return c n = len(nums) return min(n - (n1 + n2) for a, n1 in get(0) for b, n2 in get(1) if a != b)</description></item><item><title>2171. Removing Minimum Number of Magic Beans</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2171/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2171/</guid><description>LeetCode problem 2171
class Solution: def minimumRemoval(self, beans: List[int]) -&amp;gt; int: beans.sort() s, n = sum(beans), len(beans) return min(s - x * (n - i) for i, x in enumerate(beans))</description></item><item><title>2172. Maximum AND Sum of Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2172/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2172/</guid><description>LeetCode problem 2172
class Solution: def maximumANDSum(self, nums: List[int], numSlots: int) -&amp;gt; int: n = len(nums) m = numSlots &amp;lt;&amp;lt; 1 f = [0] * (1 &amp;lt;&amp;lt; m) for i in range(1 &amp;lt;&amp;lt; m): cnt = i.bit_count() if cnt &amp;gt; n: continue for j in range(m): if i &amp;gt;&amp;gt; j &amp;amp; 1: f[i] = max(f[i], f[i ^ (1 &amp;lt;&amp;lt; j)] + (nums[cnt - 1] &amp;amp; (j // 2 + 1))) return max(f)</description></item><item><title>2174. Remove All Ones With Row and Column Flips II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2174/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2174/</guid><description>LeetCode problem 2174
class Solution: def removeOnes(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) state = sum(1 &amp;lt;&amp;lt; (i * n + j) for i in range(m) for j in range(n) if grid[i][j]) q = deque([state]) vis = {state} res = 0 while q: for _ in range(len(q)): state = q.popleft() if state == 0: return res for i in range(m): for j in range(n): if grid[i][j] == 0: continue nxt = state for r in range(m): nxt &amp;amp;= ~(1 &amp;lt;&amp;lt; (r * n + j)) for c in range(n): nxt &amp;amp;= ~(1 &amp;lt;&amp;lt; (i * n + c)) if nxt not in vis: vis.</description></item><item><title>2176. Count Equal and Divisible Pairs in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2176/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2176/</guid><description>LeetCode problem 2176
class Solution: def countPairs(self, nums: List[int], k: int) -&amp;gt; int: n = len(nums) return sum( nums[i] == nums[j] and (i * j) % k == 0 for i in range(n) for j in range(i + 1, n) )</description></item><item><title>2177. Find Three Consecutive Integers That Sum to a Given Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2177/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2177/</guid><description>LeetCode problem 2177
class Solution: def sumOfThree(self, num: int) -&amp;gt; List[int]: x, mod = divmod(num, 3) return [] if mod else [x - 1, x, x + 1]</description></item><item><title>2178. Maximum Split of Positive Even Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2178/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2178/</guid><description>LeetCode problem 2178
class Solution: def maximumEvenSplit(self, finalSum: int) -&amp;gt; List[int]: if finalSum % 2: return [] i = 2 res = [] while i &amp;lt;= finalSum: res.append(i) finalSum -= i i += 2 res[-1] += finalSum return res</description></item><item><title>2179. Count Good Triplets in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2179/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2179/</guid><description>LeetCode problem 2179
class Node: def __init__(self): self.l = 0 self.r = 0 self.v = 0 class SegmentTree: def __init__(self, n): self.tr = [Node() for _ in range(4 * n)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l = l self.tr[u].r = r if l == r: return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) def modify(self, u, x, v): if self.tr[u].l == x and self.</description></item><item><title>2180. Count Integers With Even Digit Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2180/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2180/</guid><description>LeetCode problem 2180
class Solution: def countEven(self, num: int) -&amp;gt; int: res = num // 10 * 5 - 1 x, s = num // 10, 0 while x: s += x % 10 x //= 10 res += (num % 10 + 2 - (s &amp;amp; 1)) &amp;gt;&amp;gt; 1 return res</description></item><item><title>2181. Merge Nodes in Between Zeros</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2181/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2181/</guid><description>LeetCode problem 2181
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeNodes(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = tail = ListNode() s = 0 cur = head.next while cur: if cur.val != 0: s += cur.val else: tail.next = ListNode(s) tail = tail.next s = 0 cur = cur.next return dummy.next</description></item><item><title>2182. Construct String With Repeat Limit</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2182/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2182/</guid><description>LeetCode problem 2182
class Solution: def repeatLimitedString(self, s: str, repeatLimit: int) -&amp;gt; str: cnt = [0] * 26 for c in s: cnt[ord(c) - ord(&amp;#34;a&amp;#34;)] += 1 res = [] j = 24 for i in range(25, -1, -1): j = min(i - 1, j) while 1: x = min(repeatLimit, cnt[i]) cnt[i] -= x res.append(ascii_lowercase[i] * x) if cnt[i] == 0: break while j &amp;gt;= 0 and cnt[j] == 0: j -= 1 if j &amp;lt; 0: break cnt[j] -= 1 res.</description></item><item><title>2184. Number of Ways to Build Sturdy Brick Wall</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2184/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2184/</guid><description>LeetCode problem 2184
class Solution: def buildWall(self, height: int, width: int, bricks: List[int]) -&amp;gt; int: def dfs(v): if v &amp;gt; width: return if v == width: s.append(t[:]) return for x in bricks: t.append(x) dfs(v + x) t.pop() def check(a, b): s1, s2 = a[0], b[0] i = j = 1 while i &amp;lt; len(a) and j &amp;lt; len(b): if s1 == s2: return False if s1 &amp;lt; s2: s1 += a[i] i += 1 else: s2 += b[j] j += 1 return True mod = 10**9 + 7 s = [] t = [] dfs(0) g = defaultdict(list) n = len(s) for i in range(n): if check(s[i], s[i]): g[i].</description></item><item><title>2185. Counting Words With a Given Prefix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2185/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2185/</guid><description>LeetCode problem 2185
class Trie: def __init__(self): self.children = [None] * 26 self.cnt = 0 def insert(self, w): node = self for c in w: i = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[i] is None: node.children[i] = Trie() node = node.children[i] node.cnt += 1 def search(self, pref): node = self for c in pref: i = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[i] is None: return 0 node = node.children[i] return node.cnt class Solution: def prefixCount(self, words: List[str], pref: str) -&amp;gt; int: tree = Trie() for w in words: tree.</description></item><item><title>2186. Minimum Number of Steps to Make Two Strings Anagram II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2186/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2186/</guid><description>LeetCode problem 2186
class Solution: def minSteps(self, s: str, t: str) -&amp;gt; int: cnt = Counter(s) for c in t: cnt[c] -= 1 return sum(abs(v) for v in cnt.values())</description></item><item><title>2187. Minimum Time to Complete Trips</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2187/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2187/</guid><description>LeetCode problem 2187
class Solution: def minimumTime(self, time: List[int], totalTrips: int) -&amp;gt; int: mx = min(time) * totalTrips return bisect_left( range(mx), totalTrips, key=lambda x: sum(x // v for v in time) )</description></item><item><title>2188. Minimum Time to Finish the Race</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2188/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2188/</guid><description>LeetCode problem 2188
class Solution: def minimumFinishTime( self, tires: List[List[int]], changeTime: int, numLaps: int ) -&amp;gt; int: cost = [inf] * 18 for f, r in tires: i, s, t = 1, 0, f while t &amp;lt;= changeTime + f: s += t cost[i] = min(cost[i], s) t *= r i += 1 f = [inf] * (numLaps + 1) f[0] = -changeTime for i in range(1, numLaps + 1): for j in range(1, min(18, i + 1)): f[i] = min(f[i], f[i - j] + cost[j]) f[i] += changeTime return f[numLaps]</description></item><item><title>2189. Number of Ways to Build House of Cards</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2189/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2189/</guid><description>LeetCode problem 2189
class Solution: def houseOfCards(self, n: int) -&amp;gt; int: @cache def dfs(n: int, k: int) -&amp;gt; int: x = 3 * k + 2 if x &amp;gt; n: return 0 if x == n: return 1 return dfs(n - x, k + 1) + dfs(n, k + 1) return dfs(n, 0)</description></item><item><title>2190. Most Frequent Number Following Key In an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2190/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2190/</guid><description>LeetCode problem 2190
class Solution: def mostFrequent(self, nums: List[int], key: int) -&amp;gt; int: cnt = Counter() res = mx = 0 for a, b in pairwise(nums): if a == key: cnt[b] += 1 if mx &amp;lt; cnt[b]: mx = cnt[b] res = b return res</description></item><item><title>2191. Sort the Jumbled Numbers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2191/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2191/</guid><description>LeetCode problem 2191
class Solution: def sortJumbled(self, mapping: List[int], nums: List[int]) -&amp;gt; List[int]: arr = [] for i, x in enumerate(nums): y = mapping[0] if x == 0 else 0 k = 1 while x: x, v = divmod(x, 10) y = mapping[v] * k + y k *= 10 arr.append((y, i)) arr.sort() return [nums[i] for _, i in arr]</description></item><item><title>2192. All Ancestors of a Node in a Directed Acyclic Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2192/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2192/</guid><description>LeetCode problem 2192
class Solution: def getAncestors(self, n: int, edges: List[List[int]]) -&amp;gt; List[List[int]]: def bfs(s: int): q = deque([s]) vis = {s} while q: i = q.popleft() for j in g[i]: if j not in vis: vis.add(j) q.append(j) res[j].append(s) g = defaultdict(list) for u, v in edges: g[u].append(v) res = [[] for _ in range(n)] for i in range(n): bfs(i) return res</description></item><item><title>2193. Minimum Number of Moves to Make Palindrome</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2193/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2193/</guid><description>LeetCode problem 2193
class Solution: def minMovesToMakePalindrome(self, s: str) -&amp;gt; int: cs = list(s) res, n = 0, len(s) i, j = 0, n - 1 while i &amp;lt; j: even = False for k in range(j, i, -1): if cs[i] == cs[k]: even = True while k &amp;lt; j: cs[k], cs[k + 1] = cs[k + 1], cs[k] k += 1 res += 1 j -= 1 break if not even: res += n // 2 - i i += 1 return res</description></item><item><title>2194. Cells in a Range on an Excel Sheet</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2194/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2194/</guid><description>LeetCode problem 2194
class Solution: def cellsInRange(self, s: str) -&amp;gt; List[str]: return [ chr(i) + str(j) for i in range(ord(s[0]), ord(s[-2]) + 1) for j in range(int(s[1]), int(s[-1]) + 1) ]</description></item><item><title>2195. Append K Integers With Minimal Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2195/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2195/</guid><description>LeetCode problem 2195
class Solution: def minimalKSum(self, nums: List[int], k: int) -&amp;gt; int: nums.append(0) nums.append(2 * 10**9) nums.sort() res = 0 for a, b in pairwise(nums): n = min(k, b - a - 1) if n &amp;lt;= 0: continue k -= n res += (a + 1 + a + n) * n // 2 if k == 0: break return res</description></item><item><title>2196. Create Binary Tree From Descriptions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2196/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2196/</guid><description>LeetCode problem 2196
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def createBinaryTree(self, descriptions: List[List[int]]) -&amp;gt; Optional[TreeNode]: g = defaultdict(TreeNode) vis = set() for p, c, left in descriptions: if p not in g: g[p] = TreeNode(p) if c not in g: g[c] = TreeNode(c) if left: g[p].left = g[c] else: g[p].right = g[c] vis.add(c) for v, node in g.</description></item><item><title>2198. Number of Single Divisor Triplets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2198/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2198/</guid><description>LeetCode problem 2198
class Solution: def singleDivisorTriplet(self, nums: List[int]) -&amp;gt; int: def check(a, b, c): s = a + b + c return sum(s % x == 0 for x in [a, b, c]) == 1 counter = Counter(nums) res = 0 for a, cnt1 in counter.items(): for b, cnt2 in counter.items(): for c, cnt3 in counter.items(): if check(a, b, c): if a == b: res += cnt1 * (cnt1 - 1) * cnt3 elif a == c: res += cnt1 * (cnt1 - 1) * cnt2 elif b == c: res += cnt1 * cnt2 * (cnt2 - 1) else: res += cnt1 * cnt2 * cnt3 return res</description></item><item><title>2200. Find All K-Distant Indices in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2200/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2200/</guid><description>LeetCode problem 2200
class Solution: def findKDistantIndices(self, nums: List[int], key: int, k: int) -&amp;gt; List[int]: res = [] j, n = 0, len(nums) for i in range(n): while j &amp;lt; i - k or (j &amp;lt; n and nums[j] != key): j += 1 if j &amp;lt; n and j &amp;lt;= (i + k): res.append(i) return res</description></item><item><title>2201. Count Artifacts That Can Be Extracted</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2201/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2201/</guid><description>LeetCode problem 2201
class Solution: def digArtifacts( self, n: int, artifacts: List[List[int]], dig: List[List[int]] ) -&amp;gt; int: def check(a: List[int]) -&amp;gt; bool: x1, y1, x2, y2 = a return all( (x, y) in s for x in range(x1, x2 + 1) for y in range(y1, y2 + 1) ) s = {(i, j) for i, j in dig} return sum(check(a) for a in artifacts)</description></item><item><title>2202. Maximize the Topmost Element After K Moves</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2202/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2202/</guid><description>LeetCode problem 2202
class Solution: def maximumTop(self, nums: List[int], k: int) -&amp;gt; int: if k == 0: return nums[0] n = len(nums) if n == 1: if k % 2: return -1 return nums[0] res = max(nums[: k - 1], default=-1) if k &amp;lt; n: res = max(res, nums[k]) return res</description></item><item><title>2203. Minimum Weighted Subgraph With the Required Paths</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2203/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2203/</guid><description>LeetCode problem 2203
class Solution: def minimumWeight( self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int ) -&amp;gt; int: def dijkstra(g, u): dist = [inf] * n dist[u] = 0 q = [(0, u)] while q: d, u = heappop(q) if d &amp;gt; dist[u]: continue for v, w in g[u]: if dist[v] &amp;gt; dist[u] + w: dist[v] = dist[u] + w heappush(q, (dist[v], v)) return dist g = defaultdict(list) rg = defaultdict(list) for f, t, w in edges: g[f].</description></item><item><title>2204. Distance to a Cycle in Undirected Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2204/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2204/</guid><description>LeetCode problem 2204
class Solution: def distanceToCycle(self, n: int, edges: List[List[int]]) -&amp;gt; List[int]: g = defaultdict(set) for a, b in edges: g[a].add(b) g[b].add(a) q = deque(i for i in range(n) if len(g[i]) == 1) f = [0] * n seq = [] while q: i = q.popleft() seq.append(i) for j in g[i]: g[j].remove(i) f[i] = j if len(g[j]) == 1: q.append(j) g[i].clear() res = [0] * n for i in seq[::-1]: res[i] = res[f[i]] + 1 return res</description></item><item><title>2206. Divide Array Into Equal Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2206/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2206/</guid><description>LeetCode problem 2206
class Solution: def divideArray(self, nums: List[int]) -&amp;gt; bool: cnt = Counter(nums) return all(v % 2 == 0 for v in cnt.values())</description></item><item><title>2207. Maximize Number of Subsequences in a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2207/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2207/</guid><description>LeetCode problem 2207
class Solution: def maximumSubsequenceCount(self, text: str, pattern: str) -&amp;gt; int: res = 0 cnt = Counter() for c in text: if c == pattern[1]: res += cnt[pattern[0]] cnt[c] += 1 res += max(cnt[pattern[0]], cnt[pattern[1]]) return res</description></item><item><title>2208. Minimum Operations to Halve Array Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2208/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2208/</guid><description>LeetCode problem 2208
class Solution: def halveArray(self, nums: List[int]) -&amp;gt; int: s = sum(nums) / 2 h = [] for v in nums: heappush(h, -v) res = 0 while s &amp;gt; 0: t = -heappop(h) / 2 s -= t heappush(h, -t) res += 1 return res</description></item><item><title>2209. Minimum White Tiles After Covering With Carpets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2209/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2209/</guid><description>LeetCode problem 2209
class Solution: def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -&amp;gt; int: @cache def dfs(i, j): if i &amp;gt;= n: return 0 if floor[i] == &amp;#39;0&amp;#39;: return dfs(i + 1, j) if j == 0: return s[-1] - s[i] return min(1 + dfs(i + 1, j), dfs(i + carpetLen, j - 1)) n = len(floor) s = [0] * (n + 1) for i, c in enumerate(floor): s[i + 1] = s[i] + int(c == &amp;#39;1&amp;#39;) res = dfs(0, numCarpets) dfs.</description></item><item><title>2210. Count Hills and Valleys in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2210/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2210/</guid><description>LeetCode problem 2210
class Solution: def countHillValley(self, nums: List[int]) -&amp;gt; int: res = j = 0 for i in range(1, len(nums) - 1): if nums[i] == nums[i + 1]: continue if nums[i] &amp;gt; nums[j] and nums[i] &amp;gt; nums[i + 1]: res += 1 if nums[i] &amp;lt; nums[j] and nums[i] &amp;lt; nums[i + 1]: res += 1 j = i return res</description></item><item><title>2211. Count Collisions on a Road</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2211/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2211/</guid><description>LeetCode problem 2211
class Solution: def countCollisions(self, directions: str) -&amp;gt; int: d = directions.lstrip(&amp;#39;L&amp;#39;).rstrip(&amp;#39;R&amp;#39;) return len(d) - d.count(&amp;#39;S&amp;#39;)</description></item><item><title>2212. Maximum Points in an Archery Competition</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2212/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2212/</guid><description>LeetCode problem 2212
class Solution: def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -&amp;gt; List[int]: n = len(aliceArrows) state = 0 mx = -1 for mask in range(1 &amp;lt;&amp;lt; n): cnt = points = 0 for i, alice in enumerate(aliceArrows): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: cnt += alice + 1 points += i if cnt &amp;lt;= numArrows and mx &amp;lt; points: state = mask mx = points res = [0] * n for i, alice in enumerate(aliceArrows): if (state &amp;gt;&amp;gt; i) &amp;amp; 1: res[i] = alice + 1 numArrows -= res[i] res[0] = numArrows return res</description></item><item><title>2213. Longest Substring of One Repeating Character</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2213/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2213/</guid><description>LeetCode problem 2213
class Node: def __init__(self): self.l = 0 self.r = 0 self.lmx = 0 self.rmx = 0 self.mx = 0 self.size = 0 self.lc = None self.rc = None N = 100010 tr = [Node() for _ in range(N &amp;lt;&amp;lt; 2)] class SegmentTree: def __init__(self, s): n = len(s) self.s = s self.build(1, 1, n) def build(self, u, l, r): tr[u].l = l tr[u].r = r if l == r: tr[u].lmx = tr[u].rmx = tr[u].mx = tr[u].</description></item><item><title>2214. Minimum Health to Beat Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2214/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2214/</guid><description>LeetCode problem 2214
class Solution: def minimumHealth(self, damage: List[int], armor: int) -&amp;gt; int: return sum(damage) - min(max(damage), armor) + 1</description></item><item><title>2216. Minimum Deletions to Make Array Beautiful</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2216/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2216/</guid><description>LeetCode problem 2216
class Solution: def minDeletion(self, nums: List[int]) -&amp;gt; int: n = len(nums) res = i = 0 while i &amp;lt; n: j = i + 1 while j &amp;lt; n and nums[j] == nums[i]: j += 1 res += 1 i = j + 1 res += (n - res) % 2 return res</description></item><item><title>2217. Find Palindrome With Fixed Length</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2217/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2217/</guid><description>LeetCode problem 2217
class Solution: def kthPalindrome(self, queries: List[int], intLength: int) -&amp;gt; List[int]: l = (intLength + 1) &amp;gt;&amp;gt; 1 start, end = 10 ** (l - 1), 10**l - 1 res = [] for q in queries: v = start + q - 1 if v &amp;gt; end: res.append(-1) continue s = str(v) s += s[::-1][intLength % 2 :] res.append(int(s)) return res</description></item><item><title>2218. Maximum Value of K Coins From Piles</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2218/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2218/</guid><description>LeetCode problem 2218
class Solution: def maxValueOfCoins(self, piles: List[List[int]], k: int) -&amp;gt; int: presum = [list(accumulate(p, initial=0)) for p in piles] dp = [0] * (k + 1) for s in presum: for j in range(k, -1, -1): for idx, v in enumerate(s): if j &amp;gt;= idx: dp[j] = max(dp[j], dp[j - idx] + v) return dp[-1]</description></item><item><title>2219. Maximum Sum Score of Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2219/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2219/</guid><description>LeetCode problem 2219
class Solution: def maximumSumScore(self, nums: List[int]) -&amp;gt; int: s = [0] + list(accumulate(nums)) return max(max(s[i + 1], s[-1] - s[i]) for i in range(len(nums)))</description></item><item><title>2220. Minimum Bit Flips to Convert Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2220/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2220/</guid><description>LeetCode problem 2220
class Solution: def minBitFlips(self, start: int, goal: int) -&amp;gt; int: t = start ^ goal res = 0 while t: res += t &amp;amp; 1 t &amp;gt;&amp;gt;= 1 return res</description></item><item><title>2221. Find Triangular Sum of an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2221/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2221/</guid><description>LeetCode problem 2221
class Solution: def triangularSum(self, nums: List[int]) -&amp;gt; int: n = len(nums) for i in range(n, 0, -1): for j in range(i - 1): nums[j] = (nums[j] + nums[j + 1]) % 10 return nums[0]</description></item><item><title>2222. Number of Ways to Select Buildings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2222/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2222/</guid><description>LeetCode problem 2222
class Solution: def numberOfWays(self, s: str) -&amp;gt; int: n = len(s) cnt0 = s.count(&amp;#34;0&amp;#34;) cnt1 = n - cnt0 c0 = c1 = 0 res = 0 for c in s: if c == &amp;#34;0&amp;#34;: res += c1 * (cnt1 - c1) c0 += 1 else: res += c0 * (cnt0 - c0) c1 += 1 return res</description></item><item><title>2224. Minimum Number of Operations to Convert Time</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2224/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2224/</guid><description>LeetCode problem 2224
class Solution: def convertTime(self, current: str, correct: str) -&amp;gt; int: a = int(current[:2]) * 60 + int(current[3:]) b = int(correct[:2]) * 60 + int(correct[3:]) res, d = 0, b - a for i in [60, 15, 5, 1]: res += d // i d %= i return res</description></item><item><title>2225. Find Players With Zero or One Losses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2225/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2225/</guid><description>LeetCode problem 2225
class Solution: def findWinners(self, matches: List[List[int]]) -&amp;gt; List[List[int]]: cnt = Counter() for a, b in matches: if a not in cnt: cnt[a] = 0 cnt[b] += 1 res = [[], []] for u, v in cnt.items(): if v &amp;lt; 2: res[v].append(u) res[0].sort() res[1].sort() return res</description></item><item><title>2226. Maximum Candies Allocated to K Children</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2226/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2226/</guid><description>LeetCode problem 2226
class Solution: def maximumCandies(self, candies: List[int], k: int) -&amp;gt; int: left, right = 0, max(candies) while left &amp;lt; right: mid = (left + right + 1) &amp;gt;&amp;gt; 1 cnt = sum(v // mid for v in candies) if cnt &amp;gt;= k: left = mid else: right = mid - 1 return left</description></item><item><title>2227. Encrypt and Decrypt Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2227/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2227/</guid><description>LeetCode problem 2227
class Encrypter: def __init__(self, keys: List[str], values: List[str], dictionary: List[str]): self.mp = dict(zip(keys, values)) self.cnt = Counter(self.encrypt(v) for v in dictionary) def encrypt(self, word1: str) -&amp;gt; str: res = [] for c in word1: if c not in self.mp: return &amp;#39;&amp;#39; res.append(self.mp[c]) return &amp;#39;&amp;#39;.join(res) def decrypt(self, word2: str) -&amp;gt; int: return self.cnt[word2] # Your Encrypter object will be instantiated and called as such: # obj = Encrypter(keys, values, dictionary) # param_1 = obj.encrypt(word1) # param_2 = obj.</description></item><item><title>2229. Check if an Array Is Consecutive</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2229/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2229/</guid><description>LeetCode problem 2229
class Solution: def isConsecutive(self, nums: List[int]) -&amp;gt; bool: mi, mx = min(nums), max(nums) n = len(nums) return len(set(nums)) == n and mx == mi + n - 1</description></item><item><title>2231. Largest Number After Digit Swaps by Parity</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2231/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2231/</guid><description>LeetCode problem 2231
class Solution: def largestInteger(self, num: int) -&amp;gt; int: cnt = Counter() x = num while x: x, v = divmod(x, 10) cnt[v] += 1 x = num res = 0 t = 1 while x: x, v = divmod(x, 10) for y in range(10): if ((v ^ y) &amp;amp; 1) == 0 and cnt[y]: res += y * t t *= 10 cnt[y] -= 1 break return res</description></item><item><title>2232. Minimize Result by Adding Parentheses to Expression</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2232/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2232/</guid><description>LeetCode problem 2232
class Solution: def minimizeResult(self, expression: str) -&amp;gt; str: l, r = expression.split(&amp;#34;+&amp;#34;) m, n = len(l), len(r) mi = inf res = None for i in range(m): for j in range(n): c = int(l[i:]) + int(r[: j + 1]) a = 1 if i == 0 else int(l[:i]) b = 1 if j == n - 1 else int(r[j + 1 :]) if (t := a * b * c) &amp;lt; mi: mi = t res = f&amp;#34;{l[:i]}({l[i:]}+{r[: j + 1]}){r[j + 1:]}&amp;#34; return res</description></item><item><title>2233. Maximum Product After K Increments</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2233/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2233/</guid><description>LeetCode problem 2233
class Solution: def maximumProduct(self, nums: List[int], k: int) -&amp;gt; int: heapify(nums) for _ in range(k): heappush(nums, heappop(nums) + 1) res = 1 mod = 10**9 + 7 for v in nums: res = (res * v) % mod return res</description></item><item><title>2234. Maximum Total Beauty of the Gardens</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2234/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2234/</guid><description>LeetCode problem 2234
class Solution: def maximumBeauty( self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int ) -&amp;gt; int: flowers.sort() n = len(flowers) s = list(accumulate(flowers, initial=0)) res, i = 0, n - bisect_left(flowers, target) for x in range(i, n + 1): newFlowers -= 0 if x == 0 else max(target - flowers[n - x], 0) if newFlowers &amp;lt; 0: break l, r = 0, n - x - 1 while l &amp;lt; r: mid = (l + r + 1) &amp;gt;&amp;gt; 1 if flowers[mid] * (mid + 1) - s[mid + 1] &amp;lt;= newFlowers: l = mid else: r = mid - 1 y = 0 if r !</description></item><item><title>2235. Add Two Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2235/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2235/</guid><description>LeetCode problem 2235
class Solution: def sum(self, num1: int, num2: int) -&amp;gt; int: num1, num2 = num1 &amp;amp; 0xFFFFFFFF, num2 &amp;amp; 0xFFFFFFFF while num2: carry = ((num1 &amp;amp; num2) &amp;lt;&amp;lt; 1) &amp;amp; 0xFFFFFFFF num1, num2 = num1 ^ num2, carry return num1 if num1 &amp;lt; 0x80000000 else ~(num1 ^ 0xFFFFFFFF)</description></item><item><title>2236. Root Equals Sum of Children</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2236/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2236/</guid><description>LeetCode problem 2236
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def checkTree(self, root: Optional[TreeNode]) -&amp;gt; bool: return root.val == root.left.val + root.right.val</description></item><item><title>2237. Count Positions on Street With Required Brightness</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2237/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2237/</guid><description>LeetCode problem 2237
class Solution: def meetRequirement( self, n: int, lights: List[List[int]], requirement: List[int] ) -&amp;gt; int: d = [0] * 100010 for p, r in lights: i, j = max(0, p - r), min(n - 1, p + r) d[i] += 1 d[j + 1] -= 1 return sum(s &amp;gt;= r for s, r in zip(accumulate(d), requirement))</description></item><item><title>2239. Find Closest Number to Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2239/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2239/</guid><description>LeetCode problem 2239
class Solution: def findClosestNumber(self, nums: List[int]) -&amp;gt; int: res, d = 0, inf for x in nums: if (y := abs(x)) &amp;lt; d or (y == d and x &amp;gt; res): res, d = x, y return res</description></item><item><title>2240. Number of Ways to Buy Pens and Pencils</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2240/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2240/</guid><description>LeetCode problem 2240
class Solution: def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -&amp;gt; int: res = 0 for x in range(total // cost1 + 1): y = (total - (x * cost1)) // cost2 + 1 res += y return res</description></item><item><title>2241. Design an ATM Machine</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2241/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2241/</guid><description>LeetCode problem 2241
class ATM: def __init__(self): self.cnt = [0] * 5 self.d = [20, 50, 100, 200, 500] def deposit(self, banknotesCount: List[int]) -&amp;gt; None: for i, v in enumerate(banknotesCount): self.cnt[i] += v def withdraw(self, amount: int) -&amp;gt; List[int]: res = [0] * 5 for i in range(4, -1, -1): res[i] = min(amount // self.d[i], self.cnt[i]) amount -= res[i] * self.d[i] if amount &amp;gt; 0: return [-1] for i, v in enumerate(res): self.cnt[i] -= v return res # Your ATM object will be instantiated and called as such: # obj = ATM() # obj.</description></item><item><title>2242. Maximum Score of a Node Sequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2242/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2242/</guid><description>LeetCode problem 2242
class Solution: def maximumScore(self, scores: List[int], edges: List[List[int]]) -&amp;gt; int: g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) for k in g.keys(): g[k] = nlargest(3, g[k], key=lambda x: scores[x]) res = -1 for a, b in edges: for c in g[a]: for d in g[b]: if b != c != d != a: t = scores[a] + scores[b] + scores[c] + scores[d] res = max(res, t) return res</description></item><item><title>2243. Calculate Digit Sum of a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2243/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2243/</guid><description>LeetCode problem 2243
class Solution: def digitSum(self, s: str, k: int) -&amp;gt; str: if len(s) &amp;lt;= k: return s t = [] while s: t.append(str(sum(int(v) for v in s[:k]))) s = s[k:] return self.digitSum(&amp;#39;&amp;#39;.join(t), k)</description></item><item><title>2244. Minimum Rounds to Complete All Tasks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2244/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2244/</guid><description>LeetCode problem 2244
class Solution: def minimumRounds(self, tasks: List[int]) -&amp;gt; int: cnt = Counter(tasks) res = 0 for v in cnt.values(): if v == 1: return -1 res += v // 3 + (v % 3 != 0) return res</description></item><item><title>2245. Maximum Trailing Zeros in a Cornered Path</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2245/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2245/</guid><description>LeetCode problem 2245
class Solution: def maxTrailingZeros(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) r2 = [[0] * (n + 1) for _ in range(m + 1)] c2 = [[0] * (n + 1) for _ in range(m + 1)] r5 = [[0] * (n + 1) for _ in range(m + 1)] c5 = [[0] * (n + 1) for _ in range(m + 1)] for i, row in enumerate(grid, 1): for j, x in enumerate(row, 1): s2 = s5 = 0 while x % 2 == 0: x //= 2 s2 += 1 while x % 5 == 0: x //= 5 s5 += 1 r2[i][j] = r2[i][j - 1] + s2 c2[i][j] = c2[i - 1][j] + s2 r5[i][j] = r5[i][j - 1] + s5 c5[i][j] = c5[i - 1][j] + s5 res = 0 for i in range(1, m + 1): for j in range(1, n + 1): a = min(r2[i][j] + c2[i - 1][j], r5[i][j] + c5[i - 1][j]) b = min(r2[i][j] + c2[m][j] - c2[i][j], r5[i][j] + c5[m][j] - c5[i][j]) c = min(r2[i][n] - r2[i][j] + c2[i][j], r5[i][n] - r5[i][j] + c5[i][j]) d = min( r2[i][n] - r2[i][j - 1] + c2[m][j] - c2[i][j], r5[i][n] - r5[i][j - 1] + c5[m][j] - c5[i][j], ) res = max(res, a, b, c, d) return res</description></item><item><title>2246. Longest Path With Different Adjacent Characters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2246/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2246/</guid><description>LeetCode problem 2246
class Solution: def longestPath(self, parent: List[int], s: str) -&amp;gt; int: def dfs(i: int) -&amp;gt; int: mx = 0 nonlocal res for j in g[i]: x = dfs(j) + 1 if s[i] != s[j]: res = max(res, mx + x) mx = max(mx, x) return mx g = defaultdict(list) for i in range(1, len(parent)): g[parent[i]].append(i) res = 0 dfs(0) return res + 1</description></item><item><title>2247. Maximum Cost of Trip With K Highways</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2247/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2247/</guid><description>LeetCode problem 2247
class Solution: def maximumCost(self, n: int, highways: List[List[int]], k: int) -&amp;gt; int: if k &amp;gt;= n: return -1 g = defaultdict(list) for a, b, cost in highways: g[a].append((b, cost)) g[b].append((a, cost)) f = [[-inf] * n for _ in range(1 &amp;lt;&amp;lt; n)] for i in range(n): f[1 &amp;lt;&amp;lt; i][i] = 0 res = -1 for i in range(1 &amp;lt;&amp;lt; n): for j in range(n): if i &amp;gt;&amp;gt; j &amp;amp; 1: for h, cost in g[j]: if i &amp;gt;&amp;gt; h &amp;amp; 1: f[i][j] = max(f[i][j], f[i ^ (1 &amp;lt;&amp;lt; j)][h] + cost) if i.</description></item><item><title>2248. Intersection of Multiple Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2248/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2248/</guid><description>LeetCode problem 2248
class Solution: def intersection(self, nums: List[List[int]]) -&amp;gt; List[int]: cnt = Counter() res = [] for arr in nums: for x in arr: cnt[x] += 1 if cnt[x] == len(nums): res.append(x) res.sort() return res</description></item><item><title>2249. Count Lattice Points Inside a Circle</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2249/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2249/</guid><description>LeetCode problem 2249
class Solution: def countLatticePoints(self, circles: List[List[int]]) -&amp;gt; int: res = 0 mx = max(x + r for x, _, r in circles) my = max(y + r for _, y, r in circles) for i in range(mx + 1): for j in range(my + 1): for x, y, r in circles: dx, dy = i - x, j - y if dx * dx + dy * dy &amp;lt;= r * r: res += 1 break return res</description></item><item><title>2250. Count Number of Rectangles Containing Each Point</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2250/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2250/</guid><description>LeetCode problem 2250
class Solution: def countRectangles( self, rectangles: List[List[int]], points: List[List[int]] ) -&amp;gt; List[int]: d = defaultdict(list) for x, y in rectangles: d[y].append(x) for y in d.keys(): d[y].sort() res = [] for x, y in points: cnt = 0 for h in range(y, 101): xs = d[h] cnt += len(xs) - bisect_left(xs, x) res.append(cnt) return res</description></item><item><title>2255. Count Prefixes of a Given String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2255/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2255/</guid><description>LeetCode problem 2255
class Solution: def countPrefixes(self, words: List[str], s: str) -&amp;gt; int: return sum(s.startswith(w) for w in words)</description></item><item><title>2256. Minimum Average Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2256/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2256/</guid><description>LeetCode problem 2256
class Solution: def minimumAverageDifference(self, nums: List[int]) -&amp;gt; int: pre, suf = 0, sum(nums) n = len(nums) res, mi = 0, inf for i, x in enumerate(nums): pre += x suf -= x a = pre // (i + 1) b = 0 if n - i - 1 == 0 else suf // (n - i - 1) if (t := abs(a - b)) &amp;lt; mi: res = i mi = t return res</description></item><item><title>2257. Count Unguarded Cells in the Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2257/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2257/</guid><description>LeetCode problem 2257
class Solution: def countUnguarded( self, m: int, n: int, guards: List[List[int]], walls: List[List[int]] ) -&amp;gt; int: g = [[0] * n for _ in range(m)] for i, j in guards: g[i][j] = 2 for i, j in walls: g[i][j] = 2 dirs = (-1, 0, 1, 0, -1) for i, j in guards: for a, b in pairwise(dirs): x, y = i, j while 0 &amp;lt;= x + a &amp;lt; m and 0 &amp;lt;= y + b &amp;lt; n and g[x + a][y + b] &amp;lt; 2: x, y = x + a, y + b g[x][y] = 1 return sum(v == 0 for row in g for v in row)</description></item><item><title>2258. Escape the Spreading Fire</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2258/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2258/</guid><description>LeetCode problem 2258
class Solution: def maximumMinutes(self, grid: List[List[int]]) -&amp;gt; int: def spread(q: Deque[int]) -&amp;gt; Deque[int]: nq = deque() while q: i, j = q.popleft() for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and not fire[x][y] and grid[x][y] == 0: fire[x][y] = True nq.append((x, y)) return nq def check(t: int) -&amp;gt; bool: for i in range(m): for j in range(n): fire[i][j] = False q1 = deque() for i, row in enumerate(grid): for j, x in enumerate(row): if x == 1: fire[i][j] = True q1.</description></item><item><title>2259. Remove Digit From Number to Maximize Result</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2259/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2259/</guid><description>LeetCode problem 2259
class Solution: def removeDigit(self, number: str, digit: str) -&amp;gt; str: last = -1 n = len(number) for i, d in enumerate(number): if d == digit: last = i if i + 1 &amp;lt; n and d &amp;lt; number[i + 1]: break return number[:last] + number[last + 1 :]</description></item><item><title>2260. Minimum Consecutive Cards to Pick Up</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2260/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2260/</guid><description>LeetCode problem 2260
class Solution: def minimumCardPickup(self, cards: List[int]) -&amp;gt; int: last = {} res = inf for i, x in enumerate(cards): if x in last: res = min(res, i - last[x] + 1) last[x] = i return -1 if res == inf else res</description></item><item><title>2261. K Divisible Elements Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2261/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2261/</guid><description>LeetCode problem 2261
class Solution: def countDistinct(self, nums: List[int], k: int, p: int) -&amp;gt; int: n = len(nums) s = set() for i in range(n): cnt = 0 t = &amp;#34;&amp;#34; for x in nums[i:]: cnt += x % p == 0 if cnt &amp;gt; k: break t += str(x) + &amp;#34;,&amp;#34; s.add(t) return len(s)</description></item><item><title>2262. Total Appeal of A String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2262/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2262/</guid><description>LeetCode problem 2262
class Solution: def appealSum(self, s: str) -&amp;gt; int: res = t = 0 pos = [-1] * 26 for i, c in enumerate(s): c = ord(c) - ord(&amp;#39;a&amp;#39;) t += i - pos[c] res += t pos[c] = i return res</description></item><item><title>2263. Make Array Non-decreasing or Non-increasing</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2263/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2263/</guid><description>LeetCode problem 2263
class Solution: def convertArray(self, nums: List[int]) -&amp;gt; int: def solve(nums): n = len(nums) f = [[0] * 1001 for _ in range(n + 1)] for i, x in enumerate(nums, 1): mi = inf for j in range(1001): if mi &amp;gt; f[i - 1][j]: mi = f[i - 1][j] f[i][j] = mi + abs(x - j) return min(f[n]) return min(solve(nums), solve(nums[::-1]))</description></item><item><title>2265. Count Nodes Equal to Average of Subtree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2265/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2265/</guid><description>LeetCode problem 2265
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def averageOfSubtree(self, root: Optional[TreeNode]) -&amp;gt; int: def dfs(root): if root is None: return 0, 0 ls, ln = dfs(root.left) rs, rn = dfs(root.right) s = ls + rs + root.val n = ln + rn + 1 if s // n == root.val: nonlocal res res += 1 return s, n res = 0 dfs(root) return res</description></item><item><title>2266. Count Number of Texts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2266/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2266/</guid><description>LeetCode problem 2266
mod = 10**9 + 7 f = [1, 1, 2, 4] g = [1, 1, 2, 4] for _ in range(100000): f.append((f[-1] + f[-2] + f[-3]) % mod) g.append((g[-1] + g[-2] + g[-3] + g[-4]) % mod) class Solution: def countTexts(self, pressedKeys: str) -&amp;gt; int: res = 1 for ch, s in groupby(pressedKeys): m = len(list(s)) res = res * (g[m] if ch in &amp;#34;79&amp;#34; else f[m]) % mod return res</description></item><item><title>2267. Check if There Is a Valid Parentheses String Path</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2267/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2267/</guid><description>LeetCode problem 2267
class Solution: def hasValidPath(self, grid: List[List[str]]) -&amp;gt; bool: @cache def dfs(i, j, t): if grid[i][j] == &amp;#39;(&amp;#39;: t += 1 else: t -= 1 if t &amp;lt; 0: return False if i == m - 1 and j == n - 1: return t == 0 for x, y in [(i + 1, j), (i, j + 1)]: if x &amp;lt; m and y &amp;lt; n and dfs(x, y, t): return True return False m, n = len(grid), len(grid[0]) return dfs(0, 0, 0)</description></item><item><title>2268. Minimum Number of Keypresses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2268/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2268/</guid><description>LeetCode problem 2268
class Solution: def minimumKeypresses(self, s: str) -&amp;gt; int: cnt = Counter(s) res = 0 i, j = 0, 1 for v in sorted(cnt.values(), reverse=True): i += 1 res += j * v if i % 9 == 0: j += 1 return res</description></item><item><title>2269. Find the K-Beauty of a Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2269/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2269/</guid><description>LeetCode problem 2269
class Solution: def divisorSubstrings(self, num: int, k: int) -&amp;gt; int: res = 0 s = str(num) for i in range(len(s) - k + 1): t = int(s[i : i + k]) if t and num % t == 0: res += 1 return res</description></item><item><title>2270. Number of Ways to Split Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2270/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2270/</guid><description>LeetCode problem 2270
class Solution: def waysToSplitArray(self, nums: List[int]) -&amp;gt; int: s = sum(nums) res = t = 0 for v in nums[:-1]: t += v if t &amp;gt;= s - t: res += 1 return res</description></item><item><title>2271. Maximum White Tiles Covered by a Carpet</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2271/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2271/</guid><description>LeetCode problem 2271
class Solution: def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -&amp;gt; int: tiles.sort() n = len(tiles) s = res = j = 0 for i, (li, ri) in enumerate(tiles): while j &amp;lt; n and tiles[j][1] - li + 1 &amp;lt;= carpetLen: s += tiles[j][1] - tiles[j][0] + 1 j += 1 if j &amp;lt; n and li + carpetLen &amp;gt; tiles[j][0]: res = max(res, s + li + carpetLen - tiles[j][0]) else: res = max(res, s) s -= ri - li + 1 return res</description></item><item><title>2272. Substring With Largest Variance</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2272/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2272/</guid><description>LeetCode problem 2272
class Solution: def largestVariance(self, s: str) -&amp;gt; int: res = 0 for a, b in permutations(ascii_lowercase, 2): if a == b: continue f = [0, -inf] for c in s: if c == a: f[0], f[1] = f[0] + 1, f[1] + 1 elif c == b: f[1] = max(f[1] - 1, f[0] - 1) f[0] = 0 if res &amp;lt; f[1]: res = f[1] return res</description></item><item><title>2273. Find Resultant Array After Removing Anagrams</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2273/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2273/</guid><description>LeetCode problem 2273
class Solution: def removeAnagrams(self, words: List[str]) -&amp;gt; List[str]: return [ w for i, w in enumerate(words) if i == 0 or sorted(w) != sorted(words[i - 1]) ]</description></item><item><title>2274. Maximum Consecutive Floors Without Special Floors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2274/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2274/</guid><description>LeetCode problem 2274
class Solution: def maxConsecutive(self, bottom: int, top: int, special: List[int]) -&amp;gt; int: special.sort() res = max(special[0] - bottom, top - special[-1]) for i in range(1, len(special)): res = max(res, special[i] - special[i - 1] - 1) return res</description></item><item><title>2275. Largest Combination With Bitwise AND Greater Than Zero</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2275/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2275/</guid><description>LeetCode problem 2275
class Solution: def largestCombination(self, candidates: List[int]) -&amp;gt; int: res = 0 for i in range(32): t = 0 for x in candidates: t += (x &amp;gt;&amp;gt; i) &amp;amp; 1 res = max(res, t) return res</description></item><item><title>2276. Count Integers in Intervals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2276/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2276/</guid><description>LeetCode problem 2276
class Node: __slots__ = (&amp;#34;left&amp;#34;, &amp;#34;right&amp;#34;, &amp;#34;l&amp;#34;, &amp;#34;r&amp;#34;, &amp;#34;mid&amp;#34;, &amp;#34;v&amp;#34;, &amp;#34;add&amp;#34;) def __init__(self, l, r): self.left = None self.right = None self.l = l self.r = r self.mid = (l + r) // 2 self.v = 0 self.add = 0 class SegmentTree: def __init__(self): self.root = Node(1, int(1e9) + 1) def modify(self, l, r, v, node=None): if node is None: node = self.root if l &amp;gt; r: return if node.l &amp;gt;= l and node.r &amp;lt;= r: node.</description></item><item><title>2278. Percentage of Letter in String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2278/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2278/</guid><description>LeetCode problem 2278
class Solution: def percentageLetter(self, s: str, letter: str) -&amp;gt; int: return s.count(letter) * 100 // len(s)</description></item><item><title>2279. Maximum Bags With Full Capacity of Rocks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2279/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2279/</guid><description>LeetCode problem 2279
class Solution: def maximumBags( self, capacity: List[int], rocks: List[int], additionalRocks: int ) -&amp;gt; int: d = [a - b for a, b in zip(capacity, rocks)] d.sort() res = 0 for v in d: if v &amp;lt;= additionalRocks: res += 1 additionalRocks -= v return res</description></item><item><title>2280. Minimum Lines to Represent a Line Chart</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2280/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2280/</guid><description>LeetCode problem 2280
class Solution: def minimumLines(self, stockPrices: List[List[int]]) -&amp;gt; int: stockPrices.sort() dx, dy = 0, 1 res = 0 for (x, y), (x1, y1) in pairwise(stockPrices): dx1, dy1 = x1 - x, y1 - y if dy * dx1 != dx * dy1: res += 1 dx, dy = dx1, dy1 return res</description></item><item><title>2281. Sum of Total Strength of Wizards</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2281/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2281/</guid><description>LeetCode problem 2281
class Solution: def totalStrength(self, strength: List[int]) -&amp;gt; int: n = len(strength) left = [-1] * n right = [n] * n stk = [] for i, v in enumerate(strength): while stk and strength[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and strength[stk[-1]] &amp;gt; strength[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) ss = list(accumulate(list(accumulate(strength, initial=0)), initial=0)) mod = int(1e9) + 7 res = 0 for i, v in enumerate(strength): l, r = left[i] + 1, right[i] - 1 a = (ss[r + 2] - ss[i + 1]) * (i - l + 1) b = (ss[i + 1] - ss[l]) * (r - i + 1) res = (res + (a - b) * v) % mod return res</description></item><item><title>2282. Number of People That Can Be Seen in a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2282/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2282/</guid><description>LeetCode problem 2282
class Solution: def seePeople(self, heights: List[List[int]]) -&amp;gt; List[List[int]]: def f(nums: List[int]) -&amp;gt; List[int]: n = len(nums) stk = [] res = [0] * n for i in range(n - 1, -1, -1): while stk and stk[-1] &amp;lt; nums[i]: res[i] += 1 stk.pop() if stk: res[i] += 1 while stk and stk[-1] == nums[i]: stk.pop() stk.append(nums[i]) return res res = [f(row) for row in heights] m, n = len(heights), len(heights[0]) for j in range(n): add = f([heights[i][j] for i in range(m)]) for i in range(m): res[i][j] += add[i] return res</description></item><item><title>2283. Check if Number Has Equal Digit Count and Digit Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2283/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2283/</guid><description>LeetCode problem 2283
class Solution: def digitCount(self, num: str) -&amp;gt; bool: cnt = Counter(num) return all(cnt[str(i)] == int(v) for i, v in enumerate(num))</description></item><item><title>2284. Sender With Largest Word Count</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2284/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2284/</guid><description>LeetCode problem 2284
class Solution: def largestWordCount(self, messages: List[str], senders: List[str]) -&amp;gt; str: cnt = Counter() for msg, sender in zip(messages, senders): cnt[sender] += msg.count(&amp;#39; &amp;#39;) + 1 res = &amp;#39;&amp;#39; for sender, v in cnt.items(): if cnt[res] &amp;lt; v or (cnt[res] == v and res &amp;lt; sender): res = sender return res</description></item><item><title>2285. Maximum Total Importance of Roads</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2285/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2285/</guid><description>LeetCode problem 2285
class Solution: def maximumImportance(self, n: int, roads: List[List[int]]) -&amp;gt; int: deg = [0] * n for a, b in roads: deg[a] += 1 deg[b] += 1 deg.sort() return sum(i * v for i, v in enumerate(deg, 1))</description></item><item><title>2286. Booking Concert Tickets in Groups</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2286/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2286/</guid><description>LeetCode problem 2286
class Node: def __init__(self): self.l = self.r = 0 self.s = self.mx = 0 class SegmentTree: def __init__(self, n, m): self.m = m self.tr = [Node() for _ in range(n &amp;lt;&amp;lt; 2)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l, self.tr[u].r = l, r if l == r: self.tr[u].s = self.tr[u].mx = self.m return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) self.</description></item><item><title>2287. Rearrange Characters to Make Target String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2287/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2287/</guid><description>LeetCode problem 2287
class Solution: def rearrangeCharacters(self, s: str, target: str) -&amp;gt; int: cnt1 = Counter(s) cnt2 = Counter(target) return min(cnt1[c] // v for c, v in cnt2.items())</description></item><item><title>2288. Apply Discount to Prices</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2288/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2288/</guid><description>LeetCode problem 2288
class Solution: def discountPrices(self, sentence: str, discount: int) -&amp;gt; str: res = [] for w in sentence.split(): if w[0] == &amp;#39;$&amp;#39; and w[1:].isdigit(): w = f&amp;#39;${int(w[1:]) * (1 - discount / 100):.2f}&amp;#39; res.append(w) return &amp;#39; &amp;#39;.join(res)</description></item><item><title>2289. Steps to Make Array Non-decreasing</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2289/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2289/</guid><description>LeetCode problem 2289
class Solution: def totalSteps(self, nums: List[int]) -&amp;gt; int: stk = [] res, n = 0, len(nums) dp = [0] * n for i in range(n - 1, -1, -1): while stk and nums[i] &amp;gt; nums[stk[-1]]: dp[i] = max(dp[i] + 1, dp[stk.pop()]) stk.append(i) return max(dp)</description></item><item><title>2290. Minimum Obstacle Removal to Reach Corner</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2290/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2290/</guid><description>LeetCode problem 2290
class Solution: def minimumObstacles(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) q = deque([(0, 0, 0)]) vis = set() dirs = (-1, 0, 1, 0, -1) while 1: i, j, k = q.popleft() if i == m - 1 and j == n - 1: return k if (i, j) in vis: continue vis.add((i, j)) for a, b in pairwise(dirs): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n: if grid[x][y] == 0: q.</description></item><item><title>2291. Maximum Profit From Trading Stocks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2291/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2291/</guid><description>LeetCode problem 2291
class Solution: def maximumProfit(self, present: List[int], future: List[int], budget: int) -&amp;gt; int: f = [0] * (budget + 1) for a, b in zip(present, future): for j in range(budget, a - 1, -1): f[j] = max(f[j], f[j - a] + b - a) return f[-1]</description></item><item><title>2293. Min Max Game</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2293/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2293/</guid><description>LeetCode problem 2293
class Solution: def minMaxGame(self, nums: List[int]) -&amp;gt; int: n = len(nums) while n &amp;gt; 1: n &amp;gt;&amp;gt;= 1 for i in range(n): a, b = nums[i &amp;lt;&amp;lt; 1], nums[i &amp;lt;&amp;lt; 1 | 1] nums[i] = min(a, b) if i % 2 == 0 else max(a, b) return nums[0]</description></item><item><title>2294. Partition Array Such That Maximum Difference Is K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2294/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2294/</guid><description>LeetCode problem 2294
class Solution: def partitionArray(self, nums: List[int], k: int) -&amp;gt; int: nums.sort() res, a = 1, nums[0] for b in nums: if b - a &amp;gt; k: a = b res += 1 return res</description></item><item><title>2295. Replace Elements in an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2295/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2295/</guid><description>LeetCode problem 2295
class Solution: def arrayChange(self, nums: List[int], operations: List[List[int]]) -&amp;gt; List[int]: d = {v: i for i, v in enumerate(nums)} for a, b in operations: nums[d[a]] = b d[b] = d[a] return nums</description></item><item><title>2296. Design a Text Editor</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2296/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2296/</guid><description>LeetCode problem 2296
class TextEditor: def __init__(self): self.left = [] self.right = [] def addText(self, text: str) -&amp;gt; None: self.left.extend(list(text)) def deleteText(self, k: int) -&amp;gt; int: k = min(k, len(self.left)) for _ in range(k): self.left.pop() return k def cursorLeft(self, k: int) -&amp;gt; str: k = min(k, len(self.left)) for _ in range(k): self.right.append(self.left.pop()) return &amp;#39;&amp;#39;.join(self.left[-10:]) def cursorRight(self, k: int) -&amp;gt; str: k = min(k, len(self.right)) for _ in range(k): self.left.append(self.right.pop()) return &amp;#39;&amp;#39;.join(self.left[-10:]) # Your TextEditor object will be instantiated and called as such: # obj = TextEditor() # obj.</description></item><item><title>2297. Jump Game VIII</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2297/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2297/</guid><description>LeetCode problem 2297
class Solution: def minCost(self, nums: List[int], costs: List[int]) -&amp;gt; int: n = len(nums) g = defaultdict(list) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;lt; nums[i]: stk.pop() if stk: g[i].append(stk[-1]) stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt;= nums[i]: stk.pop() if stk: g[i].append(stk[-1]) stk.append(i) f = [inf] * n f[0] = 0 for i in range(n): for j in g[i]: f[j] = min(f[j], f[i] + costs[j]) return f[n - 1]</description></item><item><title>2299. Strong Password Checker II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2299/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2299/</guid><description>LeetCode problem 2299
class Solution: def strongPasswordCheckerII(self, password: str) -&amp;gt; bool: if len(password) &amp;lt; 8: return False mask = 0 for i, c in enumerate(password): if i and c == password[i - 1]: return False if c.islower(): mask |= 1 elif c.isupper(): mask |= 2 elif c.isdigit(): mask |= 4 else: mask |= 8 return mask == 15</description></item><item><title>2300. Successful Pairs of Spells and Potions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2300/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2300/</guid><description>LeetCode problem 2300
class Solution: def successfulPairs( self, spells: List[int], potions: List[int], success: int ) -&amp;gt; List[int]: potions.sort() m = len(potions) return [m - bisect_left(potions, success / v) for v in spells]</description></item><item><title>2301. Match Substring After Replacement</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2301/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2301/</guid><description>LeetCode problem 2301
class Solution: def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -&amp;gt; bool: d = [[False] * 128 for _ in range(128)] for a, b in mappings: d[ord(a)][ord(b)] = True for i in range(len(s) - len(sub) + 1): if all( a == b or d[ord(b)][ord(a)] for a, b in zip(s[i : i + len(sub)], sub) ): return True return False</description></item><item><title>2302. Count Subarrays With Score Less Than K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2302/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2302/</guid><description>LeetCode problem 2302
class Solution: def countSubarrays(self, nums: List[int], k: int) -&amp;gt; int: res = s = j = 0 for i, v in enumerate(nums): s += v while s * (i - j + 1) &amp;gt;= k: s -= nums[j] j += 1 res += i - j + 1 return res</description></item><item><title>2303. Calculate Amount Paid in Taxes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2303/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2303/</guid><description>LeetCode problem 2303
class Solution: def calculateTax(self, brackets: List[List[int]], income: int) -&amp;gt; float: res = prev = 0 for upper, percent in brackets: res += max(0, min(income, upper) - prev) * percent prev = upper return res / 100</description></item><item><title>2304. Minimum Path Cost in a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2304/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2304/</guid><description>LeetCode problem 2304
class Solution: def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) f = grid[0] for i in range(1, m): g = [inf] * n for j in range(n): for k in range(n): g[j] = min(g[j], f[k] + moveCost[grid[i - 1][k]][j] + grid[i][j]) f = g return min(f)</description></item><item><title>2305. Fair Distribution of Cookies</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2305/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2305/</guid><description>LeetCode problem 2305
class Solution: def distributeCookies(self, cookies: List[int], k: int) -&amp;gt; int: def dfs(i): if i &amp;gt;= len(cookies): nonlocal res res = max(cnt) return for j in range(k): if cnt[j] + cookies[i] &amp;gt;= res or (j and cnt[j] == cnt[j - 1]): continue cnt[j] += cookies[i] dfs(i + 1) cnt[j] -= cookies[i] res = inf cnt = [0] * k cookies.sort(reverse=True) dfs(0) return res</description></item><item><title>2306. Naming a Company</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2306/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2306/</guid><description>LeetCode problem 2306
class Solution: def distinctNames(self, ideas: List[str]) -&amp;gt; int: s = set(ideas) f = [[0] * 26 for _ in range(26)] for v in ideas: i = ord(v[0]) - ord(&amp;#39;a&amp;#39;) t = list(v) for j in range(26): t[0] = chr(ord(&amp;#39;a&amp;#39;) + j) if &amp;#39;&amp;#39;.join(t) not in s: f[i][j] += 1 res = 0 for v in ideas: i = ord(v[0]) - ord(&amp;#39;a&amp;#39;) t = list(v) for j in range(26): t[0] = chr(ord(&amp;#39;a&amp;#39;) + j) if &amp;#39;&amp;#39;.join(t) not in s: res += f[j][i] return res</description></item><item><title>2307. Check for Contradictions in Equations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2307/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2307/</guid><description>LeetCode problem 2307
class Solution: def checkContradictions( self, equations: List[List[str]], values: List[float] ) -&amp;gt; bool: def find(x: int) -&amp;gt; int: if p[x] != x: root = find(p[x]) w[x] *= w[p[x]] p[x] = root return p[x] d = defaultdict(int) n = 0 for e in equations: for s in e: if s not in d: d[s] = n n += 1 p = list(range(n)) w = [1.0] * n eps = 1e-5 for (a, b), v in zip(equations, values): a, b = d[a], d[b] pa, pb = find(a), find(b) if pa !</description></item><item><title>2309. Greatest English Letter in Upper and Lower Case</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2309/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2309/</guid><description>LeetCode problem 2309
class Solution: def greatestLetter(self, s: str) -&amp;gt; str: mask1 = mask2 = 0 for c in s: if c.islower(): mask1 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;a&amp;#34;)) else: mask2 |= 1 &amp;lt;&amp;lt; (ord(c) - ord(&amp;#34;A&amp;#34;)) mask = mask1 &amp;amp; mask2 return chr(mask.bit_length() - 1 + ord(&amp;#34;A&amp;#34;)) if mask else &amp;#34;&amp;#34;</description></item><item><title>2310. Sum of Numbers With Units Digit K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2310/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2310/</guid><description>LeetCode problem 2310
class Solution: def minimumNumbers(self, num: int, k: int) -&amp;gt; int: @cache def dfs(v): if v == 0: return 0 if v &amp;lt; 10 and v % k: return inf i = 0 t = inf while (x := i * 10 + k) &amp;lt;= v: t = min(t, dfs(v - x)) i += 1 return t + 1 if num == 0: return 0 if k == 0: return -1 if num % 10 else 1 res = dfs(num) return -1 if res &amp;gt;= inf else res</description></item><item><title>2311. Longest Binary Subsequence Less Than or Equal to K</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2311/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2311/</guid><description>LeetCode problem 2311
class Solution: def longestSubsequence(self, s: str, k: int) -&amp;gt; int: res = v = 0 for c in s[::-1]: if c == &amp;#34;0&amp;#34;: res += 1 elif res &amp;lt; 30 and (v | 1 &amp;lt;&amp;lt; res) &amp;lt;= k: v |= 1 &amp;lt;&amp;lt; res res += 1 return res</description></item><item><title>2312. Selling Pieces of Wood</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2312/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2312/</guid><description>LeetCode problem 2312
class Solution: def sellingWood(self, m: int, n: int, prices: List[List[int]]) -&amp;gt; int: d = defaultdict(dict) for h, w, p in prices: d[h][w] = p dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): dp[i][j] = d[i].get(j, 0) for k in range(1, i): dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]) for k in range(1, j): dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]) return dp[-1][-1]</description></item><item><title>2313. Minimum Flips in Binary Tree to Get Result</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2313/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2313/</guid><description>LeetCode problem 2313
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minimumFlips(self, root: Optional[TreeNode], result: bool) -&amp;gt; int: def dfs(root: Optional[TreeNode]) -&amp;gt; (int, int): if root is None: return inf, inf x = root.val if x in (0, 1): return x, x ^ 1 l, r = dfs(root.left), dfs(root.right) if x == 2: return l[0] + r[0], min(l[0] + r[1], l[1] + r[0], l[1] + r[1]) if x == 3: return min(l[0] + r[0], l[0] + r[1], l[1] + r[0]), l[1] + r[1] if x == 4: return min(l[0] + r[0], l[1] + r[1]), min(l[0] + r[1], l[1] + r[0]) return min(l[1], r[1]), min(l[0], r[0]) return dfs(root)[int(result)]</description></item><item><title>2315. Count Asterisks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2315/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2315/</guid><description>LeetCode problem 2315
class Solution: def countAsterisks(self, s: str) -&amp;gt; int: res, ok = 0, 1 for c in s: if c == &amp;#34;*&amp;#34;: res += ok elif c == &amp;#34;|&amp;#34;: ok ^= 1 return res</description></item><item><title>2316. Count Unreachable Pairs of Nodes in an Undirected Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2316/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2316/</guid><description>LeetCode problem 2316
class Solution: def countPairs(self, n: int, edges: List[List[int]]) -&amp;gt; int: def dfs(i: int) -&amp;gt; int: if vis[i]: return 0 vis[i] = True return 1 + sum(dfs(j) for j in g[i]) g = [[] for _ in range(n)] for a, b in edges: g[a].append(b) g[b].append(a) vis = [False] * n res = s = 0 for i in range(n): t = dfs(i) res += s * t s += t return res</description></item><item><title>2317. Maximum XOR After Operations</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2317/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2317/</guid><description>LeetCode problem 2317
class Solution: def maximumXOR(self, nums: List[int]) -&amp;gt; int: return reduce(or_, nums)</description></item><item><title>2318. Number of Distinct Roll Sequences</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2318/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2318/</guid><description>LeetCode problem 2318
class Solution: def distinctSequences(self, n: int) -&amp;gt; int: if n == 1: return 6 mod = 10**9 + 7 dp = [[[0] * 6 for _ in range(6)] for _ in range(n + 1)] for i in range(6): for j in range(6): if gcd(i + 1, j + 1) == 1 and i != j: dp[2][i][j] = 1 for k in range(3, n + 1): for i in range(6): for j in range(6): if gcd(i + 1, j + 1) == 1 and i !</description></item><item><title>2319. Check if Matrix Is X-Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2319/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2319/</guid><description>LeetCode problem 2319
class Solution: def checkXMatrix(self, grid: List[List[int]]) -&amp;gt; bool: for i, row in enumerate(grid): for j, v in enumerate(row): if i == j or i + j == len(grid) - 1: if v == 0: return False elif v: return False return True</description></item><item><title>2320. Count Number of Ways to Place Houses</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2320/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2320/</guid><description>LeetCode problem 2320
class Solution: def countHousePlacements(self, n: int) -&amp;gt; int: mod = 10**9 + 7 f = [1] * n g = [1] * n for i in range(1, n): f[i] = g[i - 1] g[i] = (f[i - 1] + g[i - 1]) % mod v = f[-1] + g[-1] return v * v % mod</description></item><item><title>2321. Maximum Score Of Spliced Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2321/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2321/</guid><description>LeetCode problem 2321
class Solution: def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: def f(nums1, nums2): d = [a - b for a, b in zip(nums1, nums2)] t = mx = d[0] for v in d[1:]: if t &amp;gt; 0: t += v else: t = v mx = max(mx, t) return mx s1, s2 = sum(nums1), sum(nums2) return max(s2 + f(nums1, nums2), s1 + f(nums2, nums1))</description></item><item><title>2322. Minimum Score After Removals on a Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2322/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2322/</guid><description>LeetCode problem 2322
class Solution: def minimumScore(self, nums: List[int], edges: List[List[int]]) -&amp;gt; int: def dfs(i, fa, x): res = nums[i] for j in g[i]: if j != fa and j != x: res ^= dfs(j, i, x) return res def dfs2(i, fa, x): nonlocal s, s1, res res = nums[i] for j in g[i]: if j != fa and j != x: a = dfs2(j, i, x) res ^= a b = s1 ^ a c = s ^ s1 t = max(a, b, c) - min(a, b, c) res = min(res, t) return res g = defaultdict(list) for a, b in edges: g[a].</description></item><item><title>2323. Find Minimum Time to Finish All Jobs II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2323/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2323/</guid><description>LeetCode problem 2323
class Solution: def minimumTime(self, jobs: List[int], workers: List[int]) -&amp;gt; int: jobs.sort() workers.sort() return max((a + b - 1) // b for a, b in zip(jobs, workers))</description></item><item><title>2325. Decode the Message</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2325/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2325/</guid><description>LeetCode problem 2325
class Solution: def decodeMessage(self, key: str, message: str) -&amp;gt; str: d = {&amp;#34; &amp;#34;: &amp;#34; &amp;#34;} i = 0 for c in key: if c not in d: d[c] = ascii_lowercase[i] i += 1 return &amp;#34;&amp;#34;.join(d[c] for c in message)</description></item><item><title>2326. Spiral Matrix IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2326/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2326/</guid><description>LeetCode problem 2326
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&amp;gt; List[List[int]]: res = [[-1] * n for _ in range(m)] i = j = p = 0 dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]] while 1: res[i][j] = head.val head = head.next if not head: break while 1: x, y = i + dirs[p][0], j + dirs[p][1] if x &amp;lt; 0 or y &amp;lt; 0 or x &amp;gt;= m or y &amp;gt;= n or ~res[x][y]: p = (p + 1) % 4 else: i, j = x, y break return res</description></item><item><title>2327. Number of People Aware of a Secret</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2327/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2327/</guid><description>LeetCode problem 2327
class Solution: def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -&amp;gt; int: m = (n &amp;lt;&amp;lt; 1) + 10 d = [0] * m cnt = [0] * m cnt[1] = 1 for i in range(1, n + 1): if cnt[i]: d[i] += cnt[i] d[i + forget] -= cnt[i] nxt = i + delay while nxt &amp;lt; i + forget: cnt[nxt] += cnt[i] nxt += 1 mod = 10**9 + 7 return sum(d[: n + 1]) % mod</description></item><item><title>2328. Number of Increasing Paths in a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2328/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2328/</guid><description>LeetCode problem 2328
class Solution: def countPaths(self, grid: List[List[int]]) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: res = 1 for a, b in pairwise((-1, 0, 1, 0, -1)): x, y = i + a, j + b if 0 &amp;lt;= x &amp;lt; m and 0 &amp;lt;= y &amp;lt; n and grid[i][j] &amp;lt; grid[x][y]: res = (res + dfs(x, y)) % mod return res mod = 10**9 + 7 m, n = len(grid), len(grid[0]) return sum(dfs(i, j) for i in range(m) for j in range(n)) % mod</description></item><item><title>2330. Valid Palindrome IV</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2330/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2330/</guid><description>LeetCode problem 2330
class Solution: def makePalindrome(self, s: str) -&amp;gt; bool: i, j = 0, len(s) - 1 cnt = 0 while i &amp;lt; j: cnt += s[i] != s[j] i, j = i + 1, j - 1 return cnt &amp;lt;= 2</description></item><item><title>2331. Evaluate Boolean Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2331/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2331/</guid><description>LeetCode problem 2331
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def evaluateTree(self, root: Optional[TreeNode]) -&amp;gt; bool: if root.left is None: return bool(root.val) l = self.evaluateTree(root.left) r = self.evaluateTree(root.right) return l or r if root.val == 2 else l and r</description></item><item><title>2332. The Latest Time to Catch a Bus</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2332/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2332/</guid><description>LeetCode problem 2332
class Solution: def latestTimeCatchTheBus( self, buses: List[int], passengers: List[int], capacity: int ) -&amp;gt; int: buses.sort() passengers.sort() j = 0 for t in buses: c = capacity while c and j &amp;lt; len(passengers) and passengers[j] &amp;lt;= t: c, j = c - 1, j + 1 j -= 1 res = buses[-1] if c else passengers[j] while ~j and passengers[j] == res: res, j = res - 1, j - 1 return res</description></item><item><title>2333. Minimum Sum of Squared Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2333/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2333/</guid><description>LeetCode problem 2333
class Solution: def minSumSquareDiff( self, nums1: List[int], nums2: List[int], k1: int, k2: int ) -&amp;gt; int: d = [abs(a - b) for a, b in zip(nums1, nums2)] k = k1 + k2 if sum(d) &amp;lt;= k: return 0 left, right = 0, max(d) while left &amp;lt; right: mid = (left + right) &amp;gt;&amp;gt; 1 if sum(max(v - mid, 0) for v in d) &amp;lt;= k: right = mid else: left = mid + 1 for i, v in enumerate(d): d[i] = min(left, v) k -= max(0, v - left) for i, v in enumerate(d): if k == 0: break if v == left: k -= 1 d[i] -= 1 return sum(v * v for v in d)</description></item><item><title>2334. Subarray With Elements Greater Than Varying Threshold</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2334/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2334/</guid><description>LeetCode problem 2334
class Solution: def validSubarraySize(self, nums: List[int], threshold: int) -&amp;gt; int: n = len(nums) left = [-1] * n right = [n] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) stk = [] for i in range(n - 1, -1, -1): while stk and nums[stk[-1]] &amp;gt;= nums[i]: stk.pop() if stk: right[i] = stk[-1] stk.append(i) for i, v in enumerate(nums): k = right[i] - left[i] - 1 if v &amp;gt; threshold // k: return k return -1</description></item><item><title>2335. Minimum Amount of Time to Fill Cups</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2335/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2335/</guid><description>LeetCode problem 2335
class Solution: def fillCups(self, amount: List[int]) -&amp;gt; int: amount.sort() if amount[0] + amount[1] &amp;lt;= amount[2]: return amount[2] return (sum(amount) + 1) // 2</description></item><item><title>2336. Smallest Number in Infinite Set</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2336/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2336/</guid><description>LeetCode problem 2336
from sortedcontainers import SortedSet class SmallestInfiniteSet: def __init__(self): self.s = SortedSet(range(1, 1001)) def popSmallest(self) -&amp;gt; int: x = self.s[0] self.s.remove(x) return x def addBack(self, num: int) -&amp;gt; None: self.s.add(num) # Your SmallestInfiniteSet object will be instantiated and called as such: # obj = SmallestInfiniteSet() # param_1 = obj.popSmallest() # obj.addBack(num)</description></item><item><title>2337. Move Pieces to Obtain a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2337/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2337/</guid><description>LeetCode problem 2337
class Solution: def canChange(self, start: str, target: str) -&amp;gt; bool: n = len(start) i = j = 0 while 1: while i &amp;lt; n and start[i] == &amp;#39;_&amp;#39;: i += 1 while j &amp;lt; n and target[j] == &amp;#39;_&amp;#39;: j += 1 if i &amp;gt;= n and j &amp;gt;= n: return True if i &amp;gt;= n or j &amp;gt;= n or start[i] != target[j]: return False if start[i] == &amp;#39;L&amp;#39; and i &amp;lt; j: return False if start[i] == &amp;#39;R&amp;#39; and i &amp;gt; j: return False i, j = i + 1, j + 1</description></item><item><title>2338. Count the Number of Ideal Arrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2338/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2338/</guid><description>LeetCode problem 2338
class Solution: def idealArrays(self, n: int, maxValue: int) -&amp;gt; int: c = [[0] * 16 for _ in range(n)] mod = 10**9 + 7 for i in range(n): for j in range(min(16, i + 1)): c[i][j] = 1 if j == 0 else (c[i - 1][j] + c[i - 1][j - 1]) % mod dp = [[0] * 16 for _ in range(maxValue + 1)] for i in range(1, maxValue + 1): dp[i][1] = 1 for j in range(1, 15): for i in range(1, maxValue + 1): k = 2 while k * i &amp;lt;= maxValue: dp[k * i][j + 1] = (dp[k * i][j + 1] + dp[i][j]) % mod k += 1 res = 0 for i in range(1, maxValue + 1): for j in range(1, 16): res = (res + dp[i][j] * c[-1][j - 1]) % mod return res</description></item><item><title>2340. Minimum Adjacent Swaps to Make a Valid Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2340/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2340/</guid><description>LeetCode problem 2340
class Solution: def minimumSwaps(self, nums: List[int]) -&amp;gt; int: i = j = 0 for k, v in enumerate(nums): if v &amp;lt; nums[i] or (v == nums[i] and k &amp;lt; i): i = k if v &amp;gt;= nums[j] or (v == nums[j] and k &amp;gt; j): j = k return 0 if i == j else i + len(nums) - 1 - j - (i &amp;gt; j)</description></item><item><title>2341. Maximum Number of Pairs in Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2341/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2341/</guid><description>LeetCode problem 2341
class Solution: def numberOfPairs(self, nums: List[int]) -&amp;gt; List[int]: cnt = Counter(nums) s = sum(v // 2 for v in cnt.values()) return [s, len(nums) - s * 2]</description></item><item><title>2342. Max Sum of a Pair With Equal Sum of Digits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2342/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2342/</guid><description>LeetCode problem 2342
class Solution: def maximumSum(self, nums: List[int]) -&amp;gt; int: d = defaultdict(int) res = -1 for v in nums: x, y = 0, v while y: x += y % 10 y //= 10 if x in d: res = max(res, d[x] + v) d[x] = max(d[x], v) return res</description></item><item><title>2343. Query Kth Smallest Trimmed Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2343/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2343/</guid><description>LeetCode problem 2343
class Solution: def smallestTrimmedNumbers( self, nums: List[str], queries: List[List[int]] ) -&amp;gt; List[int]: res = [] for k, trim in queries: t = sorted((v[-trim:], i) for i, v in enumerate(nums)) res.append(t[k - 1][1]) return res</description></item><item><title>2344. Minimum Deletions to Make Array Divisible</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2344/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2344/</guid><description>LeetCode problem 2344
class Solution: def minOperations(self, nums: List[int], numsDivide: List[int]) -&amp;gt; int: x = gcd(*numsDivide) y = min((v for v in nums if x % v == 0), default=0) return sum(v &amp;lt; y for v in nums) if y else -1</description></item><item><title>2345. Finding the Number of Visible Mountains</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2345/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2345/</guid><description>LeetCode problem 2345
class Solution: def visibleMountains(self, peaks: List[List[int]]) -&amp;gt; int: arr = [(x - y, x + y) for x, y in peaks] cnt = Counter(arr) arr.sort(key=lambda x: (x[0], -x[1])) res, cur = 0, -inf for l, r in arr: if r &amp;lt;= cur: continue cur = r if cnt[(l, r)] == 1: res += 1 return res</description></item><item><title>2347. Best Poker Hand</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2347/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2347/</guid><description>LeetCode problem 2347
class Solution: def bestHand(self, ranks: List[int], suits: List[str]) -&amp;gt; str: # if len(set(suits)) == 1: if all(a == b for a, b in pairwise(suits)): return &amp;#39;Flush&amp;#39; cnt = Counter(ranks) if any(v &amp;gt;= 3 for v in cnt.values()): return &amp;#39;Three of a Kind&amp;#39; if any(v == 2 for v in cnt.values()): return &amp;#39;Pair&amp;#39; return &amp;#39;High Card&amp;#39;</description></item><item><title>2348. Number of Zero-Filled Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2348/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2348/</guid><description>LeetCode problem 2348
class Solution: def zeroFilledSubarray(self, nums: List[int]) -&amp;gt; int: res = cnt = 0 for v in nums: cnt = 0 if v else cnt + 1 res += cnt return res</description></item><item><title>2349. Design a Number Container System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2349/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2349/</guid><description>LeetCode problem 2349
from sortedcontainers import SortedSet class NumberContainers: def __init__(self): self.mp = {} self.t = defaultdict(SortedSet) def change(self, index: int, number: int) -&amp;gt; None: if index in self.mp: v = self.mp[index] self.t[v].remove(index) self.mp[index] = number self.t[number].add(index) def find(self, number: int) -&amp;gt; int: s = self.t[number] return s[0] if s else -1 # Your NumberContainers object will be instantiated and called as such: # obj = NumberContainers() # obj.change(index,number) # param_2 = obj.find(number)</description></item><item><title>2350. Shortest Impossible Sequence of Rolls</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2350/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2350/</guid><description>LeetCode problem 2350
class Solution: def shortestSequence(self, rolls: List[int], k: int) -&amp;gt; int: res = 1 s = set() for v in rolls: s.add(v) if len(s) == k: res += 1 s.clear() return res</description></item><item><title>2351. First Letter to Appear Twice</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2351/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2351/</guid><description>LeetCode problem 2351
class Solution: def repeatedCharacter(self, s: str) -&amp;gt; str: mask = 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if mask &amp;gt;&amp;gt; i &amp;amp; 1: return c mask |= 1 &amp;lt;&amp;lt; i</description></item><item><title>2353. Design a Food Rating System</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2353/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2353/</guid><description>LeetCode problem 2353
from sortedcontainers import SortedSet class FoodRatings: def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]): self.mp = {} self.t = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1]))) for a, b, c in zip(foods, cuisines, ratings): self.mp[a] = (b, c) self.t[b].add((c, a)) def changeRating(self, food: str, newRating: int) -&amp;gt; None: b, c = self.mp[food] self.mp[food] = (b, newRating) self.t[b].remove((c, food)) self.t[b].add((newRating, food)) def highestRated(self, cuisine: str) -&amp;gt; str: return self.t[cuisine][0][1] # Your FoodRatings object will be instantiated and called as such: # obj = FoodRatings(foods, cuisines, ratings) # obj.</description></item><item><title>2354. Number of Excellent Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2354/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2354/</guid><description>LeetCode problem 2354
class Solution: def countExcellentPairs(self, nums: List[int], k: int) -&amp;gt; int: s = set(nums) res = 0 cnt = Counter() for v in s: cnt[v.bit_count()] += 1 for v in s: t = v.bit_count() for i, x in cnt.items(): if t + i &amp;gt;= k: res += x return res</description></item><item><title>2355. Maximum Number of Books You Can Take</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2355/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2355/</guid><description>LeetCode problem 2355
class Solution: def maximumBooks(self, books: List[int]) -&amp;gt; int: nums = [v - i for i, v in enumerate(books)] n = len(nums) left = [-1] * n stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &amp;gt;= v: stk.pop() if stk: left[i] = stk[-1] stk.append(i) res = 0 dp = [0] * n dp[0] = books[0] for i, v in enumerate(books): j = left[i] cnt = min(v, i - j) u = v - cnt + 1 s = (u + v) * cnt // 2 dp[i] = s + (0 if j == -1 else dp[j]) res = max(res, dp[i]) return res</description></item><item><title>2357. Make Array Zero by Subtracting Equal Amounts</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2357/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2357/</guid><description>LeetCode problem 2357
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: return len({x for x in nums if x})</description></item><item><title>2358. Maximum Number of Groups Entering a Competition</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2358/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2358/</guid><description>LeetCode problem 2358
class Solution: def maximumGroups(self, grades: List[int]) -&amp;gt; int: n = len(grades) return bisect_right(range(n + 1), n * 2, key=lambda x: x * x + x) - 1</description></item><item><title>2359. Find Closest Node to Given Two Nodes</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2359/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2359/</guid><description>LeetCode problem 2359
class Solution: def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -&amp;gt; int: def f(i): dist = [inf] * n dist[i] = 0 q = deque([i]) while q: i = q.popleft() for j in g[i]: if dist[j] == inf: dist[j] = dist[i] + 1 q.append(j) return dist g = defaultdict(list) for i, j in enumerate(edges): if j != -1: g[i].append(j) n = len(edges) d1 = f(node1) d2 = f(node2) res, d = -1, inf for i, (a, b) in enumerate(zip(d1, d2)): if (t := max(a, b)) &amp;lt; d: d = t res = i return res</description></item><item><title>2360. Longest Cycle in a Graph</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2360/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2360/</guid><description>LeetCode problem 2360
class Solution: def longestCycle(self, edges: List[int]) -&amp;gt; int: n = len(edges) vis = [False] * n res = -1 for i in range(n): if vis[i]: continue j = i cycle = [] while j != -1 and not vis[j]: vis[j] = True cycle.append(j) j = edges[j] if j == -1: continue m = len(cycle) k = next((k for k in range(m) if cycle[k] == j), inf) res = max(res, m - k) return res</description></item><item><title>2361. Minimum Costs Using the Train Line</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2361/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2361/</guid><description>LeetCode problem 2361
class Solution: def minimumCosts( self, regular: List[int], express: List[int], expressCost: int ) -&amp;gt; List[int]: n = len(regular) f, g = 0, inf cost = [0] * n for i, (a, b) in enumerate(zip(regular, express), 1): ff = min(f + a, g + a) gg = min(f + expressCost + b, g + b) f, g = ff, gg cost[i - 1] = min(f, g) return cost</description></item><item><title>2363. Merge Similar Items</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2363/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2363/</guid><description>LeetCode problem 2363
class Solution: def mergeSimilarItems( self, items1: List[List[int]], items2: List[List[int]] ) -&amp;gt; List[List[int]]: cnt = Counter() for v, w in chain(items1, items2): cnt[v] += w return sorted(cnt.items())</description></item><item><title>2364. Count Number of Bad Pairs</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2364/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2364/</guid><description>LeetCode problem 2364
class Solution: def countBadPairs(self, nums: List[int]) -&amp;gt; int: cnt = Counter() res = 0 for i, x in enumerate(nums): res += i - cnt[i - x] cnt[i - x] += 1 return res</description></item><item><title>2365. Task Scheduler II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2365/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2365/</guid><description>LeetCode problem 2365
class Solution: def taskSchedulerII(self, tasks: List[int], space: int) -&amp;gt; int: day = defaultdict(int) res = 0 for task in tasks: res += 1 res = max(res, day[task]) day[task] = res + space + 1 return res</description></item><item><title>2366. Minimum Replacements to Sort the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2366/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2366/</guid><description>LeetCode problem 2366
class Solution: def minimumReplacement(self, nums: List[int]) -&amp;gt; int: res = 0 n = len(nums) mx = nums[-1] for i in range(n - 2, -1, -1): if nums[i] &amp;lt;= mx: mx = nums[i] continue k = (nums[i] + mx - 1) // mx res += k - 1 mx = nums[i] // k return res</description></item><item><title>2367. Number of Arithmetic Triplets</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2367/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2367/</guid><description>LeetCode problem 2367
class Solution: def arithmeticTriplets(self, nums: List[int], diff: int) -&amp;gt; int: vis = set(nums) return sum(x + diff in vis and x + diff * 2 in vis for x in nums)</description></item><item><title>2368. Reachable Nodes With Restrictions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2368/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2368/</guid><description>LeetCode problem 2368
class Solution: def reachableNodes( self, n: int, edges: List[List[int]], restricted: List[int] ) -&amp;gt; int: s = set(restricted) g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) q = deque([0]) vis = [False] * n for v in restricted: vis[v] = True res = 0 while q: i = q.popleft() res += 1 vis[i] = True for j in g[i]: if not vis[j]: q.append(j) return res</description></item><item><title>2369. Check if There is a Valid Partition For The Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2369/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2369/</guid><description>LeetCode problem 2369
class Solution: def validPartition(self, nums: List[int]) -&amp;gt; bool: n = len(nums) dp = [False] * (n + 1) dp[0] = True for i in range(2, n + 1): if nums[i - 1] == nums[i - 2]: dp[i] = dp[i] or dp[i - 2] if i &amp;gt; 2 and nums[i - 1] == nums[i - 2] == nums[i - 3]: dp[i] = dp[i] or dp[i - 3] if ( i &amp;gt; 2 and nums[i - 1] - nums[i - 2] == 1 and nums[i - 2] - nums[i - 3] == 1 ): dp[i] = dp[i] or dp[i - 3] return dp[-1]</description></item><item><title>2370. Longest Ideal Subsequence</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2370/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2370/</guid><description>LeetCode problem 2370
class Solution: def longestIdealString(self, s: str, k: int) -&amp;gt; int: n = len(s) res = 1 dp = [1] * n d = {s[0]: 0} for i in range(1, n): a = ord(s[i]) for b in ascii_lowercase: if abs(a - ord(b)) &amp;gt; k: continue if b in d: dp[i] = max(dp[i], dp[d[b]] + 1) d[s[i]] = i return max(dp)</description></item><item><title>2371. Minimize Maximum Value in a Grid</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2371/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2371/</guid><description>LeetCode problem 2371
class Solution: def minScore(self, grid: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(grid), len(grid[0]) nums = [(v, i, j) for i, row in enumerate(grid) for j, v in enumerate(row)] nums.sort() row_max = [0] * m col_max = [0] * n res = [[0] * n for _ in range(m)] for _, i, j in nums: res[i][j] = max(row_max[i], col_max[j]) + 1 row_max[i] = col_max[j] = res[i][j] return res</description></item><item><title>2373. Largest Local Values in a Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2373/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2373/</guid><description>LeetCode problem 2373
class Solution: def largestLocal(self, grid: List[List[int]]) -&amp;gt; List[List[int]]: n = len(grid) res = [[0] * (n - 2) for _ in range(n - 2)] for i in range(n - 2): for j in range(n - 2): res[i][j] = max( grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3) ) return res</description></item><item><title>2374. Node With Highest Edge Score</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2374/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2374/</guid><description>LeetCode problem 2374
class Solution: def edgeScore(self, edges: List[int]) -&amp;gt; int: cnt = Counter() for i, v in enumerate(edges): cnt[v] += i res = 0 for i in range(len(edges)): if cnt[res] &amp;lt; cnt[i]: res = i return res</description></item><item><title>2375. Construct Smallest Number From DI String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2375/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2375/</guid><description>LeetCode problem 2375
class Solution: def smallestNumber(self, pattern: str) -&amp;gt; str: def dfs(u): nonlocal res if res: return if u == len(pattern) + 1: res = &amp;#39;&amp;#39;.join(t) return for i in range(1, 10): if not vis[i]: if u and pattern[u - 1] == &amp;#39;I&amp;#39; and int(t[-1]) &amp;gt;= i: continue if u and pattern[u - 1] == &amp;#39;D&amp;#39; and int(t[-1]) &amp;lt;= i: continue vis[i] = True t.append(str(i)) dfs(u + 1) vis[i] = False t.pop() vis = [False] * 10 t = [] res = None dfs(0) return res</description></item><item><title>2376. Count Special Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2376/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2376/</guid><description>LeetCode problem 2376
class Solution: def countSpecialNumbers(self, n: int) -&amp;gt; int: return self.f(n) def f(self, n): @cache def dfs(pos, mask, lead, limit): if pos &amp;lt;= 0: return lead ^ 1 up = a[pos] if limit else 9 res = 0 for i in range(up + 1): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: continue if i == 0 and lead: res += dfs(pos - 1, mask, lead, limit and i == up) else: res += dfs(pos - 1, mask | 1 &amp;lt;&amp;lt; i, False, limit and i == up) return res a = [0] * 11 l = 0 while n: l += 1 a[l] = n % 10 n //= 10 return dfs(l, 0, True, True)</description></item><item><title>2378. Choose Edges to Maximize Score in a Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2378/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2378/</guid><description>LeetCode problem 2378
class Solution: def maxScore(self, edges: List[List[int]]) -&amp;gt; int: def dfs(i): a = b = t = 0 for j, w in g[i]: x, y = dfs(j) a += y b += y t = max(t, x - y + w) b += t return a, b g = defaultdict(list) for i, (p, w) in enumerate(edges[1:], 1): g[p].append((i, w)) return dfs(0)[1]</description></item><item><title>2379. Minimum Recolors to Get K Consecutive Black Blocks</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2379/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2379/</guid><description>LeetCode problem 2379
class Solution: def minimumRecolors(self, blocks: str, k: int) -&amp;gt; int: res = cnt = blocks[:k].count(&amp;#39;W&amp;#39;) for i in range(k, len(blocks)): cnt += blocks[i] == &amp;#39;W&amp;#39; cnt -= blocks[i - k] == &amp;#39;W&amp;#39; res = min(res, cnt) return res</description></item><item><title>2380. Time Needed to Rearrange a Binary String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2380/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2380/</guid><description>LeetCode problem 2380
class Solution: def secondsToRemoveOccurrences(self, s: str) -&amp;gt; int: res = cnt = 0 for c in s: if c == &amp;#39;0&amp;#39;: cnt += 1 elif cnt: res = max(res + 1, cnt) return res</description></item><item><title>2381. Shifting Letters II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2381/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2381/</guid><description>LeetCode problem 2381
class Solution: def shiftingLetters(self, s: str, shifts: List[List[int]]) -&amp;gt; str: n = len(s) d = [0] * (n + 1) for i, j, v in shifts: if v == 0: v = -1 d[i] += v d[j + 1] -= v for i in range(1, n + 1): d[i] += d[i - 1] return &amp;#39;&amp;#39;.join( chr(ord(&amp;#39;a&amp;#39;) + (ord(s[i]) - ord(&amp;#39;a&amp;#39;) + d[i] + 26) % 26) for i in range(n) )</description></item><item><title>2382. Maximum Segment Sum After Removals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2382/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2382/</guid><description>LeetCode problem 2382
class Solution: def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -&amp;gt; List[int]: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def merge(a, b): pa, pb = find(a), find(b) p[pa] = pb s[pb] += s[pa] n = len(nums) p = list(range(n)) s = [0] * n res = [0] * n mx = 0 for j in range(n - 1, 0, -1): i = removeQueries[j] s[i] = nums[i] if i and s[find(i - 1)]: merge(i, i - 1) if i &amp;lt; n - 1 and s[find(i + 1)]: merge(i, i + 1) mx = max(mx, s[find(i)]) res[j - 1] = mx return res</description></item><item><title>2383. Minimum Hours of Training to Win a Competition</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2383/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2383/</guid><description>LeetCode problem 2383
class Solution: def minNumberOfHours( self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int], ) -&amp;gt; int: res = max(0, sum(energy) - initialEnergy + 1) for x in experience: if initialExperience &amp;lt;= x: res += x - initialExperience + 1 initialExperience = x + 1 initialExperience += x return res</description></item><item><title>2384. Largest Palindromic Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2384/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2384/</guid><description>LeetCode problem 2384
class Solution: def largestPalindromic(self, num: str) -&amp;gt; str: cnt = Counter(num) res = &amp;#39;&amp;#39; for i in range(9, -1, -1): v = str(i) if cnt[v] % 2: res = v cnt[v] -= 1 break for i in range(10): v = str(i) if cnt[v]: cnt[v] //= 2 s = cnt[v] * v res = s + res + s return res.strip(&amp;#39;0&amp;#39;) or &amp;#39;0&amp;#39;</description></item><item><title>2385. Amount of Time for Binary Tree to Be Infected</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2385/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2385/</guid><description>LeetCode problem 2385
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def amountOfTime(self, root: Optional[TreeNode], start: int) -&amp;gt; int: def dfs(root): if root is None: return if root.left: g[root.val].append(root.left.val) g[root.left.val].append(root.val) if root.right: g[root.val].append(root.right.val) g[root.right.val].append(root.val) dfs(root.left) dfs(root.right) def dfs2(i, fa): res = 0 for j in g[i]: if j != fa: res = max(res, 1 + dfs2(j, i)) return res g = defaultdict(list) dfs(root) return dfs2(start, -1)</description></item><item><title>2386. Find the K-Sum of an Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2386/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2386/</guid><description>LeetCode problem 2386
class Solution: def kSum(self, nums: List[int], k: int) -&amp;gt; int: mx = 0 for i, v in enumerate(nums): if v &amp;gt; 0: mx += v else: nums[i] = -v nums.sort() h = [(0, 0)] for _ in range(k - 1): s, i = heappop(h) if i &amp;lt; len(nums): heappush(h, (s + nums[i], i + 1)) if i: heappush(h, (s + nums[i] - nums[i - 1], i + 1)) return mx - h[0][0]</description></item><item><title>2387. Median of a Row Wise Sorted Matrix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2387/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2387/</guid><description>LeetCode problem 2387
class Solution: def matrixMedian(self, grid: List[List[int]]) -&amp;gt; int: def count(x): return sum(bisect_right(row, x) for row in grid) m, n = len(grid), len(grid[0]) target = (m * n + 1) &amp;gt;&amp;gt; 1 return bisect_left(range(10**6 + 1), target, key=count)</description></item><item><title>2389. Longest Subsequence With Limited Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2389/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2389/</guid><description>LeetCode problem 2389
class Solution: def answerQueries(self, nums: List[int], queries: List[int]) -&amp;gt; List[int]: nums.sort() m = len(queries) res = [0] * m idx = sorted(range(m), key=lambda i: queries[i]) s = j = 0 for i in idx: while j &amp;lt; len(nums) and s + nums[j] &amp;lt;= queries[i]: s += nums[j] j += 1 res[i] = j return res</description></item><item><title>2390. Removing Stars From a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2390/</guid><description>LeetCode problem
Problem Statement You are provided with a string s that contains asterisks or stars (*). Your task is to transform this string. In each operation, you&amp;rsquo;ll select a star and remove the character immediately to its left and the star itself. Continue this process until there are no stars left in the string.
The challenge guarantees that the input string can always be transformed as per the given operation, and the result will always be unique.</description></item><item><title>2391. Minimum Amount of Time to Collect Garbage</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2391/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2391/</guid><description>LeetCode problem 2391
class Solution: def garbageCollection(self, garbage: List[str], travel: List[int]) -&amp;gt; int: def f(x: str) -&amp;gt; int: res = 0 st = 0 for i, s in enumerate(garbage): if t := s.count(x): res += t + st st = 0 if i &amp;lt; len(travel): st += travel[i] return res return f(&amp;#39;M&amp;#39;) + f(&amp;#39;P&amp;#39;) + f(&amp;#39;G&amp;#39;)</description></item><item><title>2392. Build a Matrix With Conditions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2392/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2392/</guid><description>LeetCode problem 2392
class Solution: def buildMatrix( self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]] ) -&amp;gt; List[List[int]]: def f(cond): g = defaultdict(list) indeg = [0] * (k + 1) for a, b in cond: g[a].append(b) indeg[b] += 1 q = deque([i for i, v in enumerate(indeg[1:], 1) if v == 0]) res = [] while q: for _ in range(len(q)): i = q.popleft() res.append(i) for j in g[i]: indeg[j] -= 1 if indeg[j] == 0: q.append(j) return None if len(res) !</description></item><item><title>2393. Count Strictly Increasing Subarrays</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2393/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2393/</guid><description>LeetCode problem 2393
class Solution: def countSubarrays(self, nums: List[int]) -&amp;gt; int: res = pre = cnt = 0 for x in nums: if pre &amp;lt; x: cnt += 1 else: cnt = 1 pre = x res += cnt return res</description></item><item><title>2395. Find Subarrays With Equal Sum</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2395/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2395/</guid><description>LeetCode problem 2395
class Solution: def findSubarrays(self, nums: List[int]) -&amp;gt; bool: vis = set() for a, b in pairwise(nums): if (x := a + b) in vis: return True vis.add(x) return False</description></item><item><title>2396. Strictly Palindromic Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2396/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2396/</guid><description>LeetCode problem 2396
class Solution: def isStrictlyPalindromic(self, n: int) -&amp;gt; bool: return False</description></item><item><title>2397. Maximum Rows Covered by Columns</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2397/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2397/</guid><description>LeetCode problem 2397
class Solution: def maximumRows(self, matrix: List[List[int]], numSelect: int) -&amp;gt; int: rows = [] for row in matrix: mask = reduce(or_, (1 &amp;lt;&amp;lt; j for j, x in enumerate(row) if x), 0) rows.append(mask) res = 0 for mask in range(1 &amp;lt;&amp;lt; len(matrix[0])): if mask.bit_count() != numSelect: continue t = sum((x &amp;amp; mask) == x for x in rows) res = max(res, t) return res</description></item><item><title>2398. Maximum Number of Robots Within Budget</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2398/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2398/</guid><description>LeetCode problem 2398
class Solution: def maximumRobots( self, chargeTimes: List[int], runningCosts: List[int], budget: int ) -&amp;gt; int: q = deque() res = j = s = 0 for i, (a, b) in enumerate(zip(chargeTimes, runningCosts)): while q and chargeTimes[q[-1]] &amp;lt;= a: q.pop() q.append(i) s += b while q and chargeTimes[q[0]] + (i - j + 1) * s &amp;gt; budget: if q[0] == j: q.popleft() s -= runningCosts[j] j += 1 res = max(res, i - j + 1) return res</description></item><item><title>2399. Check Distances Between Same Letters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2399/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2399/</guid><description>LeetCode problem 2399
class Solution: def checkDistances(self, s: str, distance: List[int]) -&amp;gt; bool: d = defaultdict(int) for i, c in enumerate(s, 1): if d[c] and i - d[c] - 1 != distance[ord(c) - ord(&amp;#39;a&amp;#39;)]: return False d[c] = i return True</description></item><item><title>2400. Number of Ways to Reach a Position After Exactly k Steps</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2400/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2400/</guid><description>LeetCode problem 2400
class Solution: def numberOfWays(self, startPos: int, endPos: int, k: int) -&amp;gt; int: @cache def dfs(i: int, j: int) -&amp;gt; int: if i &amp;gt; j or j &amp;lt; 0: return 0 if j == 0: return 1 if i == 0 else 0 return (dfs(i + 1, j - 1) + dfs(abs(i - 1), j - 1)) % mod mod = 10**9 + 7 return dfs(abs(startPos - endPos), k)</description></item><item><title>2401. Longest Nice Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2401/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2401/</guid><description>LeetCode problem 2401
class Solution: def longestNiceSubarray(self, nums: List[int]) -&amp;gt; int: res = j = mask = 0 for i, x in enumerate(nums): while mask &amp;amp; x: mask ^= nums[j] j += 1 res = max(res, i - j + 1) mask |= x return res</description></item><item><title>2403. Minimum Time to Kill All Monsters</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2403/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2403/</guid><description>LeetCode problem 2403
class Solution: def minimumTime(self, power: List[int]) -&amp;gt; int: n = len(power) dp = [inf] * (1 &amp;lt;&amp;lt; n) dp[0] = 0 for mask in range(1, 1 &amp;lt;&amp;lt; n): cnt = mask.bit_count() for i, v in enumerate(power): if (mask &amp;gt;&amp;gt; i) &amp;amp; 1: dp[mask] = min(dp[mask], dp[mask ^ (1 &amp;lt;&amp;lt; i)] + (v + cnt - 1) // cnt) return dp[-1]</description></item><item><title>2404. Most Frequent Even Element</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2404/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2404/</guid><description>LeetCode problem 2404
class Solution: def mostFrequentEven(self, nums: List[int]) -&amp;gt; int: cnt = Counter(x for x in nums if x % 2 == 0) res, mx = -1, 0 for x, v in cnt.items(): if v &amp;gt; mx or (v == mx and res &amp;gt; x): res, mx = x, v return res</description></item><item><title>2405. Optimal Partition of String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2405/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2405/</guid><description>LeetCode problem 2405
class Solution: def partitionString(self, s: str) -&amp;gt; int: res, v = 1, 0 for c in s: i = ord(c) - ord(&amp;#39;a&amp;#39;) if (v &amp;gt;&amp;gt; i) &amp;amp; 1: v = 0 res += 1 v |= 1 &amp;lt;&amp;lt; i return res</description></item><item><title>2406. Divide Intervals Into Minimum Number of Groups</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2406/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2406/</guid><description>LeetCode problem 2406
class Solution: def minGroups(self, intervals: List[List[int]]) -&amp;gt; int: h = [] for a, b in sorted(intervals): if h and h[0] &amp;lt; a: heappop(h) heappush(h, b) return len(h)</description></item><item><title>2407. Longest Increasing Subsequence II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2407/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2407/</guid><description>LeetCode problem 2407
class Node: def __init__(self): self.l = 0 self.r = 0 self.v = 0 class SegmentTree: def __init__(self, n): self.tr = [Node() for _ in range(4 * n)] self.build(1, 1, n) def build(self, u, l, r): self.tr[u].l = l self.tr[u].r = r if l == r: return mid = (l + r) &amp;gt;&amp;gt; 1 self.build(u &amp;lt;&amp;lt; 1, l, mid) self.build(u &amp;lt;&amp;lt; 1 | 1, mid + 1, r) def modify(self, u, x, v): if self.tr[u].l == x and self.</description></item><item><title>2408. Design SQL</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2408/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2408/</guid><description>LeetCode problem 2408
class SQL: def __init__(self, names: List[str], columns: List[int]): self.tables = defaultdict(list) def insertRow(self, name: str, row: List[str]) -&amp;gt; None: self.tables[name].append(row) def deleteRow(self, name: str, rowId: int) -&amp;gt; None: pass def selectCell(self, name: str, rowId: int, columnId: int) -&amp;gt; str: return self.tables[name][rowId - 1][columnId - 1] # Your SQL object will be instantiated and called as such: # obj = SQL(names, columns) # obj.insertRow(name,row) # obj.deleteRow(name,rowId) # param_3 = obj.selectCell(name,rowId,columnId)</description></item><item><title>2409. Count Days Spent Together</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2409/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2409/</guid><description>LeetCode problem 2409
class Solution: def countDaysTogether( self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str ) -&amp;gt; int: a = max(arriveAlice, arriveBob) b = min(leaveAlice, leaveBob) days = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) x = sum(days[: int(a[:2]) - 1]) + int(a[3:]) y = sum(days[: int(b[:2]) - 1]) + int(b[3:]) return max(y - x + 1, 0)</description></item><item><title>2410. Maximum Matching of Players With Trainers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2410/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2410/</guid><description>LeetCode problem 2410
class Solution: def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -&amp;gt; int: players.sort() trainers.sort() res = j = 0 for p in players: while j &amp;lt; len(trainers) and trainers[j] &amp;lt; p: j += 1 if j &amp;lt; len(trainers): res += 1 j += 1 return res</description></item><item><title>2411. Smallest Subarrays With Maximum Bitwise OR</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2411/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2411/</guid><description>LeetCode problem 2411
class Solution: def smallestSubarrays(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n f = [-1] * 32 for i in range(n - 1, -1, -1): t = 1 for j in range(32): if (nums[i] &amp;gt;&amp;gt; j) &amp;amp; 1: f[j] = i elif f[j] != -1: t = max(t, f[j] - i + 1) res[i] = t return res</description></item><item><title>2412. Minimum Money Required Before Transactions</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2412/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2412/</guid><description>LeetCode problem 2412
class Solution: def minimumMoney(self, transactions: List[List[int]]) -&amp;gt; int: s = sum(max(0, a - b) for a, b in transactions) res = 0 for a, b in transactions: if a &amp;gt; b: res = max(res, s + b) else: res = max(res, s + a) return res</description></item><item><title>2413. Smallest Even Multiple</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2413/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2413/</guid><description>LeetCode problem 2413
class Solution: def smallestEvenMultiple(self, n: int) -&amp;gt; int: return n if n % 2 == 0 else n * 2</description></item><item><title>2414. Length of the Longest Alphabetical Continuous Substring</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2414/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2414/</guid><description>LeetCode problem 2414
class Solution: def longestContinuousSubstring(self, s: str) -&amp;gt; int: res = 0 i, j = 0, 1 while j &amp;lt; len(s): res = max(res, j - i) if ord(s[j]) - ord(s[j - 1]) != 1: i = j j += 1 res = max(res, j - i) return res</description></item><item><title>2415. Reverse Odd Levels of Binary Tree</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2415/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2415/</guid><description>LeetCode problem 2415
# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def reverseOddLevels(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: q = deque([root]) i = 0 while q: if i &amp;amp; 1: l, r = 0, len(q) - 1 while l &amp;lt; r: q[l].val, q[r].val = q[r].val, q[l].val l, r = l + 1, r - 1 for _ in range(len(q)): node = q.</description></item><item><title>2416. Sum of Prefix Scores of Strings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2416/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2416/</guid><description>LeetCode problem 2416
class Trie: def __init__(self): self.children = [None] * 26 self.cnt = 0 def insert(self, w): node = self for c in w: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: node.children[idx] = Trie() node = node.children[idx] node.cnt += 1 def search(self, w): node = self res = 0 for c in w: idx = ord(c) - ord(&amp;#39;a&amp;#39;) if node.children[idx] is None: return res node = node.children[idx] res += node.cnt return res class Solution: def sumPrefixScores(self, words: List[str]) -&amp;gt; List[int]: trie = Trie() for w in words: trie.</description></item><item><title>2417. Closest Fair Integer</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2417/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2417/</guid><description>LeetCode problem 2417
class Solution: def closestFair(self, n: int) -&amp;gt; int: a = b = k = 0 t = n while t: if (t % 10) &amp;amp; 1: a += 1 else: b += 1 t //= 10 k += 1 if k &amp;amp; 1: x = 10**k y = int(&amp;#39;1&amp;#39; * (k &amp;gt;&amp;gt; 1) or &amp;#39;0&amp;#39;) return x + y if a == b: return n return self.closestFair(n + 1)</description></item><item><title>2418. Sort the People</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2418/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2418/</guid><description>LeetCode problem 2418
class Solution: def sortPeople(self, names: List[str], heights: List[int]) -&amp;gt; List[str]: return [name for _, name in sorted(zip(heights, names), reverse=True)]</description></item><item><title>2419. Longest Subarray With Maximum Bitwise AND</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2419/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2419/</guid><description>LeetCode problem 2419
class Solution: def longestSubarray(self, nums: List[int]) -&amp;gt; int: mx = max(nums) res = cnt = 0 for v in nums: if v == mx: cnt += 1 res = max(res, cnt) else: cnt = 0 return res</description></item><item><title>2420. Find All Good Indices</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2420/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2420/</guid><description>LeetCode problem 2420
class Solution: def goodIndices(self, nums: List[int], k: int) -&amp;gt; List[int]: n = len(nums) decr = [1] * (n + 1) incr = [1] * (n + 1) for i in range(2, n - 1): if nums[i - 1] &amp;lt;= nums[i - 2]: decr[i] = decr[i - 1] + 1 for i in range(n - 3, -1, -1): if nums[i + 1] &amp;lt;= nums[i + 2]: incr[i] = incr[i + 1] + 1 return [i for i in range(k, n - k) if decr[i] &amp;gt;= k and incr[i] &amp;gt;= k]</description></item><item><title>2421. Number of Good Paths</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2421/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2421/</guid><description>LeetCode problem 2421
class Solution: def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -&amp;gt; int: def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] g = defaultdict(list) for a, b in edges: g[a].append(b) g[b].append(a) n = len(vals) p = list(range(n)) size = defaultdict(Counter) for i, v in enumerate(vals): size[i][v] = 1 res = n for v, a in sorted(zip(vals, range(n))): for b in g[a]: if vals[b] &amp;gt; v: continue pa, pb = find(a), find(b) if pa != pb: res += size[pa][v] * size[pb][v] p[pa] = pb size[pb][v] += size[pa][v] return res</description></item><item><title>2422. Merge Operations to Turn Array Into a Palindrome</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2422/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2422/</guid><description>LeetCode problem 2422
class Solution: def minimumOperations(self, nums: List[int]) -&amp;gt; int: i, j = 0, len(nums) - 1 a, b = nums[i], nums[j] res = 0 while i &amp;lt; j: if a &amp;lt; b: i += 1 a += nums[i] res += 1 elif b &amp;lt; a: j -= 1 b += nums[j] res += 1 else: i, j = i + 1, j - 1 a, b = nums[i], nums[j] return res</description></item><item><title>2423. Remove Letter To Equalize Frequency</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2423/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2423/</guid><description>LeetCode problem 2423
class Solution: def equalFrequency(self, word: str) -&amp;gt; bool: cnt = Counter(word) for c in cnt.keys(): cnt[c] -= 1 if len(set(v for v in cnt.values() if v)) == 1: return True cnt[c] += 1 return False</description></item><item><title>2424. Longest Uploaded Prefix</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2424/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2424/</guid><description>LeetCode problem 2424
class LUPrefix: def __init__(self, n: int): self.r = 0 self.s = set() def upload(self, video: int) -&amp;gt; None: self.s.add(video) while self.r + 1 in self.s: self.r += 1 def longest(self) -&amp;gt; int: return self.r # Your LUPrefix object will be instantiated and called as such: # obj = LUPrefix(n) # obj.upload(video) # param_2 = obj.longest()</description></item><item><title>2425. Bitwise XOR of All Pairings</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2425/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2425/</guid><description>LeetCode problem 2425
class Solution: def xorAllNums(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: res = 0 if len(nums2) &amp;amp; 1: for v in nums1: res ^= v if len(nums1) &amp;amp; 1: for v in nums2: res ^= v return res</description></item><item><title>2426. Number of Pairs Satisfying Inequality</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2426/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2426/</guid><description>LeetCode problem 2426
class BinaryIndexedTree: def __init__(self, n): self.n = n self.c = [0] * (n + 1) @staticmethod def lowbit(x): return x &amp;amp; -x def update(self, x, delta): while x &amp;lt;= self.n: self.c[x] += delta x += BinaryIndexedTree.lowbit(x) def query(self, x): s = 0 while x: s += self.c[x] x -= BinaryIndexedTree.lowbit(x) return s class Solution: def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -&amp;gt; int: tree = BinaryIndexedTree(10**5) res = 0 for a, b in zip(nums1, nums2): v = a - b res += tree.</description></item><item><title>2427. Number of Common Factors</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2427/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2427/</guid><description>LeetCode problem 2427
class Solution: def commonFactors(self, a: int, b: int) -&amp;gt; int: g = gcd(a, b) res, x = 0, 1 while x * x &amp;lt;= g: if g % x == 0: res += 1 res += x * x &amp;lt; g x += 1 return res</description></item><item><title>2428. Maximum Sum of an Hourglass</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2428/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2428/</guid><description>LeetCode problem 2428
class Solution: def maxSum(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) res = 0 for i in range(1, m - 1): for j in range(1, n - 1): s = -grid[i][j - 1] - grid[i][j + 1] s += sum( grid[x][y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) ) res = max(res, s) return res</description></item><item><title>2429. Minimize XOR</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2429/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2429/</guid><description>LeetCode problem 2429
class Solution: def minimizeXor(self, num1: int, num2: int) -&amp;gt; int: cnt1 = num1.bit_count() cnt2 = num2.bit_count() while cnt1 &amp;gt; cnt2: num1 &amp;amp;= num1 - 1 cnt1 -= 1 while cnt1 &amp;lt; cnt2: num1 |= num1 + 1 cnt1 += 1 return num1</description></item><item><title>2430. Maximum Deletions on a String</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2430/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2430/</guid><description>LeetCode problem 2430
class Solution: def deleteString(self, s: str) -&amp;gt; int: n = len(s) g = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n - 1, -1, -1): for j in range(i + 1, n): if s[i] == s[j]: g[i][j] = g[i + 1][j + 1] + 1 f = [1] * n for i in range(n - 1, -1, -1): for j in range(1, (n - i) // 2 + 1): if g[i][i + j] &amp;gt;= j: f[i] = max(f[i], f[i + j] + 1) return f[0]</description></item><item><title>2431. Maximize Total Tastiness of Purchased Fruits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2431/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2431/</guid><description>LeetCode problem 2431
class Solution: def maxTastiness( self, price: List[int], tastiness: List[int], maxAmount: int, maxCoupons: int ) -&amp;gt; int: @cache def dfs(i, j, k): if i == len(price): return 0 res = dfs(i + 1, j, k) if j &amp;gt;= price[i]: res = max(res, dfs(i + 1, j - price[i], k) + tastiness[i]) if j &amp;gt;= price[i] // 2 and k: res = max(res, dfs(i + 1, j - price[i] // 2, k - 1) + tastiness[i]) return res return dfs(0, maxAmount, maxCoupons)</description></item><item><title>2540. Minimum Common Value</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2540/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2540/</guid><description>LeetCode problem 2540
By initializing two pointers, one for each array, we can compare the elements they point to. If the elements are equal, we&amp;rsquo;ve found a common value. If not, we move the pointer pointing to the smaller value forward. This approach ensures that we only traverse each array once.
class Solution: def getCommon(self, nums1: List[int], nums2: List[int]) -&amp;gt; int: i = 0 j = 0 N1 = len(nums1) N2 = len(nums2) while i &amp;lt; N1 and j &amp;lt; N2: if nums1[i] == nums2[j]: return nums1[i] if nums1[i] &amp;lt; nums2[j]: i += 1 else: j += 1 return -1</description></item><item><title>2709. Greatest Common Divisor Traversal</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2709/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/hard/2709/</guid><description>LeetCode problem 2709
from collections import defaultdict from typing import List class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.clusterSize = [1] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1, root2 = self.find(node1), self.find(node2) if root1 == root2: return False # No union made since they are already in the same set if self.clusterSize[root1] &amp;gt; self.clusterSize[root2]: self.parent[root2] = root1 self.clusterSize[root1] += self.clusterSize[root2] else: self.parent[root1] = root2 self.clusterSize[root2] += self.</description></item><item><title>2839. Check if Strings Can be Made Equal With Operations I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2839/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2839/</guid><description>LeetCode Problem
Problem Statement You are given two strings s1 and s2, both of length 4, consisting of lowercase English letters. The objective is to find out if it&amp;rsquo;s possible to make the two strings equal by swapping certain pairs of characters.
Naive Solution A naive approach would be to try out all possible swap combinations. However, this can be very inefficient, especially when the strings have a large number of characters.
Hints &amp;amp; Tips Observe that the swapping condition is quite specific: j - i = 2.</description></item><item><title>2840. Check if Strings Can be Made Equal With Operations II</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2840/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2840/</guid><description>LeetCode Problem 2840
Problem Statement You are given two strings s1 and s2, both of length n, consisting of lowercase English letters. You can apply certain operations to make them equal. The question is, is it possible?
Naive Solution A naive approach would be to try all possible swap operations and compare the two strings at each step, which would be highly inefficient.
Hints &amp;amp; Tips Observe that swapping can only occur at indices i and j where j - i is even.</description></item><item><title>2841. Maximum Sum of Almost Unique Subarray</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2841/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2841/</guid><description>LeetCode Problem 2841
Problem Statement You are given an integer array nums and two positive integers m and k.
The task is to return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray is almost unique if it contains at least m pairwise distinct elements.
Naive Solution A naive solution would be to generate all the possible subarrays of length k and check each one to see if it is almost unique and what its sum is.</description></item><item><title>2855. Minimum Right Shifts to Sort the Array</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2855/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2855/</guid><description>LeetCode problem 2855
class Solution: def minimumRightShifts(self, nums: List[int]) -&amp;gt; int: n = len(nums) i = 1 while i &amp;lt; n and nums[i - 1] &amp;lt; nums[i]: i += 1 k = i + 1 while k &amp;lt; n and nums[k - 1] &amp;lt; nums[k] &amp;lt; nums[0]: k += 1 return -1 if k &amp;lt; n else n - i</description></item><item><title>2856. Minimum Array Length After Pair Removals</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2856/</link><pubDate>Sat, 16 Sep 2023 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2856/</guid><description>LeetCode problem 2856
Problem Statement Given a 0-indexed sorted array of integers nums, you can perform a specific operation an unlimited number of times:
Choose two indices, i and j, where i &amp;lt; j and nums[i] &amp;lt; nums[j]. Remove the elements at indices i and j from nums. The remaining elements retain their original order and the array is re-indexed. The task is to determine and return the smallest possible length of nums after executing the operation as many times as you wish.</description></item><item><title>2859. Sum of Values at Indices With K Set Bits</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2859/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2859/</guid><description>LeetCode problem 2859
class Solution: def sumIndicesWithKSetBits(self, nums: List[int], k: int) -&amp;gt; int: return sum(x for i, x in enumerate(nums) if i.bit_count() == k)</description></item><item><title>2864. Maximum Odd Binary Number</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2864/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2864/</guid><description>LeetCode problem 2864
class Solution: def maximumOddBinaryNumber(self, s: str) -&amp;gt; str: ones = [] zeros = [] for c in s: if c == &amp;#39;0&amp;#39;: zeros.append(c) else: ones.append(c) zeros = &amp;#39;&amp;#39;.join(zeros) ones = &amp;#39;&amp;#39;.join(ones) if len(ones) &amp;gt; 1: res = ones[1:] + zeros + &amp;#39;1&amp;#39; return res return zeros + ones class Solution: def maximumOddBinaryNumber(self, s: str) -&amp;gt; str: cnt = s.count(&amp;#34;1&amp;#34;) return &amp;#34;1&amp;#34; * (cnt - 1) + (len(s) - cnt) * &amp;#34;0&amp;#34; + &amp;#34;1&amp;#34;</description></item><item><title>2869. Minimum Operations to Collect Elements</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2869/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2869/</guid><description>LeetCode problem 2869
class Solution: def minOperations(self, nums: List[int], k: int) -&amp;gt; int: is_added = [False] * k count = 0 n = len(nums) for i in range(n - 1, -1, -1): if nums[i] &amp;gt; k or is_added[nums[i] - 1]: continue is_added[nums[i] - 1] = True count += 1 if count == k: return n - i</description></item><item><title>2873. Maximum Value of an Ordered Triplet I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2873/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2873/</guid><description>LeetCode problem 2873
class Solution: def maximumTripletValue(self, nums: List[int]) -&amp;gt; int: res = mx = mx_diff = 0 for num in nums: res = max(res, mx_diff * num) mx = max(mx, num) mx_diff = max(mx_diff, mx - num) return res</description></item><item><title>2877. Create a DataFrame from List</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2877/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2877/</guid><description>LeetCode problem 2877
import pandas as pd def createDataframe(student_data: List[List[int]]) -&amp;gt; pd.DataFrame: return pd.DataFrame(student_data, columns=[&amp;#39;student_id&amp;#39;, &amp;#39;age&amp;#39;])</description></item><item><title>2878. Get the Size of a DataFrame</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2878/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2878/</guid><description>LeetCode problem 2878
import pandas as pd def getDataframeSize(players: pd.DataFrame) -&amp;gt; List[int]: return list(players.shape)</description></item><item><title>2879. Display the First Three Rows</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2879/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2879/</guid><description>LeetCode problem 2879
import pandas as pd def selectFirstRows(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: return employees.head(3)</description></item><item><title>2880. Select Data</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2880/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2880/</guid><description>LeetCode problem 2880
import pandas as pd def selectData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;student_id&amp;#39;] == 101][[&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;]]</description></item><item><title>2881. Create a New Column</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2881/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2881/</guid><description>LeetCode problem 2881
import pandas as pd def createBonusColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;bonus&amp;#39;] = employees[&amp;#39;salary&amp;#39;] * 2 return employees</description></item><item><title>2882. Drop Duplicate Rows</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2882/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2882/</guid><description>LeetCode problem 2882
import pandas as pd def dropDuplicateEmails(customers: pd.DataFrame) -&amp;gt; pd.DataFrame: return customers.drop_duplicates(subset=[&amp;#39;email&amp;#39;])</description></item><item><title>2883. Drop Missing Data</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2883/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2883/</guid><description>LeetCode problem 2883
import pandas as pd def dropMissingData(students: pd.DataFrame) -&amp;gt; pd.DataFrame: return students[students[&amp;#39;name&amp;#39;].notnull()]</description></item><item><title>2884. Modify Columns</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2884/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2884/</guid><description>LeetCode problem 2884
import pandas as pd def modifySalaryColumn(employees: pd.DataFrame) -&amp;gt; pd.DataFrame: employees[&amp;#39;salary&amp;#39;] *= 2 return employees</description></item><item><title>2885. Rename Columns</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2885/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2885/</guid><description>LeetCode problem 2885
import pandas as pd def renameColumns(students: pd.DataFrame) -&amp;gt; pd.DataFrame: students.rename( columns={ &amp;#39;id&amp;#39;: &amp;#39;student_id&amp;#39;, &amp;#39;first&amp;#39;: &amp;#39;first_name&amp;#39;, &amp;#39;last&amp;#39;: &amp;#39;last_name&amp;#39;, &amp;#39;age&amp;#39;: &amp;#39;age_in_years&amp;#39;, }, inplace=True, ) return students</description></item><item><title>2886. Change Data Type</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2886/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2886/</guid><description>LeetCode problem 2886
import pandas as pd def changeDatatype(students: pd.DataFrame) -&amp;gt; pd.DataFrame: students[&amp;#39;grade&amp;#39;] = students[&amp;#39;grade&amp;#39;].astype(int) return students</description></item><item><title>2887. Fill Missing Data</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2887/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2887/</guid><description>LeetCode problem 2887
import pandas as pd def fillMissingValues(products: pd.DataFrame) -&amp;gt; pd.DataFrame: products[&amp;#39;quantity&amp;#39;] = products[&amp;#39;quantity&amp;#39;].fillna(0) return products</description></item><item><title>2888. Reshape Data Concatenate</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2888/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2888/</guid><description>LeetCode problem 2888
import pandas as pd def concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.concat([df1, df2], ignore_index=True)</description></item><item><title>2889. Reshape Data Pivot</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2889/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2889/</guid><description>LeetCode problem 2889
import pandas as pd def pivotTable(weather: pd.DataFrame) -&amp;gt; pd.DataFrame: return weather.pivot(index=&amp;#39;month&amp;#39;, columns=&amp;#39;city&amp;#39;, values=&amp;#39;temperature&amp;#39;)</description></item><item><title>2890. Reshape Data Melt</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2890/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2890/</guid><description>LeetCode problem 2890
import pandas as pd def meltTable(report: pd.DataFrame) -&amp;gt; pd.DataFrame: return pd.melt(report, id_vars=[&amp;#39;product&amp;#39;], var_name=&amp;#39;quarter&amp;#39;, value_name=&amp;#39;sales&amp;#39;)</description></item><item><title>2891. Method Chaining</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2891/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2891/</guid><description>LeetCode problem 2891
import pandas as pd def findHeavyAnimals(animals: pd.DataFrame) -&amp;gt; pd.DataFrame: return animals[animals[&amp;#39;weight&amp;#39;] &amp;gt; 100].sort_values(&amp;#39;weight&amp;#39;, ascending=False)[ [&amp;#39;name&amp;#39;] ]</description></item><item><title>2894. Divisible and Non-divisible Sums Difference</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2894/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2894/</guid><description>LeetCode problem 2894
class Solution: def differenceOfSums(self, n: int, m: int) -&amp;gt; int: return sum(i if i % m else -i for i in range(1, n + 1))</description></item><item><title>2899. Last Visited Integers</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2899/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2899/</guid><description>LeetCode problem 2899
class Solution: def lastVisitedIntegers(self, words: List[str]) -&amp;gt; List[int]: nums = [] res = [] k = 0 for w in words: if w == &amp;#34;prev&amp;#34;: k += 1 i = len(nums) - k res.append(-1 if i &amp;lt; 0 else nums[i]) else: k = 0 nums.append(int(w)) return res</description></item><item><title>2903. Find Indices With Index and Value Difference I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2903/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2903/</guid><description>LeetCode problem 2903
class Solution: def findIndices( self, nums: List[int], indexDifference: int, valueDifference: int ) -&amp;gt; List[int]: mi = mx = 0 for i in range(indexDifference, len(nums)): j = i - indexDifference if nums[j] &amp;lt; nums[mi]: mi = j if nums[j] &amp;gt; nums[mx]: mx = j if nums[i] - nums[mi] &amp;gt;= valueDifference: return [mi, i] if nums[mx] - nums[i] &amp;gt;= valueDifference: return [mx, i] return [-1, -1]</description></item><item><title>2908. Minimum Sum of Mountain Triplets I</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2908/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/easy/2908/</guid><description>LeetCode problem 2908
class Solution: def minimumSum(self, nums: List[int]) -&amp;gt; int: n = len(nums) right = [inf] * (n + 1) for i in range(n - 1, -1, -1): right[i] = min(right[i + 1], nums[i]) res = left = inf for i, x in enumerate(nums): if left &amp;lt; x and right[i + 1] &amp;lt; x: res = min(res, left + x + right[i + 1]) left = min(left, x) return -1 if res == inf else res</description></item><item><title>2971. Find Polygon With the Largest Perimeter</title><link>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2971/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://romankurnovskii.com/ru/tracks/algorithms-101/leetcode/medium/2971/</guid><description>LeetCode problem 2971
class Solution: def largestPerimeter(self, nums: List[int]) -&amp;gt; int: nums.sort() s = list(accumulate(nums, initial=0)) res = -1 for k in range(3, len(nums) + 1): if s[k - 1] &amp;gt; nums[k - 1]: res = max(res, s[k]) return res</description></item></channel></rss>